// Package Base comment
// This file was generated by ksf2go 1.3.20
// Generated from PermControl.ksf
package Base

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"go.k8sf.cloud/go/KsfGo/ksf"
	m "go.k8sf.cloud/go/KsfGo/ksf/model"
	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
	"go.k8sf.cloud/go/KsfGo/ksf/protocol/kup"
	"go.k8sf.cloud/go/KsfGo/ksf/protocol/res/basef"
	"go.k8sf.cloud/go/KsfGo/ksf/protocol/res/requestf"
	"go.k8sf.cloud/go/KsfGo/ksf/util/current"
	"go.k8sf.cloud/go/KsfGo/ksf/util/tools"
	"go.k8sf.cloud/go/KsfGo/ksf/util/trace"
	"net"
	"unsafe"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = fmt.Errorf
	_ = codec.FromInt8
	_ = unsafe.Pointer(nil)
	_ = bytes.ErrTooLarge
	_ = net.UDPConn{}
)

// RBACWithDomainsManager struct
type RBACWithDomainsManager struct {
	servant m.Servant
}

// GetUsersForRoleInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetUsersForRoleInDomain(role string, domain string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetUsersForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*users = make([]string, length)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {

			err = readBuf.ReadString(&(*users)[i1], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetUsersForRoleInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetUsersForRoleInDomainWithContext(ksfCtx context.Context, role string, domain string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["role"] = role
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetUsersForRoleInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetUsersForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*users = make([]string, length)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {

			err = readBuf.ReadString(&(*users)[i2], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["users"] = *users
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetUsersForRoleInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetUsersForRoleInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetUsersForRoleInDomainOneWayWithContext(ksfCtx context.Context, role string, domain string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetUsersForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetRolesForUserInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetRolesForUserInDomain(user string, domain string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*roles = make([]string, length)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {

			err = readBuf.ReadString(&(*roles)[i3], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetRolesForUserInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetRolesForUserInDomainWithContext(ksfCtx context.Context, user string, domain string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["user"] = user
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetRolesForUserInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*roles = make([]string, length)
		for i4, e4 := int32(0), length; i4 < e4; i4++ {

			err = readBuf.ReadString(&(*roles)[i4], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["roles"] = *roles
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetRolesForUserInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetRolesForUserInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetRolesForUserInDomainOneWayWithContext(ksfCtx context.Context, user string, domain string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetPermissionsForRoleInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetPermissionsForRoleInDomain(role string, domain string, permissions *[]RolePermission, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*permissions = make([]RolePermission, length)
		for i5, e5 := int32(0), length; i5 < e5; i5++ {

			err = (*permissions)[i5].ReadBlock(readBuf, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetPermissionsForRoleInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetPermissionsForRoleInDomainWithContext(ksfCtx context.Context, role string, domain string, permissions *[]RolePermission, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["role"] = role
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetPermissionsForRoleInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*permissions = make([]RolePermission, length)
		for i6, e6 := int32(0), length; i6 < e6; i6++ {

			err = (*permissions)[i6].ReadBlock(readBuf, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["permissions"] = *permissions
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetPermissionsForRoleInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetPermissionsForRoleInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetPermissionsForRoleInDomainOneWayWithContext(ksfCtx context.Context, role string, domain string, permissions *[]RolePermission, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetRolesForUser is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetRolesForUser(user string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetRolesForUser", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*roles = make([]string, length)
		for i7, e7 := int32(0), length; i7 < e7; i7++ {

			err = readBuf.ReadString(&(*roles)[i7], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetRolesForUserWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetRolesForUserWithContext(ksfCtx context.Context, user string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["user"] = user
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetRolesForUser", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetRolesForUser", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*roles = make([]string, length)
		for i8, e8 := int32(0), length; i8 < e8; i8++ {

			err = readBuf.ReadString(&(*roles)[i8], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["roles"] = *roles
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetRolesForUser", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetRolesForUserOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetRolesForUserOneWayWithContext(ksfCtx context.Context, user string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetRolesForUser", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetUsersForRole is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetUsersForRole(role string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetUsersForRole", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*users = make([]string, length)
		for i9, e9 := int32(0), length; i9 < e9; i9++ {

			err = readBuf.ReadString(&(*users)[i9], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetUsersForRoleWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetUsersForRoleWithContext(ksfCtx context.Context, role string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["role"] = role
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetUsersForRole", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetUsersForRole", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*users = make([]string, length)
		for i10, e10 := int32(0), length; i10 < e10; i10++ {

			err = readBuf.ReadString(&(*users)[i10], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["users"] = *users
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetUsersForRole", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetUsersForRoleOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetUsersForRoleOneWayWithContext(ksfCtx context.Context, role string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetUsersForRole", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllUsersByDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllUsersByDomain(domain string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllUsersByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*users = make([]string, length)
		for i11, e11 := int32(0), length; i11 < e11; i11++ {

			err = readBuf.ReadString(&(*users)[i11], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllUsersByDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllUsersByDomainWithContext(ksfCtx context.Context, domain string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllUsersByDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllUsersByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*users = make([]string, length)
		for i12, e12 := int32(0), length; i12 < e12; i12++ {

			err = readBuf.ReadString(&(*users)[i12], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["users"] = *users
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllUsersByDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllUsersByDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllUsersByDomainOneWayWithContext(ksfCtx context.Context, domain string, users *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetAllUsersByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllRolesByDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllRolesByDomain(domain string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllRolesByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*roles = make([]string, length)
		for i13, e13 := int32(0), length; i13 < e13; i13++ {

			err = readBuf.ReadString(&(*roles)[i13], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllRolesByDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllRolesByDomainWithContext(ksfCtx context.Context, domain string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllRolesByDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllRolesByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*roles = make([]string, length)
		for i14, e14 := int32(0), length; i14 < e14; i14++ {

			err = readBuf.ReadString(&(*roles)[i14], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["roles"] = *roles
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllRolesByDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllRolesByDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllRolesByDomainOneWayWithContext(ksfCtx context.Context, domain string, roles *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetAllRolesByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllPermissionsByDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllPermissionsByDomain(domain string, permissions *[]UserPermission, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllPermissionsByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*permissions = make([]UserPermission, length)
		for i15, e15 := int32(0), length; i15 < e15; i15++ {

			err = (*permissions)[i15].ReadBlock(readBuf, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllPermissionsByDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllPermissionsByDomainWithContext(ksfCtx context.Context, domain string, permissions *[]UserPermission, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllPermissionsByDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllPermissionsByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(2, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*permissions = make([]UserPermission, length)
		for i16, e16 := int32(0), length; i16 < e16; i16++ {

			err = (*permissions)[i16].ReadBlock(readBuf, 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["permissions"] = *permissions
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllPermissionsByDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllPermissionsByDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllPermissionsByDomainOneWayWithContext(ksfCtx context.Context, domain string, permissions *[]UserPermission, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(domain, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetAllPermissionsByDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllDomains is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllDomains(domains *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*domains)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *domains {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllDomains", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*domains = make([]string, length)
		for i17, e17 := int32(0), length; i17 < e17; i17++ {

			err = readBuf.ReadString(&(*domains)[i17], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllDomainsWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllDomainsWithContext(ksfCtx context.Context, domains *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*domains)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *domains {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllDomains", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "GetAllDomains", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return ret, err
		}

		*domains = make([]string, length)
		for i18, e18 := int32(0), length; i18 < e18; i18++ {

			err = readBuf.ReadString(&(*domains)[i18], 0, false)
			if err != nil {
				return ret, err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return ret, err
		}

	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			value["domains"] = *domains
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "GetAllDomains", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// GetAllDomainsOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) GetAllDomainsOneWayWithContext(ksfCtx context.Context, domains *[]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(*domains)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range *domains {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "GetAllDomains", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddRoleForUserInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddRoleForUserInDomain(user string, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(role, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 3)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddRoleForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddRoleForUserInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddRoleForUserInDomainWithContext(ksfCtx context.Context, user string, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(role, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 3)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["user"] = user
			value["role"] = role
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddRoleForUserInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddRoleForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddRoleForUserInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddRoleForUserInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddRoleForUserInDomainOneWayWithContext(ksfCtx context.Context, user string, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(role, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 3)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "AddRoleForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddRolesForUserInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddRolesForUserInDomain(params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddRolesForUserInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddRolesForUserInDomainWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["params"] = params
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddRolesForUserInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddRolesForUserInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddRolesForUserInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddRolesForUserInDomainOneWayWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "AddRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddPermissionForRoleInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddPermissionForRoleInDomain(role string, domain string, objt string, action string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(objt, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(action, 4)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddPermissionForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddPermissionForRoleInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddPermissionForRoleInDomainWithContext(ksfCtx context.Context, role string, domain string, objt string, action string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(objt, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(action, 4)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["role"] = role
			value["domain"] = domain
			value["objt"] = objt
			value["action"] = action
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddPermissionForRoleInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddPermissionForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddPermissionForRoleInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddPermissionForRoleInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddPermissionForRoleInDomainOneWayWithContext(ksfCtx context.Context, role string, domain string, objt string, action string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(objt, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(action, 4)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "AddPermissionForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddPermissionsForRoleInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddPermissionsForRoleInDomain(params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddPermissionsForRoleInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddPermissionsForRoleInDomainWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["params"] = params
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddPermissionsForRoleInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "AddPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "AddPermissionsForRoleInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// AddPermissionsForRoleInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) AddPermissionsForRoleInDomainOneWayWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "AddPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DelPermissionsForRoleInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DelPermissionsForRoleInDomain(params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DelPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DelPermissionsForRoleInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DelPermissionsForRoleInDomainWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["params"] = params
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DelPermissionsForRoleInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DelPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DelPermissionsForRoleInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DelPermissionsForRoleInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DelPermissionsForRoleInDomainOneWayWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DelPermissionsForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRoleForUserInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRoleForUserInDomain(user string, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(role, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 3)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRoleForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRoleForUserInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRoleForUserInDomainWithContext(ksfCtx context.Context, user string, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(role, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 3)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["user"] = user
			value["role"] = role
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRoleForUserInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRoleForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRoleForUserInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRoleForUserInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRoleForUserInDomainOneWayWithContext(ksfCtx context.Context, user string, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(role, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 3)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DeleteRoleForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRolesForUserInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRolesForUserInDomain(params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRolesForUserInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRolesForUserInDomainWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["params"] = params
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRolesForUserInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRolesForUserInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRolesForUserInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRolesForUserInDomainOneWayWithContext(ksfCtx context.Context, params [][]string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(params)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range params {

		err = buf.WriteHead(codec.LIST, 0)
		if err != nil {
			return ret, err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}

		for _, v := range v {

			err = buf.WriteString(v, 0)
			if err != nil {
				return ret, err
			}

		}
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DeleteRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteAllRolesForUserInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteAllRolesForUserInDomain(user string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteAllRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteAllRolesForUserInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteAllRolesForUserInDomainWithContext(ksfCtx context.Context, user string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["user"] = user
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteAllRolesForUserInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteAllRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteAllRolesForUserInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteAllRolesForUserInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteAllRolesForUserInDomainOneWayWithContext(ksfCtx context.Context, user string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DeleteAllRolesForUserInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteUser is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteUser(user string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteUser", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteUserWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteUserWithContext(ksfCtx context.Context, user string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["user"] = user
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteUser", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteUser", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteUser", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteUserOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteUserOneWayWithContext(ksfCtx context.Context, user string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(user, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DeleteUser", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRole is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRole(role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRole", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRoleWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRoleWithContext(ksfCtx context.Context, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["role"] = role
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRole", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRole", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRole", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRoleOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRoleOneWayWithContext(ksfCtx context.Context, role string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DeleteRole", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRoles is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRoles(roles []string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRoles", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRolesWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRolesWithContext(ksfCtx context.Context, roles []string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["roles"] = roles
			value["domain"] = domain
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRoles", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeleteRoles", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeleteRoles", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeleteRolesOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeleteRolesOneWayWithContext(ksfCtx context.Context, roles []string, domain string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteInt32(int32(len(roles)), 0)
	if err != nil {
		return ret, err
	}

	for _, v := range roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return ret, err
		}

	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DeleteRoles", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeletePermissionForRoleInDomain is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeletePermissionForRoleInDomain(role string, domain string, objt string, act string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(objt, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(act, 4)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}
	ksfResp := new(requestf.ResponsePacket)
	ksfCtx := context.Background()

	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeletePermissionForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeletePermissionForRoleInDomainWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeletePermissionForRoleInDomainWithContext(ksfCtx context.Context, role string, domain string, objt string, act string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(objt, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(act, 4)
	if err != nil {
		return ret, err
	}

	traceData, ok := current.GetTraceData(ksfCtx)
	if ok && traceData.TraceCall {
		traceData.NewSpan()
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCS, uint(buf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value["role"] = role
			value["domain"] = domain
			value["objt"] = objt
			value["act"] = act
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCS), trace.TraceAnnotationCS, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeletePermissionForRoleInDomain", 0, traceParam, "")
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 0, "DeletePermissionForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
	err = readBuf.ReadInt32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	if ok && traceData.TraceCall {
		var traceParam string
		traceParamFlag := traceData.NeedTraceParam(trace.EstCR, uint(readBuf.Len()))
		if traceParamFlag == trace.EnpNormal {
			value := map[string]interface{}{}
			value[""] = ret
			p, _ := json.Marshal(value)
			traceParam = string(p)
		} else if traceParamFlag == trace.EnpOverMaxLen {
			traceParam = "{\"trace_param_over_max_len\":true}"
		}
		ksf.Trace(traceData.GetTraceKey(trace.EstCR), trace.TraceAnnotationCR, ksf.GetClientConfig().ModuleName, obj.servant.Name(), "DeletePermissionForRoleInDomain", int(ksfResp.IRet), traceParam, "")
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// DeletePermissionForRoleInDomainOneWayWithContext is the proxy function for the method defined in the ksf file, with the context
func (obj *RBACWithDomainsManager) DeletePermissionForRoleInDomainOneWayWithContext(ksfCtx context.Context, role string, domain string, objt string, act string, opts ...map[string]string) (ret int32, err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	buf := codec.NewBuffer()
	err = buf.WriteString(role, 1)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(domain, 2)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(objt, 3)
	if err != nil {
		return ret, err
	}

	err = buf.WriteString(act, 4)
	if err != nil {
		return ret, err
	}

	var statusMap map[string]string
	var contextMap map[string]string
	if len(opts) == 1 {
		contextMap = opts[0]
	} else if len(opts) == 2 {
		contextMap = opts[0]
		statusMap = opts[1]
	}

	ksfResp := new(requestf.ResponsePacket)
	err = obj.servant.KsfInvoke(ksfCtx, 1, "DeletePermissionForRoleInDomain", buf.ToBytes(), statusMap, contextMap, ksfResp)
	if err != nil {
		return ret, err
	}

	if len(opts) == 1 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range contextMap {
			delete(contextMap, k)
		}
		for k, v := range ksfResp.Context {
			contextMap[k] = v
		}
		for k := range statusMap {
			delete(statusMap, k)
		}
		for k, v := range ksfResp.Status {
			statusMap[k] = v
		}
	}
	_ = length
	_ = have
	_ = ty
	return ret, nil
}

// SetServant sets servant for the service.
func (obj *RBACWithDomainsManager) SetServant(servant m.Servant) {
	obj.servant = servant
}

// GetServant gets servant for the service.
func (obj *RBACWithDomainsManager) GetServant() (servant *m.Servant) {
	return &obj.servant
}

// SetOnConnectCallback
func (obj *RBACWithDomainsManager) SetOnConnectCallback(callback func(string)) {
	obj.servant.SetOnConnectCallback(callback)
}

// SetOnCloseCallback
func (obj *RBACWithDomainsManager) SetOnCloseCallback(callback func(string)) {
	obj.servant.SetOnCloseCallback(callback)
}

// SetKsfCallback
func (obj *RBACWithDomainsManager) SetKsfCallback(callback RBACWithDomainsManagerKsfCallback) {
	var push RBACWithDomainsManagerPushCallback
	push.Cb = callback
	obj.servant.SetKsfCallback(&push)
}

// SetPushCallback
func (obj *RBACWithDomainsManager) SetPushCallback(callback func([]byte)) {
	obj.servant.SetPushCallback(callback)
}
func (obj *RBACWithDomainsManager) req2Byte(rsp *requestf.ResponsePacket) []byte {
	req := requestf.RequestPacket{}
	req.IVersion = rsp.IVersion
	req.IRequestId = rsp.IRequestId
	req.IMessageType = rsp.IMessageType
	req.CPacketType = rsp.CPacketType
	req.Context = rsp.Context
	req.Status = rsp.Status
	req.SBuffer = rsp.SBuffer

	os := codec.NewBuffer()
	req.WriteTo(os)
	bs := os.ToBytes()
	sbuf := bytes.NewBuffer(nil)
	sbuf.Write(make([]byte, 4))
	sbuf.Write(bs)
	length := sbuf.Len()
	binary.BigEndian.PutUint32(sbuf.Bytes(), uint32(length))
	return sbuf.Bytes()
}

func (obj *RBACWithDomainsManager) rsp2Byte(rsp *requestf.ResponsePacket) []byte {
	if rsp.IVersion == basef.KUPVERSION {
		return obj.req2Byte(rsp)
	}
	os := codec.NewBuffer()
	rsp.WriteTo(os)
	bs := os.ToBytes()
	sbuf := bytes.NewBuffer(nil)
	sbuf.Write(make([]byte, 4))
	sbuf.Write(bs)
	length := sbuf.Len()
	binary.BigEndian.PutUint32(sbuf.Bytes(), uint32(length))
	return sbuf.Bytes()
}

// KsfPing
func (obj *RBACWithDomainsManager) KsfPing() {
	ksfCtx := context.Background()
	obj.servant.KsfPing(ksfCtx)
}

// KsfSetTimeout sets the timeout for the servant which is in ms.
func (obj *RBACWithDomainsManager) KsfSetTimeout(timeout int) {
	obj.servant.KsfSetTimeout(timeout)
}

// KsfSetVersion default as KSFVERSION,you can set JSONVERSION.
func (obj *RBACWithDomainsManager) KsfSetVersion(version int16) {
	obj.servant.KsfSetVersion(version)
}

// KsfSetProtocol sets the protocol for the servant.
func (obj *RBACWithDomainsManager) KsfSetProtocol(p m.Protocol) {
	obj.servant.KsfSetProtocol(p)
}

// AddServant adds servant  for the service.
func (obj *RBACWithDomainsManager) AddServant(imp RBACWithDomainsManagerServant, servantObj string) {
	ksf.AddServant(obj, imp, servantObj)
}

// AddServantWithContext adds servant  for the service with context.
func (obj *RBACWithDomainsManager) AddServantWithContext(imp RBACWithDomainsManagerServantWithContext, servantObj string) {
	ksf.AddServantWithContext(obj, imp, servantObj)
}

type RBACWithDomainsManagerServant interface {
	GetUsersForRoleInDomain(role string, domain string, users *[]string) (ret int32, err error)
	GetRolesForUserInDomain(user string, domain string, roles *[]string) (ret int32, err error)
	GetPermissionsForRoleInDomain(role string, domain string, permissions *[]RolePermission) (ret int32, err error)
	GetRolesForUser(user string, roles *[]string) (ret int32, err error)
	GetUsersForRole(role string, users *[]string) (ret int32, err error)
	GetAllUsersByDomain(domain string, users *[]string) (ret int32, err error)
	GetAllRolesByDomain(domain string, roles *[]string) (ret int32, err error)
	GetAllPermissionsByDomain(domain string, permissions *[]UserPermission) (ret int32, err error)
	GetAllDomains(domains *[]string) (ret int32, err error)
	AddRoleForUserInDomain(user string, role string, domain string) (ret int32, err error)
	AddRolesForUserInDomain(params [][]string) (ret int32, err error)
	AddPermissionForRoleInDomain(role string, domain string, objt string, action string) (ret int32, err error)
	AddPermissionsForRoleInDomain(params [][]string) (ret int32, err error)
	DelPermissionsForRoleInDomain(params [][]string) (ret int32, err error)
	DeleteRoleForUserInDomain(user string, role string, domain string) (ret int32, err error)
	DeleteRolesForUserInDomain(params [][]string) (ret int32, err error)
	DeleteAllRolesForUserInDomain(user string, domain string) (ret int32, err error)
	DeleteUser(user string, domain string) (ret int32, err error)
	DeleteRole(role string, domain string) (ret int32, err error)
	DeleteRoles(roles []string, domain string) (ret int32, err error)
	DeletePermissionForRoleInDomain(role string, domain string, objt string, act string) (ret int32, err error)
}
type RBACWithDomainsManagerServantWithContext interface {
	GetUsersForRoleInDomain(ksfCtx context.Context, role string, domain string, users *[]string) (ret int32, err error)
	GetRolesForUserInDomain(ksfCtx context.Context, user string, domain string, roles *[]string) (ret int32, err error)
	GetPermissionsForRoleInDomain(ksfCtx context.Context, role string, domain string, permissions *[]RolePermission) (ret int32, err error)
	GetRolesForUser(ksfCtx context.Context, user string, roles *[]string) (ret int32, err error)
	GetUsersForRole(ksfCtx context.Context, role string, users *[]string) (ret int32, err error)
	GetAllUsersByDomain(ksfCtx context.Context, domain string, users *[]string) (ret int32, err error)
	GetAllRolesByDomain(ksfCtx context.Context, domain string, roles *[]string) (ret int32, err error)
	GetAllPermissionsByDomain(ksfCtx context.Context, domain string, permissions *[]UserPermission) (ret int32, err error)
	GetAllDomains(ksfCtx context.Context, domains *[]string) (ret int32, err error)
	AddRoleForUserInDomain(ksfCtx context.Context, user string, role string, domain string) (ret int32, err error)
	AddRolesForUserInDomain(ksfCtx context.Context, params [][]string) (ret int32, err error)
	AddPermissionForRoleInDomain(ksfCtx context.Context, role string, domain string, objt string, action string) (ret int32, err error)
	AddPermissionsForRoleInDomain(ksfCtx context.Context, params [][]string) (ret int32, err error)
	DelPermissionsForRoleInDomain(ksfCtx context.Context, params [][]string) (ret int32, err error)
	DeleteRoleForUserInDomain(ksfCtx context.Context, user string, role string, domain string) (ret int32, err error)
	DeleteRolesForUserInDomain(ksfCtx context.Context, params [][]string) (ret int32, err error)
	DeleteAllRolesForUserInDomain(ksfCtx context.Context, user string, domain string) (ret int32, err error)
	DeleteUser(ksfCtx context.Context, user string, domain string) (ret int32, err error)
	DeleteRole(ksfCtx context.Context, role string, domain string) (ret int32, err error)
	DeleteRoles(ksfCtx context.Context, roles []string, domain string) (ret int32, err error)
	DeletePermissionForRoleInDomain(ksfCtx context.Context, role string, domain string, objt string, act string) (ret int32, err error)

	DoClose(ctx context.Context)
}

// Dispatch is used to call the server side implement for the method defined in the ksf file. withContext shows using context or not.
func (obj *RBACWithDomainsManager) Dispatch(ksfCtx context.Context, val interface{}, ksfReq *requestf.RequestPacket, ksfResp *requestf.ResponsePacket, withContext bool) (err error) {
	var (
		length int32
		have   bool
		ty     byte
	)
	readBuf := codec.NewReader(tools.Int8ToByte(ksfReq.SBuffer))
	buf := codec.NewBuffer()
	switch ksfReq.SFuncName {
	case "GetUsersForRoleInDomain":
		var role string
		var domain string
		var users []string
		users = make([]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&role, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["role"] = role
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetUsersForRoleInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetUsersForRoleInDomain(role, domain, &users)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetUsersForRoleInDomain(ksfCtx, role, domain, &users)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 3)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(users)), 0)
			if err != nil {
				return err
			}

			for _, v := range users {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(users)), 0)
			if err != nil {
				return err
			}

			for _, v := range users {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("users", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["users"] = users

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["users"] = users
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetUsersForRoleInDomain", 0, traceParam, "")
		}

	case "GetRolesForUserInDomain":
		var user string
		var domain string
		var roles []string
		roles = make([]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&user, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("user", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&user, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["user"])
				if err = json.Unmarshal(jsonStr, &user); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["user"] = user
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetRolesForUserInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetRolesForUserInDomain(user, domain, &roles)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetRolesForUserInDomain(ksfCtx, user, domain, &roles)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 3)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(roles)), 0)
			if err != nil {
				return err
			}

			for _, v := range roles {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(roles)), 0)
			if err != nil {
				return err
			}

			for _, v := range roles {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("roles", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["roles"] = roles

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["roles"] = roles
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetRolesForUserInDomain", 0, traceParam, "")
		}

	case "GetPermissionsForRoleInDomain":
		var role string
		var domain string
		var permissions []RolePermission
		permissions = make([]RolePermission, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&role, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["role"] = role
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetPermissionsForRoleInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetPermissionsForRoleInDomain(role, domain, &permissions)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetPermissionsForRoleInDomain(ksfCtx, role, domain, &permissions)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 3)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(permissions)), 0)
			if err != nil {
				return err
			}

			for _, v := range permissions {

				err = v.WriteBlock(buf, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(permissions)), 0)
			if err != nil {
				return err
			}

			for _, v := range permissions {

				err = v.WriteBlock(buf, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("permissions", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["permissions"] = permissions

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["permissions"] = permissions
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetPermissionsForRoleInDomain", 0, traceParam, "")
		}

	case "GetRolesForUser":
		var user string
		var roles []string
		roles = make([]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&user, 1, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("user", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&user, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["user"])
				if err = json.Unmarshal(jsonStr, &user); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["user"] = user
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetRolesForUser", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetRolesForUser(user, &roles)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetRolesForUser(ksfCtx, user, &roles)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 2)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(roles)), 0)
			if err != nil {
				return err
			}

			for _, v := range roles {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(roles)), 0)
			if err != nil {
				return err
			}

			for _, v := range roles {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("roles", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["roles"] = roles

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["roles"] = roles
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetRolesForUser", 0, traceParam, "")
		}

	case "GetUsersForRole":
		var role string
		var users []string
		users = make([]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&role, 1, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["role"] = role
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetUsersForRole", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetUsersForRole(role, &users)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetUsersForRole(ksfCtx, role, &users)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 2)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(users)), 0)
			if err != nil {
				return err
			}

			for _, v := range users {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(users)), 0)
			if err != nil {
				return err
			}

			for _, v := range users {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("users", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["users"] = users

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["users"] = users
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetUsersForRole", 0, traceParam, "")
		}

	case "GetAllUsersByDomain":
		var domain string
		var users []string
		users = make([]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&domain, 1, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllUsersByDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetAllUsersByDomain(domain, &users)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetAllUsersByDomain(ksfCtx, domain, &users)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 2)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(users)), 0)
			if err != nil {
				return err
			}

			for _, v := range users {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(users)), 0)
			if err != nil {
				return err
			}

			for _, v := range users {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("users", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["users"] = users

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["users"] = users
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllUsersByDomain", 0, traceParam, "")
		}

	case "GetAllRolesByDomain":
		var domain string
		var roles []string
		roles = make([]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&domain, 1, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllRolesByDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetAllRolesByDomain(domain, &roles)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetAllRolesByDomain(ksfCtx, domain, &roles)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 2)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(roles)), 0)
			if err != nil {
				return err
			}

			for _, v := range roles {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(roles)), 0)
			if err != nil {
				return err
			}

			for _, v := range roles {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("roles", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["roles"] = roles

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["roles"] = roles
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllRolesByDomain", 0, traceParam, "")
		}

	case "GetAllPermissionsByDomain":
		var domain string
		var permissions []UserPermission
		permissions = make([]UserPermission, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&domain, 1, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllPermissionsByDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetAllPermissionsByDomain(domain, &permissions)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetAllPermissionsByDomain(ksfCtx, domain, &permissions)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 2)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(permissions)), 0)
			if err != nil {
				return err
			}

			for _, v := range permissions {

				err = v.WriteBlock(buf, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(permissions)), 0)
			if err != nil {
				return err
			}

			for _, v := range permissions {

				err = v.WriteBlock(buf, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("permissions", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["permissions"] = permissions

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["permissions"] = permissions
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllPermissionsByDomain", 0, traceParam, "")
		}

	case "GetAllDomains":
		var domains []string
		domains = make([]string, 0)

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllDomains", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.GetAllDomains(&domains)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.GetAllDomains(ksfCtx, &domains)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			err = buf.WriteHead(codec.LIST, 1)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(domains)), 0)
			if err != nil {
				return err
			}

			for _, v := range domains {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = buf.WriteHead(codec.LIST, 0)
			if err != nil {
				return err
			}

			err = buf.WriteInt32(int32(len(domains)), 0)
			if err != nil {
				return err
			}

			for _, v := range domains {

				err = buf.WriteString(v, 0)
				if err != nil {
					return err
				}

			}
			rspKup.PutBuffer("domains", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet
			rspJson["domains"] = domains

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				value["domains"] = domains
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "GetAllDomains", 0, traceParam, "")
		}

	case "AddRoleForUserInDomain":
		var user string
		var role string
		var domain string

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&user, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&role, 2, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 3, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("user", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&user, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["user"])
				if err = json.Unmarshal(jsonStr, &user); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["user"] = user
				value["role"] = role
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddRoleForUserInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.AddRoleForUserInDomain(user, role, domain)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.AddRoleForUserInDomain(ksfCtx, user, role, domain)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddRoleForUserInDomain", 0, traceParam, "")
		}

	case "AddRolesForUserInDomain":
		var params [][]string
		params = make([][]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			_, ty, err = readBuf.SkipToNoCheck(1, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i19, e19 := int32(0), length; i19 < e19; i19++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i19] = make([]string, length)
							for i20, e20 := int32(0), length; i20 < e20; i20++ {

								err = readBuf.ReadString(&params[i19][i20], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("params", &kupBuffer)
			readBuf.Reset(kupBuffer)
			_, ty, err = readBuf.SkipToNoCheck(0, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i21, e21 := int32(0), length; i21 < e21; i21++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i21] = make([]string, length)
							for i22, e22 := int32(0), length; i22 < e22; i22++ {

								err = readBuf.ReadString(&params[i21][i22], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["params"])
				if err = json.Unmarshal(jsonStr, &params); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["params"] = params
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddRolesForUserInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.AddRolesForUserInDomain(params)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.AddRolesForUserInDomain(ksfCtx, params)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddRolesForUserInDomain", 0, traceParam, "")
		}

	case "AddPermissionForRoleInDomain":
		var role string
		var domain string
		var objt string
		var action string

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&role, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&objt, 3, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&action, 4, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("objt", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&objt, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("action", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&action, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["objt"])
				if err = json.Unmarshal(jsonStr, &objt); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["action"])
				if err = json.Unmarshal(jsonStr, &action); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["role"] = role
				value["domain"] = domain
				value["objt"] = objt
				value["action"] = action
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddPermissionForRoleInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.AddPermissionForRoleInDomain(role, domain, objt, action)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.AddPermissionForRoleInDomain(ksfCtx, role, domain, objt, action)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddPermissionForRoleInDomain", 0, traceParam, "")
		}

	case "AddPermissionsForRoleInDomain":
		var params [][]string
		params = make([][]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			_, ty, err = readBuf.SkipToNoCheck(1, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i23, e23 := int32(0), length; i23 < e23; i23++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i23] = make([]string, length)
							for i24, e24 := int32(0), length; i24 < e24; i24++ {

								err = readBuf.ReadString(&params[i23][i24], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("params", &kupBuffer)
			readBuf.Reset(kupBuffer)
			_, ty, err = readBuf.SkipToNoCheck(0, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i25, e25 := int32(0), length; i25 < e25; i25++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i25] = make([]string, length)
							for i26, e26 := int32(0), length; i26 < e26; i26++ {

								err = readBuf.ReadString(&params[i25][i26], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["params"])
				if err = json.Unmarshal(jsonStr, &params); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["params"] = params
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddPermissionsForRoleInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.AddPermissionsForRoleInDomain(params)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.AddPermissionsForRoleInDomain(ksfCtx, params)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "AddPermissionsForRoleInDomain", 0, traceParam, "")
		}

	case "DelPermissionsForRoleInDomain":
		var params [][]string
		params = make([][]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			_, ty, err = readBuf.SkipToNoCheck(1, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i27, e27 := int32(0), length; i27 < e27; i27++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i27] = make([]string, length)
							for i28, e28 := int32(0), length; i28 < e28; i28++ {

								err = readBuf.ReadString(&params[i27][i28], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("params", &kupBuffer)
			readBuf.Reset(kupBuffer)
			_, ty, err = readBuf.SkipToNoCheck(0, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i29, e29 := int32(0), length; i29 < e29; i29++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i29] = make([]string, length)
							for i30, e30 := int32(0), length; i30 < e30; i30++ {

								err = readBuf.ReadString(&params[i29][i30], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["params"])
				if err = json.Unmarshal(jsonStr, &params); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["params"] = params
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DelPermissionsForRoleInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DelPermissionsForRoleInDomain(params)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DelPermissionsForRoleInDomain(ksfCtx, params)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DelPermissionsForRoleInDomain", 0, traceParam, "")
		}

	case "DeleteRoleForUserInDomain":
		var user string
		var role string
		var domain string

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&user, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&role, 2, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 3, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("user", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&user, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["user"])
				if err = json.Unmarshal(jsonStr, &user); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["user"] = user
				value["role"] = role
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRoleForUserInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DeleteRoleForUserInDomain(user, role, domain)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DeleteRoleForUserInDomain(ksfCtx, user, role, domain)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRoleForUserInDomain", 0, traceParam, "")
		}

	case "DeleteRolesForUserInDomain":
		var params [][]string
		params = make([][]string, 0)

		if ksfReq.IVersion == basef.KSFVERSION {

			_, ty, err = readBuf.SkipToNoCheck(1, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i31, e31 := int32(0), length; i31 < e31; i31++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i31] = make([]string, length)
							for i32, e32 := int32(0), length; i32 < e32; i32++ {

								err = readBuf.ReadString(&params[i31][i32], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("params", &kupBuffer)
			readBuf.Reset(kupBuffer)
			_, ty, err = readBuf.SkipToNoCheck(0, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				params = make([][]string, length)
				for i33, e33 := int32(0), length; i33 < e33; i33++ {

					have, ty, err = readBuf.SkipToNoCheck(0, false)
					if err != nil {
						return err
					}

					if have {
						if ty == codec.LIST {
							err = readBuf.ReadInt32(&length, 0, true)
							if err != nil {
								return err
							}

							params[i33] = make([]string, length)
							for i34, e34 := int32(0), length; i34 < e34; i34++ {

								err = readBuf.ReadString(&params[i33][i34], 0, false)
								if err != nil {
									return err
								}

							}
						} else if ty == codec.SimpleList {
							err = fmt.Errorf("not support SimpleList type")
							if err != nil {
								return err
							}

						} else {
							err = fmt.Errorf("require vector, but not")
							if err != nil {
								return err
							}

						}
					}
				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["params"])
				if err = json.Unmarshal(jsonStr, &params); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["params"] = params
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRolesForUserInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DeleteRolesForUserInDomain(params)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DeleteRolesForUserInDomain(ksfCtx, params)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRolesForUserInDomain", 0, traceParam, "")
		}

	case "DeleteAllRolesForUserInDomain":
		var user string
		var domain string

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&user, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("user", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&user, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["user"])
				if err = json.Unmarshal(jsonStr, &user); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["user"] = user
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteAllRolesForUserInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DeleteAllRolesForUserInDomain(user, domain)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DeleteAllRolesForUserInDomain(ksfCtx, user, domain)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteAllRolesForUserInDomain", 0, traceParam, "")
		}

	case "DeleteUser":
		var user string
		var domain string

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&user, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("user", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&user, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["user"])
				if err = json.Unmarshal(jsonStr, &user); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["user"] = user
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteUser", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DeleteUser(user, domain)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DeleteUser(ksfCtx, user, domain)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteUser", 0, traceParam, "")
		}

	case "DeleteRole":
		var role string
		var domain string

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&role, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["role"] = role
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRole", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DeleteRole(role, domain)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DeleteRole(ksfCtx, role, domain)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRole", 0, traceParam, "")
		}

	case "DeleteRoles":
		var roles []string
		roles = make([]string, 0)
		var domain string

		if ksfReq.IVersion == basef.KSFVERSION {

			_, ty, err = readBuf.SkipToNoCheck(1, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				roles = make([]string, length)
				for i35, e35 := int32(0), length; i35 < e35; i35++ {

					err = readBuf.ReadString(&roles[i35], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("roles", &kupBuffer)
			readBuf.Reset(kupBuffer)
			_, ty, err = readBuf.SkipToNoCheck(0, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				roles = make([]string, length)
				for i36, e36 := int32(0), length; i36 < e36; i36++ {

					err = readBuf.ReadString(&roles[i36], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["roles"])
				if err = json.Unmarshal(jsonStr, &roles); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["roles"] = roles
				value["domain"] = domain
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRoles", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DeleteRoles(roles, domain)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DeleteRoles(ksfCtx, roles, domain)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeleteRoles", 0, traceParam, "")
		}

	case "DeletePermissionForRoleInDomain":
		var role string
		var domain string
		var objt string
		var act string

		if ksfReq.IVersion == basef.KSFVERSION {

			err = readBuf.ReadString(&role, 1, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&domain, 2, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&objt, 3, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&act, 4, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			reqKup := kup.NewUniAttribute()
			reqKup.Decode(readBuf)

			var kupBuffer []byte

			reqKup.GetBuffer("role", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&role, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("domain", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&domain, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("objt", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&objt, 0, true)
			if err != nil {
				return err
			}

			reqKup.GetBuffer("act", &kupBuffer)
			readBuf.Reset(kupBuffer)
			err = readBuf.ReadString(&act, 0, true)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.JSONVERSION {
			var jsonData map[string]interface{}
			decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
			decoder.UseNumber()
			err = decoder.Decode(&jsonData)
			if err != nil {
				return fmt.Errorf("decode reqpacket failed, error: %+v", err)
			}
			{
				jsonStr, _ := json.Marshal(jsonData["role"])
				if err = json.Unmarshal(jsonStr, &role); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["domain"])
				if err = json.Unmarshal(jsonStr, &domain); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["objt"])
				if err = json.Unmarshal(jsonStr, &objt); err != nil {
					return err
				}
			}
			{
				jsonStr, _ := json.Marshal(jsonData["act"])
				if err = json.Unmarshal(jsonStr, &act); err != nil {
					return err
				}
			}

		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", ksfReq.IVersion)
			return err
		}

		traceData, ok := current.GetTraceData(ksfCtx)
		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSR, uint(readBuf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value["role"] = role
				value["domain"] = domain
				value["objt"] = objt
				value["act"] = act
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSR), trace.TraceAnnotationSR, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeletePermissionForRoleInDomain", 0, traceParam, "")
		}

		var funRet int32
		if !withContext {
			imp := val.(RBACWithDomainsManagerServant)
			funRet, err = imp.DeletePermissionForRoleInDomain(role, domain, objt, act)
		} else {
			imp := val.(RBACWithDomainsManagerServantWithContext)
			funRet, err = imp.DeletePermissionForRoleInDomain(ksfCtx, role, domain, objt, act)
		}

		if err != nil {
			return err
		}

		if ksfReq.IVersion == basef.KSFVERSION {
			buf.Reset()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

		} else if ksfReq.IVersion == basef.KUPVERSION {
			rspKup := kup.NewUniAttribute()

			err = buf.WriteInt32(funRet, 0)
			if err != nil {
				return err
			}

			rspKup.PutBuffer("", buf.ToBytes())
			rspKup.PutBuffer("ksf_ret", buf.ToBytes())

			buf.Reset()
			err = rspKup.Encode(buf)
			if err != nil {
				return err
			}
		} else if ksfReq.IVersion == basef.JSONVERSION {
			rspJson := map[string]interface{}{}
			rspJson["ksf_ret"] = funRet

			var rspByte []byte
			if rspByte, err = json.Marshal(rspJson); err != nil {
				return err
			}

			buf.Reset()
			err = buf.WriteSliceUint8(rspByte)
			if err != nil {
				return err
			}
		}

		if ok && traceData.TraceCall {
			var traceParam string
			traceParamFlag := traceData.NeedTraceParam(trace.EstSS, uint(buf.Len()))
			if traceParamFlag == trace.EnpNormal {
				value := map[string]interface{}{}
				value[""] = funRet
				p, _ := json.Marshal(value)
				traceParam = string(p)
			} else if traceParamFlag == trace.EnpOverMaxLen {
				traceParam = "{\"trace_param_over_max_len\":true}"
			}
			ksf.Trace(traceData.GetTraceKey(trace.EstSS), trace.TraceAnnotationSS, ksf.GetClientConfig().ModuleName, ksfReq.SServantName, "DeletePermissionForRoleInDomain", 0, traceParam, "")
		}

	default:
		if ksfReq.SFuncName == "DoClose" {
			if withContext {
				imp := val.(RBACWithDomainsManagerServantWithContext)
				imp.DoClose(ksfCtx)
			}
			return nil
		}
		return fmt.Errorf("func mismatch")
	}
	var statusMap map[string]string
	if status, ok := current.GetResponseStatus(ksfCtx); ok && status != nil {
		statusMap = status
	}
	var contextMap map[string]string
	if ctx, ok := current.GetResponseContext(ksfCtx); ok && ctx != nil {
		contextMap = ctx
	}
	*ksfResp = requestf.ResponsePacket{
		IVersion:     ksfReq.IVersion,
		CPacketType:  0,
		IRequestId:   ksfReq.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(buf.ToBytes()),
		Status:       statusMap,
		SResultDesc:  "",
		Context:      contextMap,
	}

	_ = readBuf
	_ = buf
	_ = length
	_ = have
	_ = ty
	return nil
}

type RBACWithDomainsManagerKsfCallback interface {
	GetUsersForRoleInDomain_Callback(ret *int32, users *[]string, opt ...map[string]string)
	GetUsersForRoleInDomain_ExceptionCallback(err error)
	GetRolesForUserInDomain_Callback(ret *int32, roles *[]string, opt ...map[string]string)
	GetRolesForUserInDomain_ExceptionCallback(err error)
	GetPermissionsForRoleInDomain_Callback(ret *int32, permissions *[]RolePermission, opt ...map[string]string)
	GetPermissionsForRoleInDomain_ExceptionCallback(err error)
	GetRolesForUser_Callback(ret *int32, roles *[]string, opt ...map[string]string)
	GetRolesForUser_ExceptionCallback(err error)
	GetUsersForRole_Callback(ret *int32, users *[]string, opt ...map[string]string)
	GetUsersForRole_ExceptionCallback(err error)
	GetAllUsersByDomain_Callback(ret *int32, users *[]string, opt ...map[string]string)
	GetAllUsersByDomain_ExceptionCallback(err error)
	GetAllRolesByDomain_Callback(ret *int32, roles *[]string, opt ...map[string]string)
	GetAllRolesByDomain_ExceptionCallback(err error)
	GetAllPermissionsByDomain_Callback(ret *int32, permissions *[]UserPermission, opt ...map[string]string)
	GetAllPermissionsByDomain_ExceptionCallback(err error)
	GetAllDomains_Callback(ret *int32, domains *[]string, opt ...map[string]string)
	GetAllDomains_ExceptionCallback(err error)
	AddRoleForUserInDomain_Callback(ret *int32, opt ...map[string]string)
	AddRoleForUserInDomain_ExceptionCallback(err error)
	AddRolesForUserInDomain_Callback(ret *int32, opt ...map[string]string)
	AddRolesForUserInDomain_ExceptionCallback(err error)
	AddPermissionForRoleInDomain_Callback(ret *int32, opt ...map[string]string)
	AddPermissionForRoleInDomain_ExceptionCallback(err error)
	AddPermissionsForRoleInDomain_Callback(ret *int32, opt ...map[string]string)
	AddPermissionsForRoleInDomain_ExceptionCallback(err error)
	DelPermissionsForRoleInDomain_Callback(ret *int32, opt ...map[string]string)
	DelPermissionsForRoleInDomain_ExceptionCallback(err error)
	DeleteRoleForUserInDomain_Callback(ret *int32, opt ...map[string]string)
	DeleteRoleForUserInDomain_ExceptionCallback(err error)
	DeleteRolesForUserInDomain_Callback(ret *int32, opt ...map[string]string)
	DeleteRolesForUserInDomain_ExceptionCallback(err error)
	DeleteAllRolesForUserInDomain_Callback(ret *int32, opt ...map[string]string)
	DeleteAllRolesForUserInDomain_ExceptionCallback(err error)
	DeleteUser_Callback(ret *int32, opt ...map[string]string)
	DeleteUser_ExceptionCallback(err error)
	DeleteRole_Callback(ret *int32, opt ...map[string]string)
	DeleteRole_ExceptionCallback(err error)
	DeleteRoles_Callback(ret *int32, opt ...map[string]string)
	DeleteRoles_ExceptionCallback(err error)
	DeletePermissionForRoleInDomain_Callback(ret *int32, opt ...map[string]string)
	DeletePermissionForRoleInDomain_ExceptionCallback(err error)
}

// RBACWithDomainsManagerPushCallback struct
type RBACWithDomainsManagerPushCallback struct {
	Cb RBACWithDomainsManagerKsfCallback
}

func (cb *RBACWithDomainsManagerPushCallback) Ondispatch(ksfResp *requestf.ResponsePacket) {
	switch ksfResp.SResultDesc {
	case "GetUsersForRoleInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var users []string

			_, ty, err = readBuf.SkipToNoCheck(3, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				users = make([]string, length)
				for i37, e37 := int32(0), length; i37 < e37; i37++ {

					err = readBuf.ReadString(&users[i37], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetUsersForRoleInDomain_Callback(&ret, &users, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetUsersForRoleInDomain_Callback(&ret, &users)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetUsersForRoleInDomain_ExceptionCallback(err)
		}
	case "GetRolesForUserInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var roles []string

			_, ty, err = readBuf.SkipToNoCheck(3, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				roles = make([]string, length)
				for i38, e38 := int32(0), length; i38 < e38; i38++ {

					err = readBuf.ReadString(&roles[i38], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetRolesForUserInDomain_Callback(&ret, &roles, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetRolesForUserInDomain_Callback(&ret, &roles)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetRolesForUserInDomain_ExceptionCallback(err)
		}
	case "GetPermissionsForRoleInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var permissions []RolePermission

			_, ty, err = readBuf.SkipToNoCheck(3, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				permissions = make([]RolePermission, length)
				for i39, e39 := int32(0), length; i39 < e39; i39++ {

					err = permissions[i39].ReadBlock(readBuf, 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetPermissionsForRoleInDomain_Callback(&ret, &permissions, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetPermissionsForRoleInDomain_Callback(&ret, &permissions)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetPermissionsForRoleInDomain_ExceptionCallback(err)
		}
	case "GetRolesForUser":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var roles []string

			_, ty, err = readBuf.SkipToNoCheck(2, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				roles = make([]string, length)
				for i40, e40 := int32(0), length; i40 < e40; i40++ {

					err = readBuf.ReadString(&roles[i40], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetRolesForUser_Callback(&ret, &roles, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetRolesForUser_Callback(&ret, &roles)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetRolesForUser_ExceptionCallback(err)
		}
	case "GetUsersForRole":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var users []string

			_, ty, err = readBuf.SkipToNoCheck(2, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				users = make([]string, length)
				for i41, e41 := int32(0), length; i41 < e41; i41++ {

					err = readBuf.ReadString(&users[i41], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetUsersForRole_Callback(&ret, &users, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetUsersForRole_Callback(&ret, &users)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetUsersForRole_ExceptionCallback(err)
		}
	case "GetAllUsersByDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var users []string

			_, ty, err = readBuf.SkipToNoCheck(2, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				users = make([]string, length)
				for i42, e42 := int32(0), length; i42 < e42; i42++ {

					err = readBuf.ReadString(&users[i42], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetAllUsersByDomain_Callback(&ret, &users, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetAllUsersByDomain_Callback(&ret, &users)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetAllUsersByDomain_ExceptionCallback(err)
		}
	case "GetAllRolesByDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var roles []string

			_, ty, err = readBuf.SkipToNoCheck(2, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				roles = make([]string, length)
				for i43, e43 := int32(0), length; i43 < e43; i43++ {

					err = readBuf.ReadString(&roles[i43], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetAllRolesByDomain_Callback(&ret, &roles, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetAllRolesByDomain_Callback(&ret, &roles)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetAllRolesByDomain_ExceptionCallback(err)
		}
	case "GetAllPermissionsByDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var permissions []UserPermission

			_, ty, err = readBuf.SkipToNoCheck(2, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				permissions = make([]UserPermission, length)
				for i44, e44 := int32(0), length; i44 < e44; i44++ {

					err = permissions[i44].ReadBlock(readBuf, 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetAllPermissionsByDomain_Callback(&ret, &permissions, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetAllPermissionsByDomain_Callback(&ret, &permissions)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetAllPermissionsByDomain_ExceptionCallback(err)
		}
	case "GetAllDomains":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			var domains []string

			_, ty, err = readBuf.SkipToNoCheck(1, true)
			if err != nil {
				return err
			}

			if ty == codec.LIST {
				err = readBuf.ReadInt32(&length, 0, true)
				if err != nil {
					return err
				}

				domains = make([]string, length)
				for i45, e45 := int32(0), length; i45 < e45; i45++ {

					err = readBuf.ReadString(&domains[i45], 0, false)
					if err != nil {
						return err
					}

				}
			} else if ty == codec.SimpleList {
				err = fmt.Errorf("not support SimpleList type")
				if err != nil {
					return err
				}

			} else {
				err = fmt.Errorf("require vector, but not")
				if err != nil {
					return err
				}

			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.GetAllDomains_Callback(&ret, &domains, ksfResp.Context)
				return nil
			} else {
				cb.Cb.GetAllDomains_Callback(&ret, &domains)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.GetAllDomains_ExceptionCallback(err)
		}
	case "AddRoleForUserInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.AddRoleForUserInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.AddRoleForUserInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.AddRoleForUserInDomain_ExceptionCallback(err)
		}
	case "AddRolesForUserInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.AddRolesForUserInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.AddRolesForUserInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.AddRolesForUserInDomain_ExceptionCallback(err)
		}
	case "AddPermissionForRoleInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.AddPermissionForRoleInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.AddPermissionForRoleInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.AddPermissionForRoleInDomain_ExceptionCallback(err)
		}
	case "AddPermissionsForRoleInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.AddPermissionsForRoleInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.AddPermissionsForRoleInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.AddPermissionsForRoleInDomain_ExceptionCallback(err)
		}
	case "DelPermissionsForRoleInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DelPermissionsForRoleInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DelPermissionsForRoleInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DelPermissionsForRoleInDomain_ExceptionCallback(err)
		}
	case "DeleteRoleForUserInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DeleteRoleForUserInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DeleteRoleForUserInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DeleteRoleForUserInDomain_ExceptionCallback(err)
		}
	case "DeleteRolesForUserInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DeleteRolesForUserInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DeleteRolesForUserInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DeleteRolesForUserInDomain_ExceptionCallback(err)
		}
	case "DeleteAllRolesForUserInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DeleteAllRolesForUserInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DeleteAllRolesForUserInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DeleteAllRolesForUserInDomain_ExceptionCallback(err)
		}
	case "DeleteUser":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DeleteUser_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DeleteUser_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DeleteUser_ExceptionCallback(err)
		}
	case "DeleteRole":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DeleteRole_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DeleteRole_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DeleteRole_ExceptionCallback(err)
		}
	case "DeleteRoles":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DeleteRoles_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DeleteRoles_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DeleteRoles_ExceptionCallback(err)
		}
	case "DeletePermissionForRoleInDomain":
		err := func() error {
			var (
				length int32
				have   bool
				ty     byte
			)
			var err error
			readBuf := codec.NewReader(tools.Int8ToByte(ksfResp.SBuffer))
			var ret int32
			err = readBuf.ReadInt32(&ret, 0, true)
			if err != nil {
				return err
			}

			_ = length
			_ = have
			_ = ty
			if ksfResp.Context != nil {
				cb.Cb.DeletePermissionForRoleInDomain_Callback(&ret, ksfResp.Context)
				return nil
			} else {
				cb.Cb.DeletePermissionForRoleInDomain_Callback(&ret)
				return nil
			}
		}()
		if err != nil {
			cb.Cb.DeletePermissionForRoleInDomain_ExceptionCallback(err)
		}
	}
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetUsersForRoleInDomain(ctx context.Context, ret int32, users *[]string, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetUsersForRoleInDomain"
	resp.SResultDesc = "GetUsersForRoleInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetRolesForUserInDomain(ctx context.Context, ret int32, roles *[]string, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetRolesForUserInDomain"
	resp.SResultDesc = "GetRolesForUserInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetPermissionsForRoleInDomain(ctx context.Context, ret int32, permissions *[]RolePermission, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetPermissionsForRoleInDomain"
	resp.SResultDesc = "GetPermissionsForRoleInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetRolesForUser(ctx context.Context, ret int32, roles *[]string, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetRolesForUser"
	resp.SResultDesc = "GetRolesForUser"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetUsersForRole(ctx context.Context, ret int32, users *[]string, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetUsersForRole"
	resp.SResultDesc = "GetUsersForRole"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetAllUsersByDomain(ctx context.Context, ret int32, users *[]string, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*users)), 0)
	if err != nil {
		return err
	}

	for _, v := range *users {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetAllUsersByDomain"
	resp.SResultDesc = "GetAllUsersByDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetAllRolesByDomain(ctx context.Context, ret int32, roles *[]string, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*roles)), 0)
	if err != nil {
		return err
	}

	for _, v := range *roles {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetAllRolesByDomain"
	resp.SResultDesc = "GetAllRolesByDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetAllPermissionsByDomain(ctx context.Context, ret int32, permissions *[]UserPermission, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*permissions)), 0)
	if err != nil {
		return err
	}

	for _, v := range *permissions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetAllPermissionsByDomain"
	resp.SResultDesc = "GetAllPermissionsByDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_GetAllDomains(ctx context.Context, ret int32, domains *[]string, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(*domains)), 0)
	if err != nil {
		return err
	}

	for _, v := range *domains {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}
	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "GetAllDomains"
	resp.SResultDesc = "GetAllDomains"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_AddRoleForUserInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "AddRoleForUserInDomain"
	resp.SResultDesc = "AddRoleForUserInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_AddRolesForUserInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "AddRolesForUserInDomain"
	resp.SResultDesc = "AddRolesForUserInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_AddPermissionForRoleInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "AddPermissionForRoleInDomain"
	resp.SResultDesc = "AddPermissionForRoleInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_AddPermissionsForRoleInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "AddPermissionsForRoleInDomain"
	resp.SResultDesc = "AddPermissionsForRoleInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DelPermissionsForRoleInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DelPermissionsForRoleInDomain"
	resp.SResultDesc = "DelPermissionsForRoleInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DeleteRoleForUserInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DeleteRoleForUserInDomain"
	resp.SResultDesc = "DeleteRoleForUserInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DeleteRolesForUserInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DeleteRolesForUserInDomain"
	resp.SResultDesc = "DeleteRolesForUserInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DeleteAllRolesForUserInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DeleteAllRolesForUserInDomain"
	resp.SResultDesc = "DeleteAllRolesForUserInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DeleteUser(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DeleteUser"
	resp.SResultDesc = "DeleteUser"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DeleteRole(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DeleteRole"
	resp.SResultDesc = "DeleteRole"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DeleteRoles(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DeleteRoles"
	resp.SResultDesc = "DeleteRoles"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}
func (obj *RBACWithDomainsManager) AsyncSendResponse_DeletePermissionForRoleInDomain(ctx context.Context, ret int32, opt ...map[string]string) (err error) {

	conn, udpAddr, ok := current.GetRawConn(ctx)
	if !ok {
		return fmt.Errorf("connection not found")
	}
	buf := codec.NewBuffer()

	err = buf.WriteInt32(ret, 0)
	if err != nil {
		return err
	}

	resp := &requestf.ResponsePacket{
		SBuffer: tools.ByteToInt8(buf.ToBytes()),
	}
	resp.IVersion = basef.KSFVERSION
	if resp.Status == nil {
		resp.Status = make(map[string]string)
	}
	resp.Status["KSF_FUNC"] = "DeletePermissionForRoleInDomain"
	resp.SResultDesc = "DeletePermissionForRoleInDomain"
	if len(opt) > 0 {
		if opt[0] != nil {
			resp.Context = opt[0]
		}
	}
	rspData := obj.rsp2Byte(resp)
	if udpAddr != nil {
		udpConn, _ := conn.(*net.UDPConn)
		_, err = udpConn.WriteToUDP(rspData, udpAddr)
	} else {
		_, err = conn.Write(rspData)
	}
	return err
}

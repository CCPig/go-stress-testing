// Package ksTrade comment
// This file was generated by ksf2go 1.3.20
// Generated from Relay.ksf
package ksTrade

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
	"ksQuant"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// ClientSysInfo struct implement
type ClientSysInfo struct {
	Acc_id                 string            `json:"acc_id"`
	Macs                   []string          `json:"macs"`
	Hosts                  []string          `json:"hosts"`
	System_info            string            `json:"system_info"`
	Client_system_info_Len int32             `json:"client_system_info_Len"`
	Client_public_ip       string            `json:"client_public_ip"`
	Client_port            int32             `json:"client_port"`
	Client_app_id          string            `json:"client_app_id"`
	Extra_params           map[string]string `json:"extra_params"`
}

func (st *ClientSysInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ClientSysInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Acc_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hosts = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Hosts[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.System_info, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Client_system_info_Len, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Client_public_ip, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Client_port, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Client_app_id, 8, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 9, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 string

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v2, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k2] = v2
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ClientSysInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ClientSysInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ClientSysInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Acc_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Hosts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hosts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.System_info, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Client_system_info_Len, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Client_public_ip, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Client_port, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Client_app_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ClientSysInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountAsset struct implement
type AccountAsset struct {
	Account_id        string            `json:"account_id"`
	Counter_code      string            `json:"counter_code"`
	Currency          string            `json:"currency"`
	Nav               float64           `json:"nav"`
	Pnl               float64           `json:"pnl"`
	Pre_balance       float64           `json:"pre_balance"`
	Pre_margin        float64           `json:"pre_margin"`
	Curr_margin       float64           `json:"curr_margin"`
	Deposit           float64           `json:"deposit"`
	Withdraw          float64           `json:"withdraw"`
	Frozen_margin     float64           `json:"frozen_margin"`
	Frozen_cash       float64           `json:"frozen_cash"`
	Frozen_commission float64           `json:"frozen_commission"`
	Cash              float64           `json:"cash"`
	Balance           float64           `json:"balance"`
	Available         float64           `json:"available"`
	Commission        float64           `json:"commission"`
	Close_profit      float64           `json:"close_profit"`
	Position_profit   float64           `json:"position_profit"`
	Withdraw_quota    float64           `json:"withdraw_quota"`
	Cum_input         float64           `json:"cum_input"`
	Cum_trade         float64           `json:"cum_trade"`
	Cum_pnl           float64           `json:"cum_pnl"`
	Cum_commission    float64           `json:"cum_commission"`
	Last_trade        float64           `json:"last_trade"`
	Last_pnl          float64           `json:"last_pnl"`
	Last_commission   float64           `json:"last_commission"`
	Last_inout        float64           `json:"last_inout"`
	Last_order_side   string            `json:"last_order_side"`
	Bonus             float64           `json:"bonus"`
	Created_at        int64             `json:"created_at"`
	Updated_at        int64             `json:"updated_at"`
	Fund_account      string            `json:"fund_account"`
	Total_asset       float64           `json:"total_asset"`
	Extra_params      map[string]string `json:"extra_params"`
}

func (st *AccountAsset) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountAsset) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Nav, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pnl, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_balance, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_margin, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Curr_margin, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Deposit, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Withdraw, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_margin, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_cash, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_commission, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cash, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Balance, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Available, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Position_profit, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Withdraw_quota, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cum_input, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cum_trade, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cum_pnl, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cum_commission, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_trade, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_pnl, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_commission, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_inout, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Last_order_side, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bonus, 29, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Created_at, 30, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Updated_at, 31, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Fund_account, 32, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_asset, 33, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountAsset) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountAsset, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountAsset) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Nav, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pnl, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_balance, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_margin, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Curr_margin, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Deposit, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Withdraw, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_margin, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_cash, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_commission, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cash, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Balance, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Available, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Position_profit, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Withdraw_quota, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cum_input, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cum_trade, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cum_pnl, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cum_commission, 23)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_trade, 24)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_pnl, 25)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_commission, 26)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_inout, 27)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Last_order_side, 28)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bonus, 29)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Created_at, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Updated_at, 31)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Fund_account, 32)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_asset, 33)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountAsset) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Position struct implement
type Position struct {
	Account_id         string            `json:"account_id"`
	Counter_code       string            `json:"counter_code"`
	Exchange           string            `json:"exchange"`
	Symbol             string            `json:"symbol"`
	Market_id          string            `json:"market_id"`
	Side               string            `json:"side"`
	Hedge              string            `json:"hedge"`
	Tod_yes            string            `json:"tod_yes"`
	Yes_qty            int64             `json:"yes_qty"`
	Qty                int64             `json:"qty"`
	Tod_qty            int64             `json:"tod_qty"`
	Price              float64           `json:"price"`
	Long_forzen        int64             `json:"long_forzen"`
	Short_forzen       int64             `json:"short_forzen"`
	Pos_cost           float64           `json:"pos_cost"`
	Use_margin         float64           `json:"use_margin"`
	Close_profit       float64           `json:"close_profit"`
	Pos_profit         float64           `json:"pos_profit"`
	Available_qty      int64             `json:"available_qty"`
	Market_value       float64           `json:"market_value"`
	Pre_price          float64           `json:"pre_price"`
	Margin_rate        float64           `json:"margin_rate"`
	Margin_rate_volume float64           `json:"margin_rate_volume"`
	Commission         float64           `json:"commission"`
	Stockholder_id     string            `json:"stockholder_id"`
	Secu_name          string            `json:"secu_name"`
	Dilute_cost_price  float64           `json:"dilute_cost_price"`
	Brow_index         int64             `json:"brow_index"`
	Last_price         float64           `json:"last_price"`
	Total_profit       float64           `json:"total_profit"`
	Extra_params       map[string]string `json:"extra_params"`
}

func (st *Position) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Position) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Tod_yes, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Yes_qty, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Qty, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Tod_qty, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Long_forzen, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Short_forzen, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pos_cost, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Use_margin, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pos_profit, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Available_qty, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Market_value, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_price, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Margin_rate, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Margin_rate_volume, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Secu_name, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Dilute_cost_price, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_price, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_profit, 29, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Position) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Position, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Position) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Tod_yes, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Yes_qty, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Qty, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Tod_qty, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Long_forzen, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Short_forzen, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pos_cost, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Use_margin, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pos_profit, 17)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Available_qty, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Market_value, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_price, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Margin_rate, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Margin_rate_volume, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 23)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 24)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Secu_name, 25)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Dilute_cost_price, 26)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 27)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_price, 28)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_profit, 29)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Position) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderInfo struct implement
type OrderInfo struct {
	Order_id        string            `json:"order_id"`
	Counter_code    string            `json:"counter_code"`
	Account_id      string            `json:"account_id"`
	Entrust_id      string            `json:"entrust_id"`
	Task_id         string            `json:"task_id"`
	Session_id      int32             `json:"session_id"`
	Front_id        int32             `json:"front_id"`
	Order_ref       string            `json:"order_ref"`
	Order_price     float64           `json:"order_price"`
	Order_volume    int64             `json:"order_volume"`
	Direction       string            `json:"direction"`
	Comb_offset     string            `json:"comb_offset"`
	Market_id       string            `json:"market_id"`
	Exchange        string            `json:"exchange"`
	Symbol          string            `json:"symbol"`
	Order_status    string            `json:"order_status"`
	Status_msg      string            `json:"status_msg"`
	Order_date      int32             `json:"order_date"`
	Order_time      int64             `json:"order_time"`
	Stockholder_id  string            `json:"stockholder_id"`
	Secu_name       string            `json:"secu_name"`
	Cancel_flag     string            `json:"cancel_flag"`
	Brow_index      int64             `json:"brow_index"`
	Trade_volume    int64             `json:"trade_volume"`
	Trade_avg_price float64           `json:"trade_avg_price"`
	Trade_amount    float64           `json:"trade_amount"`
	Trade_time      int64             `json:"trade_time"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *OrderInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Order_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Session_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Front_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_ref, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_price, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Order_volume, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Direction, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Comb_offset, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market_id, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_status, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status_msg, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Order_date, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Order_time, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Secu_name, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trade_volume, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_avg_price, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_amount, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trade_time, 26, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Session_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Front_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_ref, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_price, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Order_volume, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Direction, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Comb_offset, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market_id, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 13)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_status, 15)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status_msg, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Order_date, 17)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Order_time, 18)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 19)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Secu_name, 20)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 21)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 22)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trade_volume, 23)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_avg_price, 24)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_amount, 25)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trade_time, 26)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *OrderInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TradeInfo struct implement
type TradeInfo struct {
	Order_id       string            `json:"order_id"`
	Counter_code   string            `json:"counter_code"`
	Account_id     string            `json:"account_id"`
	Order_ref      string            `json:"order_ref"`
	Entrust_id     string            `json:"entrust_id"`
	Execution_id   string            `json:"execution_id"`
	Task_id        string            `json:"task_id"`
	Market_id      string            `json:"market_id"`
	Exchange       string            `json:"exchange"`
	Direction      string            `json:"direction"`
	Offset         string            `json:"offset"`
	Hedge          string            `json:"hedge"`
	Symbol         string            `json:"symbol"`
	Trade_volume   int64             `json:"trade_volume"`
	Trade_price    float64           `json:"trade_price"`
	Trade_date     int32             `json:"trade_date"`
	Trade_time     int64             `json:"trade_time"`
	Trade_type     string            `json:"trade_type"`
	Stockholder_id string            `json:"stockholder_id"`
	Secu_name      string            `json:"secu_name"`
	Cancel_flag    string            `json:"cancel_flag"`
	Brow_index     int64             `json:"brow_index"`
	Trade_amount   float64           `json:"trade_amount"`
	Commission     float64           `json:"commission"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *TradeInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Order_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_ref, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Execution_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Direction, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Offset, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trade_volume, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_price, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trade_time, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_type, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Secu_name, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_amount, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 23, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_ref, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Execution_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Direction, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Offset, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trade_volume, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_price, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trade_time, 16)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_type, 17)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 18)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Secu_name, 19)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_amount, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 23)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TradeInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderReq struct implement
type CancelOrderReq struct {
	User_id      string            `json:"user_id"`
	Channel      string            `json:"channel"`
	Account_id   string            `json:"account_id"`
	Counter_code string            `json:"counter_code"`
	Macs         []string          `json:"macs"`
	Account_type string            `json:"account_type"`
	Task_id      string            `json:"task_id"`
	Order_id     string            `json:"order_id"`
	Order_ref    string            `json:"order_ref"`
	Entrust_id   string            `json:"entrust_id"`
	Symbol       string            `json:"symbol"`
	Market_id    string            `json:"market_id"`
	Exchange     string            `json:"exchange"`
	Service_id   string            `json:"service_id"`
	Service_node string            `json:"service_node"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *CancelOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Account_type, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_ref, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market_id, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Service_id, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Service_node, 14, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Account_type, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_ref, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market_id, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Service_id, 13)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Service_node, 14)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderRsp struct implement
type CancelOrderRsp struct {
	User_id      string            `json:"user_id"`
	Account_id   string            `json:"account_id"`
	Channel      string            `json:"channel"`
	Task_id      string            `json:"task_id"`
	Order_id     string            `json:"order_id"`
	Session_id   int32             `json:"session_id"`
	Front_id     int32             `json:"front_id"`
	Order_ref    string            `json:"order_ref"`
	Entrust_id   string            `json:"entrust_id"`
	Status       string            `json:"status"`
	Ret          ksQuant.Error     `json:"ret"`
	Msg          string            `json:"msg"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *CancelOrderRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Session_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Front_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_ref, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status, 9, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 11, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Session_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Front_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_ref, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status, 9)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 11)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CreateAccountReq struct implement
type CreateAccountReq struct {
	Account ksQuant.TradeAccount `json:"account"`
}

func (st *CreateAccountReq) ResetDefault() {
	st.Account.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CreateAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Account.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CreateAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CreateAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CreateAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Account.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CreateAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CreateAccountRsp struct implement
type CreateAccountRsp struct {
	Msg string `json:"msg"`
}

func (st *CreateAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CreateAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CreateAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CreateAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CreateAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CreateAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelAccountReq struct implement
type DelAccountReq struct {
	AccountId string `json:"accountId"`
}

func (st *DelAccountReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.AccountId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.AccountId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DelAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelAccountRsp struct implement
type DelAccountRsp struct {
	Msg string `json:"msg"`
}

func (st *DelAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DelAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// EnterOrderReq struct implement
type EnterOrderReq struct {
	User_id      string            `json:"user_id"`
	Channel      string            `json:"channel"`
	Account_id   string            `json:"account_id"`
	Counter_code string            `json:"counter_code"`
	Macs         []string          `json:"macs"`
	Account_type string            `json:"account_type"`
	Task_id      string            `json:"task_id"`
	Order_id     string            `json:"order_id"`
	Symbol       string            `json:"symbol"`
	Direction    string            `json:"direction"`
	Comb_offset  string            `json:"comb_offset"`
	Hedge        string            `json:"hedge"`
	Qty          int64             `json:"qty"`
	Price_type   string            `json:"price_type"`
	Price        float64           `json:"price"`
	Market_id    string            `json:"market_id"`
	Exchange     string            `json:"exchange"`
	Trade_date   int32             `json:"trade_date"`
	Book_id      string            `json:"book_id"`
	Algo_id      string            `json:"algo_id"`
	Algo_type    string            `json:"algo_type"`
	Service_id   string            `json:"service_id"`
	Service_node string            `json:"service_node"`
	Order_ref    string            `json:"order_ref"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *EnterOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *EnterOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Account_type, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Direction, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Comb_offset, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Qty, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market_id, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Book_id, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_id, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_type, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Service_id, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Service_node, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_ref, 23, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *EnterOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EnterOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *EnterOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Account_type, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Direction, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Comb_offset, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Qty, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market_id, 15)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 17)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Book_id, 18)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_id, 19)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_type, 20)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Service_id, 21)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Service_node, 22)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_ref, 23)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *EnterOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// EnterOrderRsp struct implement
type EnterOrderRsp struct {
	User_id      string            `json:"user_id"`
	Account_id   string            `json:"account_id"`
	Channel      string            `json:"channel"`
	Task_id      string            `json:"task_id"`
	Order_id     string            `json:"order_id"`
	Session_id   int32             `json:"session_id"`
	Front_id     int32             `json:"front_id"`
	Order_ref    string            `json:"order_ref"`
	Entrust_id   string            `json:"entrust_id"`
	Status       string            `json:"status"`
	Ret          ksQuant.Error     `json:"ret"`
	Msg          string            `json:"msg"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *EnterOrderRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *EnterOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Session_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Front_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_ref, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status, 9, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 11, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *EnterOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EnterOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *EnterOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Session_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Front_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_ref, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status, 9)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 11)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *EnterOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddCashReq struct implement
type AddCashReq struct {
	AccountId string  `json:"accountId"`
	Cash      float64 `json:"cash"`
}

func (st *AddCashReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddCashReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.AccountId, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddCashReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddCashReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddCashReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.AccountId, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cash, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddCashReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddCashRsp struct implement
type AddCashRsp struct {
	Msg string `json:"msg"`
}

func (st *AddCashRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddCashRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddCashRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddCashRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddCashRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddCashRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLoginReq struct implement
type AccountLoginReq struct {
	Client        ClientSysInfo        `json:"client"`
	Trade_account ksQuant.TradeAccount `json:"trade_account"`
}

func (st *AccountLoginReq) ResetDefault() {
	st.Client.ResetDefault()
	st.Trade_account.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLoginReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Client.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Trade_account.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLoginReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLoginReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLoginReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Client.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Trade_account.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountLoginReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLoginRsp struct implement
type AccountLoginRsp struct {
	Msg string `json:"msg"`
}

func (st *AccountLoginRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLoginRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLoginRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLoginRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLoginRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountLoginRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLogoutReq struct implement
type AccountLogoutReq struct {
	Client        ClientSysInfo        `json:"client"`
	Trade_account ksQuant.TradeAccount `json:"trade_account"`
}

func (st *AccountLogoutReq) ResetDefault() {
	st.Client.ResetDefault()
	st.Trade_account.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLogoutReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Client.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Trade_account.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLogoutReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLogoutReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLogoutReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Client.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Trade_account.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountLogoutReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLogoutRsp struct implement
type AccountLogoutRsp struct {
	Msg string `json:"msg"`
}

func (st *AccountLogoutRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLogoutRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLogoutRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLogoutRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLogoutRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountLogoutRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryAccountReq struct implement
type QueryAccountReq struct {
	Account_id   string   `json:"account_id"`
	Counter_code string   `json:"counter_code"`
	Macs         []string `json:"macs"`
}

func (st *QueryAccountReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryAccountRsp struct implement
type QueryAccountRsp struct {
	Account ksQuant.TradeAccount `json:"account"`
	Msg     string               `json:"msg"`
}

func (st *QueryAccountRsp) ResetDefault() {
	st.Account.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Account.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Account.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryAssetReq struct implement
type QueryAssetReq struct {
	Account_id   string   `json:"account_id"`
	Counter_code string   `json:"counter_code"`
	Macs         []string `json:"macs"`
}

func (st *QueryAssetReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryAssetReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryAssetReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryAssetReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryAssetReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryAssetReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryAssetRsp struct implement
type QueryAssetRsp struct {
	Asset AccountAsset `json:"asset"`
	Msg   string       `json:"msg"`
}

func (st *QueryAssetRsp) ResetDefault() {
	st.Asset.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryAssetRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Asset.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryAssetRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryAssetRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryAssetRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Asset.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryAssetRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountOrderReq struct implement
type AccountOrderReq struct {
	Account_id     string   `json:"account_id"`
	Counter_code   string   `json:"counter_code"`
	Macs           []string `json:"macs"`
	Symbol         string   `json:"symbol"`
	Exchange       string   `json:"exchange"`
	Stockholder_id string   `json:"stockholder_id"`
	Entrust_id     string   `json:"entrust_id"`
	Record_count   int64    `json:"record_count"`
	Brow_index     int64    `json:"brow_index"`
	Order_id       string   `json:"order_id"`
}

func (st *AccountOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Symbol, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Record_count, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Symbol, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Record_count, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountOrderRsp struct implement
type AccountOrderRsp struct {
	Orders []OrderInfo `json:"orders"`
	Msg    string      `json:"msg"`
}

func (st *AccountOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]OrderInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Orders[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountTradeReq struct implement
type AccountTradeReq struct {
	Account_id     string   `json:"account_id"`
	Counter_code   string   `json:"counter_code"`
	Macs           []string `json:"macs"`
	Symbol         string   `json:"symbol"`
	Exchange       string   `json:"exchange"`
	Stockholder_id string   `json:"stockholder_id"`
	Trade_id       string   `json:"trade_id"`
	Record_count   int64    `json:"record_count"`
	Brow_index     int64    `json:"brow_index"`
}

func (st *AccountTradeReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountTradeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Symbol, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Record_count, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountTradeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountTradeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountTradeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Symbol, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Record_count, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountTradeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountTradeRsp struct implement
type AccountTradeRsp struct {
	Trades []TradeInfo `json:"trades"`
	Msg    string      `json:"msg"`
}

func (st *AccountTradeRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountTradeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Trades = make([]TradeInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Trades[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountTradeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountTradeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountTradeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Trades)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Trades {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountTradeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountPositionReq struct implement
type AccountPositionReq struct {
	Account_id     string   `json:"account_id"`
	Counter_code   string   `json:"counter_code"`
	Macs           []string `json:"macs"`
	Symbol         string   `json:"symbol"`
	Exchange       string   `json:"exchange"`
	Stockholder_id string   `json:"stockholder_id"`
	Record_count   int64    `json:"record_count"`
	Brow_index     int64    `json:"brow_index"`
}

func (st *AccountPositionReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountPositionReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Symbol, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Record_count, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountPositionReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountPositionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountPositionReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Symbol, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Record_count, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountPositionReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountPositionRsp struct implement
type AccountPositionRsp struct {
	Vec_pos []Position `json:"vec_pos"`
	Msg     string     `json:"msg"`
}

func (st *AccountPositionRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountPositionRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_pos = make([]Position, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_pos[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountPositionRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountPositionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountPositionRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_pos)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_pos {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountPositionRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ResetAccountReq struct implement
type ResetAccountReq struct {
	Account ksQuant.TradeAccount `json:"account"`
}

func (st *ResetAccountReq) ResetDefault() {
	st.Account.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ResetAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Account.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ResetAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ResetAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ResetAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Account.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ResetAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ResetAccountRsp struct implement
type ResetAccountRsp struct {
	Msg string `json:"msg"`
}

func (st *ResetAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ResetAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ResetAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ResetAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ResetAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ResetAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountHistoryOrderReq struct implement
type AccountHistoryOrderReq struct {
	Account_id     string   `json:"account_id"`
	Counter_code   string   `json:"counter_code"`
	Macs           []string `json:"macs"`
	Begin_date     string   `json:"begin_date"`
	End_date       string   `json:"end_date"`
	Symbol         string   `json:"symbol"`
	Exchange       string   `json:"exchange"`
	Stockholder_id string   `json:"stockholder_id"`
	Record_count   int64    `json:"record_count"`
	Brow_index     int64    `json:"brow_index"`
}

func (st *AccountHistoryOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountHistoryOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Begin_date, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_date, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Record_count, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountHistoryOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountHistoryOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountHistoryOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Begin_date, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_date, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Record_count, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountHistoryOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountHistoryOrderRsp struct implement
type AccountHistoryOrderRsp struct {
	Orders []OrderInfo `json:"orders"`
	Msg    string      `json:"msg"`
}

func (st *AccountHistoryOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountHistoryOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]OrderInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Orders[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountHistoryOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountHistoryOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountHistoryOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountHistoryOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountHistoryTradeReq struct implement
type AccountHistoryTradeReq struct {
	Account_id     string   `json:"account_id"`
	Counter_code   string   `json:"counter_code"`
	Macs           []string `json:"macs"`
	Begin_date     string   `json:"begin_date"`
	End_date       string   `json:"end_date"`
	Symbol         string   `json:"symbol"`
	Exchange       string   `json:"exchange"`
	Stockholder_id string   `json:"stockholder_id"`
	Record_count   int64    `json:"record_count"`
	Brow_index     int64    `json:"brow_index"`
}

func (st *AccountHistoryTradeReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountHistoryTradeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Begin_date, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_date, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stockholder_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Record_count, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountHistoryTradeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountHistoryTradeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountHistoryTradeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Begin_date, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_date, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stockholder_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Record_count, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountHistoryTradeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountHistoryTradeRsp struct implement
type AccountHistoryTradeRsp struct {
	Trades []TradeInfo `json:"trades"`
	Msg    string      `json:"msg"`
}

func (st *AccountHistoryTradeRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountHistoryTradeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Trades = make([]TradeInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Trades[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountHistoryTradeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountHistoryTradeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountHistoryTradeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Trades)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Trades {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountHistoryTradeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SettlementInfoReq struct implement
type SettlementInfoReq struct {
	Account_id   string   `json:"account_id"`
	Counter_code string   `json:"counter_code"`
	Macs         []string `json:"macs"`
	Trading_day  string   `json:"trading_day"`
}

func (st *SettlementInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SettlementInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Trading_day, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SettlementInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SettlementInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SettlementInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Trading_day, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SettlementInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SettlementInfoRsp struct implement
type SettlementInfoRsp struct {
	Trading_day  string   `json:"trading_day"`
	Account_id   string   `json:"account_id"`
	Counter_code string   `json:"counter_code"`
	Settle_id    int32    `json:"settle_id"`
	Contents     []string `json:"contents"`
	Currency_id  string   `json:"currency_id"`
	Msg          string   `json:"msg"`
}

func (st *SettlementInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SettlementInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Trading_day, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Settle_id, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Contents = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Contents[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Currency_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SettlementInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SettlementInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SettlementInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Trading_day, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Settle_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Contents)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Contents {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Currency_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SettlementInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SettlementConfirmReq struct implement
type SettlementConfirmReq struct {
	Account_id   string   `json:"account_id"`
	Counter_code string   `json:"counter_code"`
	Macs         []string `json:"macs"`
}

func (st *SettlementConfirmReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SettlementConfirmReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SettlementConfirmReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SettlementConfirmReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SettlementConfirmReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SettlementConfirmReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SettlementConfirmRsp struct implement
type SettlementConfirmRsp struct {
	Account_id   string `json:"account_id"`
	Counter_code string `json:"counter_code"`
	Confirm_date string `json:"confirm_date"`
	Confirm_time string `json:"confirm_time"`
	Settle_id    int32  `json:"settle_id"`
	Currency_id  string `json:"currency_id"`
	Msg          string `json:"msg"`
}

func (st *SettlementConfirmRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SettlementConfirmRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Confirm_date, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Confirm_time, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Settle_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SettlementConfirmRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SettlementConfirmRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SettlementConfirmRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Confirm_date, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Confirm_time, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Settle_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SettlementConfirmRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// HeartBeatReq struct implement
type HeartBeatReq struct {
	UniqueId string `json:"uniqueId"`
}

func (st *HeartBeatReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *HeartBeatReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.UniqueId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *HeartBeatReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HeartBeatReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *HeartBeatReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.UniqueId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *HeartBeatReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// HeartBeatRsp struct implement
type HeartBeatRsp struct {
	UniqueId string `json:"uniqueId"`
}

func (st *HeartBeatRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *HeartBeatRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.UniqueId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *HeartBeatRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HeartBeatRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *HeartBeatRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.UniqueId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *HeartBeatRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RegUpdateReq struct implement
type RegUpdateReq struct {
	Counter_code string `json:"counter_code"`
	Account_id   string `json:"account_id"`
}

func (st *RegUpdateReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RegUpdateReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_code, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RegUpdateReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RegUpdateReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RegUpdateReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_code, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *RegUpdateReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RegUpdateRsp struct implement
type RegUpdateRsp struct {
	Msg string `json:"msg"`
}

func (st *RegUpdateRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RegUpdateRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RegUpdateRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RegUpdateRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RegUpdateRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *RegUpdateRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

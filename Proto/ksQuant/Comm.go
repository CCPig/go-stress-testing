// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from Comm.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type ExchangeEventType int32

const (
	ExchangeEventType_BEFORE_OPEN_MARKET = 1
	ExchangeEventType_AFTER_CLOSE_MARKET = 2
	ExchangeEventType_SETTLE             = 3
)

// Error struct implement
type Error struct {
	Code int32  `json:"code"`
	Msg  string `json:"msg"`
}

func (st *Error) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Error) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Error) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Error, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Error) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Code, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Error) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Pagination struct implement
type Pagination struct {
	Offset      int64 `json:"offset"`
	Page_size   int64 `json:"page_size"`
	Total_count int64 `json:"total_count"`
}

func (st *Pagination) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Pagination) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Offset, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Page_size, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Total_count, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Pagination) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Pagination, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Pagination) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Offset, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Page_size, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Total_count, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Pagination) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CacheRecord struct implement
type CacheRecord struct {
	Table_name  string   `json:"table_name"`
	Cached      bool     `json:"cached"`
	Updating    bool     `json:"updating"`
	Cache_index []string `json:"cache_index"`
	Level1      string   `json:"level1"`
	Level2      string   `json:"level2"`
	Level3      string   `json:"level3"`
}

func (st *CacheRecord) ResetDefault() {
	st.Cached = true
	st.Updating = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CacheRecord) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Table_name, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Cached, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Updating, 2, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Cache_index = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Cache_index[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Level1, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Level2, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Level3, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CacheRecord) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CacheRecord, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CacheRecord) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Table_name, 0)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Cached, 1)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Updating, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Cache_index)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Cache_index {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Level1, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Level2, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Level3, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CacheRecord) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// LoginReq struct implement
type LoginReq struct {
	Client         ClientInfo `json:"client"`
	Token          string     `json:"token"`
	Account_id     string     `json:"account_id"`
	Pre_front_id   string     `json:"pre_front_id"`
	Pre_session_id string     `json:"pre_session_id"`
	Now_front_id   string     `json:"now_front_id"`
	Now_session_id string     `json:"now_session_id"`
	Timestamp      int64      `json:"timestamp"`
}

func (st *LoginReq) ResetDefault() {
	st.Client.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *LoginReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Client.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Token, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pre_front_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pre_session_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Now_front_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Now_session_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *LoginReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LoginReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *LoginReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Client.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Token, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pre_front_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pre_session_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Now_front_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Now_session_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *LoginReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// LoginRsp struct implement
type LoginRsp struct {
	Ret        Error  `json:"ret"`
	Front_id   string `json:"front_id"`
	Session_id string `json:"session_id"`
}

func (st *LoginRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *LoginRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Ret.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Front_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Session_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *LoginRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LoginRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *LoginRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Ret.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Front_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Session_id, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *LoginRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// LogoutReq struct implement
type LogoutReq struct {
	Client     ClientInfo `json:"client"`
	Token      string     `json:"token"`
	Account_id string     `json:"account_id"`
	Front_id   string     `json:"front_id"`
	Session_id string     `json:"session_id"`
}

func (st *LogoutReq) ResetDefault() {
	st.Client.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *LogoutReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Client.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Token, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Front_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Session_id, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *LogoutReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LogoutReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *LogoutReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Client.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Token, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Front_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Session_id, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *LogoutReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// LogoutRsp struct implement
type LogoutRsp struct {
	Ret        Error  `json:"ret"`
	Front_id   string `json:"front_id"`
	Session_id string `json:"session_id"`
}

func (st *LogoutRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *LogoutRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Ret.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Front_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Session_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *LogoutRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require LogoutRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *LogoutRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Ret.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Front_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Session_id, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *LogoutRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RunLog struct implement
type RunLog struct {
	Id          string `json:"id"`
	Level       string `json:"level"`
	Module_id   string `json:"module_id"`
	Run_id      string `json:"run_id"`
	Strategy_id string `json:"strategy_id"`
	User_id     string `json:"user_id"`
	Msg         string `json:"msg"`
	Timestamp   int64  `json:"timestamp"`
}

func (st *RunLog) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RunLog) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Level, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Module_id, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 6, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 7, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RunLog) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RunLog, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RunLog) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Level, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Module_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *RunLog) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CreateTableChangeHis struct implement
type CreateTableChangeHis struct {
	Struct_name string `json:"struct_name"`
	Create_sql  string `json:"create_sql"`
	Update      int64  `json:"update"`
}

func (st *CreateTableChangeHis) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CreateTableChangeHis) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Struct_name, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Create_sql, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Update, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CreateTableChangeHis) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CreateTableChangeHis, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CreateTableChangeHis) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Struct_name, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Create_sql, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Update, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CreateTableChangeHis) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

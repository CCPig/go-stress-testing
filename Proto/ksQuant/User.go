// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from User.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type ECalcType int32

const (
	ECalcType_ECT_NONE     = 0
	ECalcType_ECT_PLUS     = 1
	ECalcType_ECT_MULTIPLY = 2
	ECalcType_ECT_ABS      = 3
)

// UserProfile struct implement
type UserProfile struct {
	User_id         string            `json:"user_id"`
	Nickname        string            `json:"nickname"`
	Realname        string            `json:"realname"`
	Card_type       string            `json:"card_type"`
	Card_id         string            `json:"card_id"`
	Mail            string            `json:"mail"`
	Tel_no          string            `json:"tel_no"`
	Wechat          string            `json:"wechat"`
	Remark          string            `json:"remark"`
	Individual_flag string            `json:"individual_flag"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *UserProfile) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserProfile) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Nickname, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Realname, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Card_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Card_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Mail, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Tel_no, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Wechat, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remark, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Individual_flag, 9, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserProfile) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserProfile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserProfile) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Nickname, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Realname, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Card_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Card_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Mail, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Tel_no, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Wechat, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remark, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Individual_flag, 9)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UserProfile) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserAuth struct implement
type UserAuth struct {
	User_id        string            `json:"user_id"`
	Token          string            `json:"token"`
	Salt           string            `json:"salt"`
	User_type      string            `json:"user_type"`
	Role_ids       []string          `json:"role_ids"`
	User_status    string            `json:"user_status"`
	Trade_accounts []string          `json:"trade_accounts"`
	Domain_id      string            `json:"domain_id"`
	Mod_pass       bool              `json:"mod_pass"`
	Reg_time       int64             `json:"reg_time"`
	Company_id     string            `json:"company_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *UserAuth) ResetDefault() {
	st.Mod_pass = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserAuth) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Token, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Salt, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_type, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Role_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Role_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.User_status, 5, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Trade_accounts = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Trade_accounts[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Domain_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Mod_pass, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Reg_time, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Company_id, 10, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 11, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 string

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v2, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k2] = v2
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserAuth) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserAuth, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserAuth) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Token, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Salt, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Role_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Role_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.User_status, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Trade_accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Trade_accounts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Domain_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Mod_pass, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Reg_time, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Company_id, 10)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UserAuth) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserPermission struct implement
type UserPermission struct {
	User_id      string `json:"user_id"`
	Max_backtest int32  `json:"max_backtest"`
	Max_simtrade int32  `json:"max_simtrade"`
	Max_realtime int32  `json:"max_realtime"`
}

func (st *UserPermission) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserPermission) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Max_backtest, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Max_simtrade, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Max_realtime, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserPermission) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserPermission, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserPermission) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Max_backtest, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Max_simtrade, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Max_realtime, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UserPermission) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserDefinition struct implement
type UserDefinition struct {
	User_id string `json:"user_id"`
}

func (st *UserDefinition) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserDefinition) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserDefinition) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserDefinition, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserDefinition) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UserDefinition) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ClientInfo struct implement
type ClientInfo struct {
	User_id      string            `json:"user_id"`
	Channel      string            `json:"channel"`
	Guid         string            `json:"guid"`
	Xua          string            `json:"xua"`
	Imei         string            `json:"imei"`
	Accounts     []string          `json:"accounts"`
	Macs         []string          `json:"macs"`
	Hosts        []string          `json:"hosts"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *ClientInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ClientInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Guid, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Xua, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Imei, 4, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Accounts = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Accounts[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Macs[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hosts = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Hosts[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 8, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 string
			var v3 string

			err = readBuf.ReadString(&k3, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v3, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k3] = v3
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ClientInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ClientInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ClientInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Guid, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Xua, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Imei, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Accounts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Hosts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hosts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.Extra_params {

		err = buf.WriteString(k4, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v4, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ClientInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserFeeCustom struct implement
type UserFeeCustom struct {
	Inst_id   string  `json:"inst_id"`
	Calc_type int32   `json:"calc_type"`
	Value     float64 `json:"value"`
}

func (st *UserFeeCustom) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserFeeCustom) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Calc_type, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Value, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserFeeCustom) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserFeeCustom, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserFeeCustom) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Calc_type, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Value, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UserFeeCustom) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserMarginRateCustom struct implement
type UserMarginRateCustom struct {
	Inst_id   string  `json:"inst_id"`
	Calc_type int32   `json:"calc_type"`
	Value     float64 `json:"value"`
}

func (st *UserMarginRateCustom) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserMarginRateCustom) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Calc_type, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Value, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserMarginRateCustom) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserMarginRateCustom, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserMarginRateCustom) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Calc_type, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Value, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UserMarginRateCustom) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CustomConfig struct implement
type CustomConfig struct {
	User_id     string                 `json:"user_id"`
	Fee         []UserFeeCustom        `json:"fee"`
	Margin_rate []UserMarginRateCustom `json:"margin_rate"`
}

func (st *CustomConfig) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CustomConfig) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Fee = make([]UserFeeCustom, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Fee[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Margin_rate = make([]UserMarginRateCustom, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Margin_rate[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CustomConfig) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CustomConfig, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CustomConfig) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Fee)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Fee {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Margin_rate)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Margin_rate {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CustomConfig) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ConnectNode struct implement
type ConnectNode struct {
	Node_id  string   `json:"node_id"`
	Connects []string `json:"connects"`
}

func (st *ConnectNode) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ConnectNode) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Node_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Connects = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Connects[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ConnectNode) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ConnectNode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ConnectNode) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Node_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Connects)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Connects {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ConnectNode) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ClientConnectNode struct implement
type ClientConnectNode struct {
	User_id string        `json:"user_id"`
	Nodes   []ConnectNode `json:"nodes"`
}

func (st *ClientConnectNode) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ClientConnectNode) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Nodes = make([]ConnectNode, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Nodes[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ClientConnectNode) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ClientConnectNode, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ClientConnectNode) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Nodes)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Nodes {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ClientConnectNode) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// EmailCaptcha struct implement
type EmailCaptcha struct {
	Captcha     string `json:"captcha"`
	Create_time int32  `json:"create_time"`
}

func (st *EmailCaptcha) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *EmailCaptcha) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Captcha, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Create_time, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *EmailCaptcha) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EmailCaptcha, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *EmailCaptcha) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Captcha, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Create_time, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *EmailCaptcha) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserModule struct implement
type UserModule struct {
	User_id int32 `json:"user_id"`
	Uni_key int32 `json:"uni_key"`
}

func (st *UserModule) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserModule) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Uni_key, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserModule) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserModule, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserModule) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Uni_key, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UserModule) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// User struct implement
type User struct {
	User_id    string            `json:"user_id"`
	Auth       UserAuth          `json:"auth"`
	Profile    UserProfile       `json:"profile"`
	Permission UserPermission    `json:"permission"`
	Client     ClientInfo        `json:"client"`
	Node       ClientConnectNode `json:"node"`
	Config     CustomConfig      `json:"config"`
	Create     int64             `json:"create"`
	Update     int64             `json:"update"`
}

func (st *User) ResetDefault() {
	st.Auth.ResetDefault()
	st.Profile.ResetDefault()
	st.Permission.ResetDefault()
	st.Client.ResetDefault()
	st.Node.ResetDefault()
	st.Config.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *User) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Auth.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Profile.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	err = st.Permission.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	err = st.Client.ReadBlock(readBuf, 4, false)
	if err != nil {
		return err
	}

	err = st.Node.ReadBlock(readBuf, 5, false)
	if err != nil {
		return err
	}

	err = st.Config.ReadBlock(readBuf, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Create, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Update, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *User) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require User, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *User) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = st.Auth.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Profile.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = st.Permission.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = st.Client.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	err = st.Node.WriteBlock(buf, 5)
	if err != nil {
		return err
	}

	err = st.Config.WriteBlock(buf, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Create, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Update, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *User) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserPack struct implement
type UserPack struct {
	Is_login bool `json:"is_login"`
	User     User `json:"user"`
}

func (st *UserPack) ResetDefault() {
	st.Is_login = false
	st.User.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserPack) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadBool(&st.Is_login, 0, false)
	if err != nil {
		return err
	}

	err = st.User.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserPack) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserPack, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserPack) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteBool(st.Is_login, 0)
	if err != nil {
		return err
	}

	err = st.User.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UserPack) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

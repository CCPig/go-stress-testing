// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from Archive.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// QuoteChMergeReq struct implement
type QuoteChMergeReq struct {
	Tables       []string          `json:"tables"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QuoteChMergeReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QuoteChMergeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Tables = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Tables[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QuoteChMergeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QuoteChMergeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QuoteChMergeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Tables)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Tables {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QuoteChMergeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StartAsyncLoadAllDataReq struct implement
type StartAsyncLoadAllDataReq struct {
	InstIds                   []string `json:"instIds"`
	Types                     []string `json:"types"`
	BarStartLoadTime          int64    `json:"barStartLoadTime"`
	BarEndLoadTime            int64    `json:"barEndLoadTime"`
	TickStartLoadTime         int64    `json:"tickStartLoadTime"`
	TickEndLoadTime           int64    `json:"tickEndLoadTime"`
	StaticBeforeStartLoadDate int32    `json:"staticBeforeStartLoadDate"`
	StaticBeforeEndLoadDate   int32    `json:"staticBeforeEndLoadDate"`
	StaticAfterStartLoadDate  int32    `json:"staticAfterStartLoadDate"`
	StaticAfterEndLoadDate    int32    `json:"staticAfterEndLoadDate"`
	BarStartLoadDate          int32    `json:"barStartLoadDate"`
	BarEndLoadDate            int32    `json:"barEndLoadDate"`
	TickStartLoadDate         int32    `json:"tickStartLoadDate"`
	TickEndLoadDate           int32    `json:"tickEndLoadDate"`
	Market                    []string `json:"market"`
	Condition                 string   `json:"condition"`
}

func (st *StartAsyncLoadAllDataReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StartAsyncLoadAllDataReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.InstIds = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.InstIds[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Types = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Types[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt64(&st.BarStartLoadTime, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.BarEndLoadTime, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TickStartLoadTime, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TickEndLoadTime, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.StaticBeforeStartLoadDate, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.StaticBeforeEndLoadDate, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.StaticAfterStartLoadDate, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.StaticAfterEndLoadDate, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.BarStartLoadDate, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.BarEndLoadDate, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.TickStartLoadDate, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.TickEndLoadDate, 13, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(14, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Market = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Market[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Condition, 15, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StartAsyncLoadAllDataReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StartAsyncLoadAllDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StartAsyncLoadAllDataReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InstIds)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InstIds {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Types)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Types {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt64(st.BarStartLoadTime, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.BarEndLoadTime, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TickStartLoadTime, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TickEndLoadTime, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.StaticBeforeStartLoadDate, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.StaticBeforeEndLoadDate, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.StaticAfterStartLoadDate, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.StaticAfterEndLoadDate, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.BarStartLoadDate, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.BarEndLoadDate, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.TickStartLoadDate, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.TickEndLoadDate, 13)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Market)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Market {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Condition, 15)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StartAsyncLoadAllDataReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetQuotePackRsp struct implement
type GetQuotePackRsp struct {
	Type string `json:"type"`
	Buf  []int8 `json:"buf"`
}

func (st *GetQuotePackRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetQuotePackRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Type, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Buf = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadInt8(&st.Buf[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Buf, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetQuotePackRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetQuotePackRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetQuotePackRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.SimpleList, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Buf)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Buf)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetQuotePackRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetQuoteTickPackReq struct implement
type GetQuoteTickPackReq struct {
	InstIds   []string `json:"instIds"`
	StartTime int64    `json:"startTime"`
	EndTime   int64    `json:"endTime"`
}

func (st *GetQuoteTickPackReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetQuoteTickPackReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.InstIds = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.InstIds[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt64(&st.StartTime, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.EndTime, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetQuoteTickPackReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetQuoteTickPackReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetQuoteTickPackReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InstIds)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InstIds {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt64(st.StartTime, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.EndTime, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetQuoteTickPackReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetQuoteBarPackReq struct implement
type GetQuoteBarPackReq struct {
	InstIds   []string `json:"instIds"`
	TimeSpans []string `json:"timeSpans"`
	StartTime int64    `json:"startTime"`
	EndTime   int64    `json:"endTime"`
}

func (st *GetQuoteBarPackReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetQuoteBarPackReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.InstIds = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.InstIds[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.TimeSpans = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.TimeSpans[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt64(&st.StartTime, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.EndTime, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetQuoteBarPackReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetQuoteBarPackReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetQuoteBarPackReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InstIds)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InstIds {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.TimeSpans)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.TimeSpans {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt64(st.StartTime, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.EndTime, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetQuoteBarPackReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetQuoteDailyStaticReq struct implement
type GetQuoteDailyStaticReq struct {
	Type      string   `json:"type"`
	InstIds   []string `json:"instIds"`
	StartDate int32    `json:"startDate"`
	EndDate   int32    `json:"endDate"`
}

func (st *GetQuoteDailyStaticReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetQuoteDailyStaticReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Type, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.InstIds = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.InstIds[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.StartDate, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.EndDate, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetQuoteDailyStaticReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetQuoteDailyStaticReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetQuoteDailyStaticReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InstIds)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InstIds {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.StartDate, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.EndDate, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetQuoteDailyStaticReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// MonitorInfo struct implement
type MonitorInfo struct {
	Table          string `json:"table"`
	LastTime       int64  `json:"lastTime"`
	LastStatus     int32  `json:"lastStatus"`
	LastVol        int64  `json:"lastVol"`
	TotalCount     int64  `json:"totalCount"`
	TotalFailCount int64  `json:"totalFailCount"`
	TotalVol       int64  `json:"totalVol"`
}

func (st *MonitorInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *MonitorInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Table, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.LastTime, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.LastStatus, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.LastVol, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TotalCount, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TotalFailCount, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TotalVol, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *MonitorInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MonitorInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *MonitorInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Table, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.LastTime, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.LastStatus, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.LastVol, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TotalCount, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TotalFailCount, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TotalVol, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *MonitorInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetBifrostBinlogReq struct implement
type GetBifrostBinlogReq struct {
	Type     string `json:"type"`
	Position int64  `json:"position"`
}

func (st *GetBifrostBinlogReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetBifrostBinlogReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Type, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Position, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetBifrostBinlogReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetBifrostBinlogReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetBifrostBinlogReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Position, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetBifrostBinlogReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetBifrostBinlogRsp struct implement
type GetBifrostBinlogRsp struct {
	Type     string   `json:"type"`
	Jsons    []string `json:"jsons"`
	Position int64    `json:"position"`
}

func (st *GetBifrostBinlogRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetBifrostBinlogRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Type, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Jsons = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Jsons[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt64(&st.Position, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetBifrostBinlogRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetBifrostBinlogRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetBifrostBinlogRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Jsons)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Jsons {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt64(st.Position, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetBifrostBinlogRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// NotifyMonitorInfoReq struct implement
type NotifyMonitorInfoReq struct {
	Monitors map[string]MonitorInfo `json:"monitors"`
}

func (st *NotifyMonitorInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *NotifyMonitorInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Monitors = make(map[string]MonitorInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 MonitorInfo

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Monitors[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *NotifyMonitorInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NotifyMonitorInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *NotifyMonitorInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Monitors)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Monitors {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *NotifyMonitorInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// PredilectionStat struct implement
type PredilectionStat struct {
	LastMonthVol   int64 `json:"lastMonthVol"`
	LastMonthCount int64 `json:"lastMonthCount"`
	TotalVol       int64 `json:"totalVol"`
	TotalCount     int64 `json:"totalCount"`
}

func (st *PredilectionStat) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *PredilectionStat) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.LastMonthVol, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.LastMonthCount, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TotalVol, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TotalCount, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *PredilectionStat) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PredilectionStat, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *PredilectionStat) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.LastMonthVol, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.LastMonthCount, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TotalVol, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TotalCount, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *PredilectionStat) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// PredilectionInfo struct implement
type PredilectionInfo struct {
	Channel                 string                      `json:"channel"`
	BarInstPredilection_1   map[string]PredilectionStat `json:"barInstPredilection_1"`
	BarInstPredilection_5   map[string]PredilectionStat `json:"barInstPredilection_5"`
	BarInstPredilection_15  map[string]PredilectionStat `json:"barInstPredilection_15"`
	BarInstPredilection_30  map[string]PredilectionStat `json:"barInstPredilection_30"`
	BarInstPredilection_60  map[string]PredilectionStat `json:"barInstPredilection_60"`
	BarInstPredilection_day map[string]PredilectionStat `json:"barInstPredilection_day"`
	BarInstPredilection     map[string]PredilectionStat `json:"barInstPredilection"`
	TickInstPredilection    map[string]PredilectionStat `json:"tickInstPredilection"`
	FatorPredilection       map[string]PredilectionStat `json:"fatorPredilection"`
	TickPredilection        PredilectionStat            `json:"tickPredilection"`
	BarPredilection_1       PredilectionStat            `json:"barPredilection_1"`
	BarPredilection_5       PredilectionStat            `json:"barPredilection_5"`
	BarPredilection_15      PredilectionStat            `json:"barPredilection_15"`
	BarPredilection_30      PredilectionStat            `json:"barPredilection_30"`
	BarPredilection_60      PredilectionStat            `json:"barPredilection_60"`
	BarPredilection_day     PredilectionStat            `json:"barPredilection_day"`
}

func (st *PredilectionInfo) ResetDefault() {
	st.TickPredilection.ResetDefault()
	st.BarPredilection_1.ResetDefault()
	st.BarPredilection_5.ResetDefault()
	st.BarPredilection_15.ResetDefault()
	st.BarPredilection_30.ResetDefault()
	st.BarPredilection_60.ResetDefault()
	st.BarPredilection_day.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *PredilectionInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Channel, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BarInstPredilection_1 = make(map[string]PredilectionStat)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 PredilectionStat

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.BarInstPredilection_1[k0] = v0
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BarInstPredilection_5 = make(map[string]PredilectionStat)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 PredilectionStat

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = v1.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.BarInstPredilection_5[k1] = v1
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BarInstPredilection_15 = make(map[string]PredilectionStat)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 PredilectionStat

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = v2.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.BarInstPredilection_15[k2] = v2
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 4, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BarInstPredilection_30 = make(map[string]PredilectionStat)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 string
			var v3 PredilectionStat

			err = readBuf.ReadString(&k3, 0, false)
			if err != nil {
				return err
			}

			err = v3.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.BarInstPredilection_30[k3] = v3
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 5, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BarInstPredilection_60 = make(map[string]PredilectionStat)
		for i4, e4 := int32(0), length; i4 < e4; i4++ {
			var k4 string
			var v4 PredilectionStat

			err = readBuf.ReadString(&k4, 0, false)
			if err != nil {
				return err
			}

			err = v4.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.BarInstPredilection_60[k4] = v4
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 6, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BarInstPredilection_day = make(map[string]PredilectionStat)
		for i5, e5 := int32(0), length; i5 < e5; i5++ {
			var k5 string
			var v5 PredilectionStat

			err = readBuf.ReadString(&k5, 0, false)
			if err != nil {
				return err
			}

			err = v5.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.BarInstPredilection_day[k5] = v5
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 7, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.BarInstPredilection = make(map[string]PredilectionStat)
		for i6, e6 := int32(0), length; i6 < e6; i6++ {
			var k6 string
			var v6 PredilectionStat

			err = readBuf.ReadString(&k6, 0, false)
			if err != nil {
				return err
			}

			err = v6.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.BarInstPredilection[k6] = v6
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 8, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.TickInstPredilection = make(map[string]PredilectionStat)
		for i7, e7 := int32(0), length; i7 < e7; i7++ {
			var k7 string
			var v7 PredilectionStat

			err = readBuf.ReadString(&k7, 0, false)
			if err != nil {
				return err
			}

			err = v7.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.TickInstPredilection[k7] = v7
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 9, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.FatorPredilection = make(map[string]PredilectionStat)
		for i8, e8 := int32(0), length; i8 < e8; i8++ {
			var k8 string
			var v8 PredilectionStat

			err = readBuf.ReadString(&k8, 0, false)
			if err != nil {
				return err
			}

			err = v8.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.FatorPredilection[k8] = v8
		}
	}

	err = st.TickPredilection.ReadBlock(readBuf, 10, false)
	if err != nil {
		return err
	}

	err = st.BarPredilection_1.ReadBlock(readBuf, 11, false)
	if err != nil {
		return err
	}

	err = st.BarPredilection_5.ReadBlock(readBuf, 12, false)
	if err != nil {
		return err
	}

	err = st.BarPredilection_15.ReadBlock(readBuf, 13, false)
	if err != nil {
		return err
	}

	err = st.BarPredilection_30.ReadBlock(readBuf, 14, false)
	if err != nil {
		return err
	}

	err = st.BarPredilection_60.ReadBlock(readBuf, 15, false)
	if err != nil {
		return err
	}

	err = st.BarPredilection_day.ReadBlock(readBuf, 16, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *PredilectionInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PredilectionInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *PredilectionInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Channel, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.BarInstPredilection_1)), 0)
	if err != nil {
		return err
	}

	for k9, v9 := range st.BarInstPredilection_1 {

		err = buf.WriteString(k9, 0)
		if err != nil {
			return err
		}

		err = v9.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.BarInstPredilection_5)), 0)
	if err != nil {
		return err
	}

	for k10, v10 := range st.BarInstPredilection_5 {

		err = buf.WriteString(k10, 0)
		if err != nil {
			return err
		}

		err = v10.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.BarInstPredilection_15)), 0)
	if err != nil {
		return err
	}

	for k11, v11 := range st.BarInstPredilection_15 {

		err = buf.WriteString(k11, 0)
		if err != nil {
			return err
		}

		err = v11.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.BarInstPredilection_30)), 0)
	if err != nil {
		return err
	}

	for k12, v12 := range st.BarInstPredilection_30 {

		err = buf.WriteString(k12, 0)
		if err != nil {
			return err
		}

		err = v12.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.BarInstPredilection_60)), 0)
	if err != nil {
		return err
	}

	for k13, v13 := range st.BarInstPredilection_60 {

		err = buf.WriteString(k13, 0)
		if err != nil {
			return err
		}

		err = v13.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.BarInstPredilection_day)), 0)
	if err != nil {
		return err
	}

	for k14, v14 := range st.BarInstPredilection_day {

		err = buf.WriteString(k14, 0)
		if err != nil {
			return err
		}

		err = v14.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.BarInstPredilection)), 0)
	if err != nil {
		return err
	}

	for k15, v15 := range st.BarInstPredilection {

		err = buf.WriteString(k15, 0)
		if err != nil {
			return err
		}

		err = v15.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.TickInstPredilection)), 0)
	if err != nil {
		return err
	}

	for k16, v16 := range st.TickInstPredilection {

		err = buf.WriteString(k16, 0)
		if err != nil {
			return err
		}

		err = v16.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.FatorPredilection)), 0)
	if err != nil {
		return err
	}

	for k17, v17 := range st.FatorPredilection {

		err = buf.WriteString(k17, 0)
		if err != nil {
			return err
		}

		err = v17.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = st.TickPredilection.WriteBlock(buf, 10)
	if err != nil {
		return err
	}

	err = st.BarPredilection_1.WriteBlock(buf, 11)
	if err != nil {
		return err
	}

	err = st.BarPredilection_5.WriteBlock(buf, 12)
	if err != nil {
		return err
	}

	err = st.BarPredilection_15.WriteBlock(buf, 13)
	if err != nil {
		return err
	}

	err = st.BarPredilection_30.WriteBlock(buf, 14)
	if err != nil {
		return err
	}

	err = st.BarPredilection_60.WriteBlock(buf, 15)
	if err != nil {
		return err
	}

	err = st.BarPredilection_day.WriteBlock(buf, 16)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *PredilectionInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// NotifyPredilectionInfoReq struct implement
type NotifyPredilectionInfoReq struct {
	NotifyPredilections map[string]PredilectionInfo `json:"notifyPredilections"`
}

func (st *NotifyPredilectionInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *NotifyPredilectionInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.NotifyPredilections = make(map[string]PredilectionInfo)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 PredilectionInfo

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.NotifyPredilections[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *NotifyPredilectionInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NotifyPredilectionInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *NotifyPredilectionInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.NotifyPredilections)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.NotifyPredilections {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *NotifyPredilectionInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurInstrumentsRsp struct implement
type GetCurInstrumentsRsp struct {
	Insts []Instrument `json:"insts"`
}

func (st *GetCurInstrumentsRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurInstrumentsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Insts = make([]Instrument, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Insts[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurInstrumentsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurInstrumentsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurInstrumentsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Insts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurInstrumentsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetHisInstrumentsRsp struct implement
type GetHisInstrumentsRsp struct {
	Insts_his []InstrumentHistory `json:"insts_his"`
}

func (st *GetHisInstrumentsRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetHisInstrumentsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Insts_his = make([]InstrumentHistory, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Insts_his[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetHisInstrumentsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetHisInstrumentsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetHisInstrumentsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Insts_his)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Insts_his {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetHisInstrumentsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetRefMarketsReq struct implement
type GetRefMarketsReq struct {
	Insts []string `json:"insts"`
}

func (st *GetRefMarketsReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetRefMarketsReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Insts = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Insts[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetRefMarketsReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetRefMarketsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetRefMarketsReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetRefMarketsReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetRefMarketsRsp struct implement
type GetRefMarketsRsp struct {
	Markets []string `json:"markets"`
}

func (st *GetRefMarketsRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetRefMarketsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Markets = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Markets[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetRefMarketsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetRefMarketsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetRefMarketsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Markets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Markets {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetRefMarketsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetInstrumentMarketReq struct implement
type GetInstrumentMarketReq struct {
	InstId string `json:"instId"`
}

func (st *GetInstrumentMarketReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetInstrumentMarketReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.InstId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetInstrumentMarketReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetInstrumentMarketReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetInstrumentMarketReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.InstId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetInstrumentMarketReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetInstrumentMarketRsp struct implement
type GetInstrumentMarketRsp struct {
	Market string `json:"market"`
}

func (st *GetInstrumentMarketRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetInstrumentMarketRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Market, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetInstrumentMarketRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetInstrumentMarketRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetInstrumentMarketRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Market, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetInstrumentMarketRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetExchangeIdReq struct implement
type GetExchangeIdReq struct {
	InstId string `json:"instId"`
}

func (st *GetExchangeIdReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetExchangeIdReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.InstId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetExchangeIdReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetExchangeIdReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetExchangeIdReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.InstId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetExchangeIdReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetExchangeIdRsp struct implement
type GetExchangeIdRsp struct {
	ExchangeMic string `json:"exchangeMic"`
}

func (st *GetExchangeIdRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetExchangeIdRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.ExchangeMic, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetExchangeIdRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetExchangeIdRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetExchangeIdRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.ExchangeMic, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetExchangeIdRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetInstVolMultiReq struct implement
type GetInstVolMultiReq struct {
	Date   int32  `json:"date"`
	InstId string `json:"instId"`
}

func (st *GetInstVolMultiReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetInstVolMultiReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetInstVolMultiReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetInstVolMultiReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetInstVolMultiReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetInstVolMultiReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetInstVolMultiRsp struct implement
type GetInstVolMultiRsp struct {
	VolMulti float64 `json:"volMulti"`
}

func (st *GetInstVolMultiRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetInstVolMultiRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadFloat64(&st.VolMulti, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetInstVolMultiRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetInstVolMultiRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetInstVolMultiRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteFloat64(st.VolMulti, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetInstVolMultiRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetTradingMarketsReq struct implement
type GetTradingMarketsReq struct {
	Date    int32    `json:"date"`
	Markets []string `json:"markets"`
}

func (st *GetTradingMarketsReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetTradingMarketsReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Markets = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Markets[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetTradingMarketsReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetTradingMarketsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetTradingMarketsReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Markets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Markets {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetTradingMarketsReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetTradingMarketsRsp struct implement
type GetTradingMarketsRsp struct {
	Markets []string `json:"markets"`
}

func (st *GetTradingMarketsRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetTradingMarketsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Markets = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Markets[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetTradingMarketsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetTradingMarketsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetTradingMarketsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Markets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Markets {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetTradingMarketsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetTradeDateReq struct implement
type GetTradeDateReq struct {
	Timestamp int64  `json:"timestamp"`
	InstId    string `json:"instId"`
}

func (st *GetTradeDateReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetTradeDateReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Timestamp, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetTradeDateReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetTradeDateReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetTradeDateReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Timestamp, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetTradeDateReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetTradeDateRsp struct implement
type GetTradeDateRsp struct {
	Date int32 `json:"date"`
}

func (st *GetTradeDateRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetTradeDateRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetTradeDateRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetTradeDateRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetTradeDateRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetTradeDateRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCfInstrumentReq struct implement
type GetCfInstrumentReq struct {
	Date   int32  `json:"date"`
	InstId string `json:"instId"`
}

func (st *GetCfInstrumentReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCfInstrumentReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCfInstrumentReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCfInstrumentReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCfInstrumentReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCfInstrumentReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCfInstrumentRsp struct implement
type GetCfInstrumentRsp struct {
	Inst ChinaFutureInstrument `json:"inst"`
}

func (st *GetCfInstrumentRsp) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCfInstrumentRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCfInstrumentRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCfInstrumentRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCfInstrumentRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCfInstrumentRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetPrdInstrumentReq struct implement
type GetPrdInstrumentReq struct {
	Date   int32  `json:"date"`
	InstId string `json:"instId"`
}

func (st *GetPrdInstrumentReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetPrdInstrumentReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetPrdInstrumentReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetPrdInstrumentReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetPrdInstrumentReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetPrdInstrumentReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetPrdInstrumentRsp struct implement
type GetPrdInstrumentRsp struct {
	Inst ProductInstrument `json:"inst"`
}

func (st *GetPrdInstrumentRsp) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetPrdInstrumentRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetPrdInstrumentRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetPrdInstrumentRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetPrdInstrumentRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetPrdInstrumentRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetInstPrdIdReq struct implement
type GetInstPrdIdReq struct {
	Date   int32  `json:"date"`
	InstId string `json:"instId"`
}

func (st *GetInstPrdIdReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetInstPrdIdReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetInstPrdIdReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetInstPrdIdReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetInstPrdIdReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetInstPrdIdReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetInstPrdIdRsp struct implement
type GetInstPrdIdRsp struct {
	Prd string `json:"prd"`
}

func (st *GetInstPrdIdRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetInstPrdIdRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Prd, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetInstPrdIdRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetInstPrdIdRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetInstPrdIdRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Prd, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetInstPrdIdRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsSuspendReq struct implement
type IsSuspendReq struct {
	Date   int32  `json:"date"`
	InstId string `json:"instId"`
}

func (st *IsSuspendReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsSuspendReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsSuspendReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsSuspendReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsSuspendReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsSuspendReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsSuspendRsp struct implement
type IsSuspendRsp struct {
	Flag bool `json:"flag"`
}

func (st *IsSuspendRsp) ResetDefault() {
	st.Flag = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsSuspendRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadBool(&st.Flag, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsSuspendRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsSuspendRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsSuspendRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteBool(st.Flag, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsSuspendRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetConstituentInstrumentsReq struct implement
type GetConstituentInstrumentsReq struct {
	Date   int32  `json:"date"`
	InstId string `json:"instId"`
}

func (st *GetConstituentInstrumentsReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetConstituentInstrumentsReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetConstituentInstrumentsReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetConstituentInstrumentsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetConstituentInstrumentsReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetConstituentInstrumentsReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetConstituentInstrumentsRsp struct implement
type GetConstituentInstrumentsRsp struct {
	InstIds []string `json:"instIds"`
}

func (st *GetConstituentInstrumentsRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetConstituentInstrumentsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.InstIds = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.InstIds[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetConstituentInstrumentsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetConstituentInstrumentsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetConstituentInstrumentsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InstIds)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InstIds {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetConstituentInstrumentsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAppointedInstrumentsReq struct implement
type GetAppointedInstrumentsReq struct {
	Date   int32  `json:"date"`
	InstId string `json:"instId"`
}

func (st *GetAppointedInstrumentsReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAppointedInstrumentsReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.InstId, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAppointedInstrumentsReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAppointedInstrumentsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAppointedInstrumentsReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.InstId, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetAppointedInstrumentsReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAppointedInstrumentsRsp struct implement
type GetAppointedInstrumentsRsp struct {
	InstIds []string `json:"instIds"`
}

func (st *GetAppointedInstrumentsRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAppointedInstrumentsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.InstIds = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.InstIds[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAppointedInstrumentsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAppointedInstrumentsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAppointedInstrumentsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InstIds)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InstIds {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetAppointedInstrumentsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsPrdReq struct implement
type IsPrdReq struct {
	InstId string `json:"instId"`
}

func (st *IsPrdReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsPrdReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.InstId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsPrdReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsPrdReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsPrdReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.InstId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsPrdReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsPrdRsp struct implement
type IsPrdRsp struct {
	Flag bool `json:"flag"`
}

func (st *IsPrdRsp) ResetDefault() {
	st.Flag = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsPrdRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadBool(&st.Flag, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsPrdRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsPrdRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsPrdRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteBool(st.Flag, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsPrdRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsCfReq struct implement
type IsCfReq struct {
	InstId string `json:"instId"`
}

func (st *IsCfReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsCfReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.InstId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsCfReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsCfReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsCfReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.InstId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsCfReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsCfRsp struct implement
type IsCfRsp struct {
	Flag bool `json:"flag"`
}

func (st *IsCfRsp) ResetDefault() {
	st.Flag = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsCfRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadBool(&st.Flag, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsCfRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsCfRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsCfRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteBool(st.Flag, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsCfRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsMarketReq struct implement
type IsMarketReq struct {
	InstId string `json:"instId"`
}

func (st *IsMarketReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsMarketReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.InstId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsMarketReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsMarketReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsMarketReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.InstId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsMarketReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IsMarketRsp struct implement
type IsMarketRsp struct {
	Flag bool `json:"flag"`
}

func (st *IsMarketRsp) ResetDefault() {
	st.Flag = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IsMarketRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadBool(&st.Flag, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IsMarketRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IsMarketRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IsMarketRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteBool(st.Flag, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IsMarketRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetSWIndexInstrumentReq struct implement
type GetSWIndexInstrumentReq struct {
	Level int32 `json:"level"`
}

func (st *GetSWIndexInstrumentReq) ResetDefault() {
	st.Level = 1
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetSWIndexInstrumentReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Level, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetSWIndexInstrumentReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetSWIndexInstrumentReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetSWIndexInstrumentReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Level, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetSWIndexInstrumentReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetSWIndexInstrumentRsp struct implement
type GetSWIndexInstrumentRsp struct {
	Insts []Instrument `json:"insts"`
}

func (st *GetSWIndexInstrumentRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetSWIndexInstrumentRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Insts = make([]Instrument, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Insts[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetSWIndexInstrumentRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetSWIndexInstrumentRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetSWIndexInstrumentRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Insts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetSWIndexInstrumentRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

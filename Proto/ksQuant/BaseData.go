// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from BaseData.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type TRADE_CALENDAR_SESSION_TYPE int32

const (
	TRADE_CALENDAR_SESSION_TYPE_TCST_OPEN         = 0
	TRADE_CALENDAR_SESSION_TYPE_TCST_CLOSE        = 1
	TRADE_CALENDAR_SESSION_TYPE_TCST_BEFORE_OPEN  = 2
	TRADE_CALENDAR_SESSION_TYPE_TCST_AFTER_CLOSE  = 3
	TRADE_CALENDAR_SESSION_TYPE_TCST_AFTER_OPEN   = 4
	TRADE_CALENDAR_SESSION_TYPE_TCST_BEFORE_CLOSE = 5
)

// Instrument struct implement
type Instrument struct {
	Id              string `json:"id"`
	Name            string `json:"name"`
	Origin_code     string `json:"origin_code"`
	Origin_name     string `json:"origin_name"`
	E_type          int32  `json:"e_type"`
	Exchange        string `json:"exchange"`
	Market          string `json:"market"`
	Exchange_mic    string `json:"exchange_mic"`
	Exchange_market string `json:"exchange_market"`
	Currency        string `json:"currency"`
	Tplus           int32  `json:"tplus"`
	Is_standard     bool   `json:"is_standard"`
	Is_tradable     bool   `json:"is_tradable"`
	Is_expired      bool   `json:"is_expired"`
	Is_set          bool   `json:"is_set"`
	List_date       int32  `json:"list_date"`
	De_list_date    int32  `json:"de_list_date"`
	Set_code        string `json:"set_code"`
}

func (st *Instrument) ResetDefault() {
	st.Is_standard = false
	st.Is_tradable = false
	st.Is_expired = false
	st.Is_set = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Instrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Origin_code, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Origin_name, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.E_type, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_mic, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_market, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Tplus, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_standard, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_tradable, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_expired, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_set, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.List_date, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.De_list_date, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Set_code, 17, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Instrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Instrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Instrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Origin_code, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Origin_name, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.E_type, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_mic, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_market, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Tplus, 10)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_standard, 11)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_tradable, 12)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_expired, 13)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_set, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.List_date, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.De_list_date, 16)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Set_code, 17)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Instrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// InstrumentHistory struct implement
type InstrumentHistory struct {
	Inst        Instrument `json:"inst"`
	Change_date int32      `json:"change_date"`
}

func (st *InstrumentHistory) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InstrumentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InstrumentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InstrumentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InstrumentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *InstrumentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// MainInstrument struct implement
type MainInstrument struct {
	Inst_id   string `json:"inst_id"`
	Trade_day int32  `json:"trade_day"`
}

func (st *MainInstrument) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *MainInstrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_day, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *MainInstrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MainInstrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *MainInstrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_day, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *MainInstrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// MainInstrumentHistory struct implement
type MainInstrumentHistory struct {
	Product     string         `json:"product"`
	Change_date int32          `json:"change_date"`
	Main_ins    MainInstrument `json:"main_ins"`
}

func (st *MainInstrumentHistory) ResetDefault() {
	st.Main_ins.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *MainInstrumentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Product, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	err = st.Main_ins.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *MainInstrumentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MainInstrumentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *MainInstrumentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Product, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	err = st.Main_ins.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *MainInstrumentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChinaStockInstrument struct implement
type ChinaStockInstrument struct {
	Id           string  `json:"id"`
	Name         string  `json:"name"`
	Lot_size     float64 `json:"lot_size"`
	Tick_table   string  `json:"tick_table"`
	Price_tick   float64 `json:"price_tick"`
	Comm_ratio   float64 `json:"comm_ratio"`
	Stamp_tax    float64 `json:"stamp_tax"`
	Transfer_fee float64 `json:"transfer_fee"`
	Exchange_fee float64 `json:"exchange_fee"`
	Other        float64 `json:"other"`
	Mini_comm    float64 `json:"mini_comm"`
	Is_ST        bool    `json:"is_ST"`
	Is_XST       bool    `json:"is_XST"`
	Is_PT        bool    `json:"is_PT"`
}

func (st *ChinaStockInstrument) ResetDefault() {
	st.Is_ST = true
	st.Is_XST = true
	st.Is_PT = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ChinaStockInstrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Lot_size, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Tick_table, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price_tick, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Comm_ratio, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Stamp_tax, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Transfer_fee, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Exchange_fee, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Other, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Mini_comm, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_ST, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_XST, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_PT, 13, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ChinaStockInstrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChinaStockInstrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ChinaStockInstrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Lot_size, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Tick_table, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price_tick, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Comm_ratio, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Stamp_tax, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Transfer_fee, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Exchange_fee, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Other, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Mini_comm, 10)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_ST, 11)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_XST, 12)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_PT, 13)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ChinaStockInstrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChinaStockInstrumentHistory struct implement
type ChinaStockInstrumentHistory struct {
	Inst        ChinaStockInstrument `json:"inst"`
	Change_date int32                `json:"change_date"`
}

func (st *ChinaStockInstrumentHistory) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ChinaStockInstrumentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ChinaStockInstrumentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChinaStockInstrumentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ChinaStockInstrumentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ChinaStockInstrumentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChinaFutureInstrument struct implement
type ChinaFutureInstrument struct {
	Id                   string  `json:"id"`
	Product_id           string  `json:"product_id"`
	Combination_type     string  `json:"combination_type"`
	Max_market_order_vol int64   `json:"max_market_order_vol"`
	Min_market_order_vol int64   `json:"min_market_order_vol"`
	Max_limit_order_vol  int64   `json:"max_limit_order_vol"`
	Min_limit_order_vol  int64   `json:"min_limit_order_vol"`
	Long_margin_ratio    float64 `json:"long_margin_ratio"`
	Short_margin_ratio   float64 `json:"short_margin_ratio"`
	Comm_ratio           float64 `json:"comm_ratio"`
	Deliv_year           int32   `json:"deliv_year"`
	Deliv_month          int32   `json:"deliv_month"`
	Start_deliv_date     int32   `json:"start_deliv_date"`
	End_deliv_date       int32   `json:"end_deliv_date"`
}

func (st *ChinaFutureInstrument) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ChinaFutureInstrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Product_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Combination_type, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Max_market_order_vol, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Min_market_order_vol, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Max_limit_order_vol, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Min_limit_order_vol, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Long_margin_ratio, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Short_margin_ratio, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Comm_ratio, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Deliv_year, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Deliv_month, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Start_deliv_date, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.End_deliv_date, 16, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ChinaFutureInstrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChinaFutureInstrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ChinaFutureInstrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Product_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Combination_type, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Max_market_order_vol, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Min_market_order_vol, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Max_limit_order_vol, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Min_limit_order_vol, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Long_margin_ratio, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Short_margin_ratio, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Comm_ratio, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Deliv_year, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Deliv_month, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Start_deliv_date, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.End_deliv_date, 16)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ChinaFutureInstrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChinaFutureInstrumentHistory struct implement
type ChinaFutureInstrumentHistory struct {
	Inst        ChinaFutureInstrument `json:"inst"`
	Change_date int32                 `json:"change_date"`
}

func (st *ChinaFutureInstrumentHistory) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ChinaFutureInstrumentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ChinaFutureInstrumentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChinaFutureInstrumentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ChinaFutureInstrumentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ChinaFutureInstrumentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChinaOptionInstrument struct implement
type ChinaOptionInstrument struct {
	Id                   string  `json:"id"`
	Product_id           string  `json:"product_id"`
	Combination_type     string  `json:"combination_type"`
	Max_market_order_vol int64   `json:"max_market_order_vol"`
	Min_market_order_vol int64   `json:"min_market_order_vol"`
	Max_limit_order_vol  int64   `json:"max_limit_order_vol"`
	Min_limit_order_vol  int64   `json:"min_limit_order_vol"`
	Long_margin_ratio    float64 `json:"long_margin_ratio"`
	Short_margin_ratio   float64 `json:"short_margin_ratio"`
	Comm_ratio           float64 `json:"comm_ratio"`
	Deliv_year           int32   `json:"deliv_year"`
	Deliv_month          int32   `json:"deliv_month"`
	Start_deliv_date     int32   `json:"start_deliv_date"`
	End_deliv_date       int32   `json:"end_deliv_date"`
}

func (st *ChinaOptionInstrument) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ChinaOptionInstrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Product_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Combination_type, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Max_market_order_vol, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Min_market_order_vol, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Max_limit_order_vol, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Min_limit_order_vol, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Long_margin_ratio, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Short_margin_ratio, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Comm_ratio, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Deliv_year, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Deliv_month, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Start_deliv_date, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.End_deliv_date, 16, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ChinaOptionInstrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChinaOptionInstrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ChinaOptionInstrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Product_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Combination_type, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Max_market_order_vol, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Min_market_order_vol, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Max_limit_order_vol, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Min_limit_order_vol, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Long_margin_ratio, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Short_margin_ratio, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Comm_ratio, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Deliv_year, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Deliv_month, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Start_deliv_date, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.End_deliv_date, 16)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ChinaOptionInstrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ChinaOptionInstrumentHistory struct implement
type ChinaOptionInstrumentHistory struct {
	Inst        ChinaOptionInstrument `json:"inst"`
	Change_date int32                 `json:"change_date"`
}

func (st *ChinaOptionInstrumentHistory) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ChinaOptionInstrumentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ChinaOptionInstrumentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ChinaOptionInstrumentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ChinaOptionInstrumentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ChinaOptionInstrumentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ProductInstrument struct implement
type ProductInstrument struct {
	Id                   string   `json:"id"`
	Name                 string   `json:"name"`
	Support_markets      []string `json:"support_markets"`
	E_type               int32    `json:"e_type"`
	Night_trading        bool     `json:"night_trading"`
	Max_market_order_vol int64    `json:"max_market_order_vol"`
	Min_market_order_vol int64    `json:"min_market_order_vol"`
	Max_limit_order_vol  int64    `json:"max_limit_order_vol"`
	Min_limit_order_vol  int64    `json:"min_limit_order_vol"`
	Vol_multi            float64  `json:"vol_multi"`
	Price_tick           float64  `json:"price_tick"`
	Long_margin_ratio    float64  `json:"long_margin_ratio"`
	Short_margin_ratio   float64  `json:"short_margin_ratio"`
	Comm_ratio           float64  `json:"comm_ratio"`
	Comm_unit            int32    `json:"comm_unit"`
	Pos_type             string   `json:"pos_type"`
	Pos_date_type        string   `json:"pos_date_type"`
}

func (st *ProductInstrument) ResetDefault() {
	st.Night_trading = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ProductInstrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Support_markets = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Support_markets[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.E_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Night_trading, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Max_market_order_vol, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Min_market_order_vol, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Max_limit_order_vol, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Min_limit_order_vol, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Vol_multi, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price_tick, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Long_margin_ratio, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Short_margin_ratio, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Comm_ratio, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Comm_unit, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pos_type, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pos_date_type, 16, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ProductInstrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ProductInstrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ProductInstrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Support_markets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Support_markets {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.E_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Night_trading, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Max_market_order_vol, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Min_market_order_vol, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Max_limit_order_vol, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Min_limit_order_vol, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Vol_multi, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price_tick, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Long_margin_ratio, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Short_margin_ratio, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Comm_ratio, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Comm_unit, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pos_type, 15)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pos_date_type, 16)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ProductInstrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ProductInstrumentHistory struct implement
type ProductInstrumentHistory struct {
	Inst        ProductInstrument `json:"inst"`
	Change_date int32             `json:"change_date"`
}

func (st *ProductInstrumentHistory) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ProductInstrumentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ProductInstrumentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ProductInstrumentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ProductInstrumentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ProductInstrumentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Exchange struct implement
type Exchange struct {
	Id          string `json:"id"`
	Mic         string `json:"mic"`
	Origin_code string `json:"origin_code"`
	Region      string `json:"region"`
}

func (st *Exchange) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Exchange) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Mic, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Origin_code, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Region, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Exchange) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Exchange, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Exchange) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Mic, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Origin_code, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Region, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Exchange) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ExchangeHistory struct implement
type ExchangeHistory struct {
	Exchange    Exchange `json:"exchange"`
	Change_date int32    `json:"change_date"`
}

func (st *ExchangeHistory) ResetDefault() {
	st.Exchange.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ExchangeHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Exchange.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ExchangeHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ExchangeHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ExchangeHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Exchange.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ExchangeHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Market struct implement
type Market struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

func (st *Market) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Market) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Market) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Market, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Market) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Market) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TradeDay struct implement
type TradeDay struct {
	Date int32 `json:"date"`
	Flag int32 `json:"flag"`
}

func (st *TradeDay) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeDay) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Flag, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeDay) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeDay, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeDay) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Flag, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TradeDay) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TradeCalendar struct implement
type TradeCalendar struct {
	Market  string     `json:"market"`
	All_day []TradeDay `json:"all_day"`
}

func (st *TradeCalendar) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeCalendar) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Market, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.All_day = make([]TradeDay, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.All_day[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeCalendar) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeCalendar, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeCalendar) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Market, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.All_day)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.All_day {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TradeCalendar) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TimeSlot struct implement
type TimeSlot struct {
	Open_time  int64             `json:"open_time"`
	Close_time int64             `json:"close_time"`
	From_time  int64             `json:"from_time"`
	To_time    int64             `json:"to_time"`
	Sequence   int32             `json:"sequence"`
	Flag_bits  uint32            `json:"flag_bits"`
	Extends    map[string]string `json:"extends"`
}

func (st *TimeSlot) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TimeSlot) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Open_time, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Close_time, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.From_time, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.To_time, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Sequence, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadUint32(&st.Flag_bits, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TimeSlot) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TimeSlot, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TimeSlot) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Open_time, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Close_time, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.From_time, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.To_time, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Sequence, 4)
	if err != nil {
		return err
	}

	err = buf.WriteUint32(st.Flag_bits, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TimeSlot) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TradeTime struct implement
type TradeTime struct {
	Inst_id   string     `json:"inst_id"`
	Time_slot []TimeSlot `json:"time_slot"`
}

func (st *TradeTime) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeTime) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Time_slot = make([]TimeSlot, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Time_slot[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeTime) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeTime, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeTime) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Time_slot)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Time_slot {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TradeTime) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TradeTimeHistory struct implement
type TradeTimeHistory struct {
	Trade_time  TradeTime `json:"trade_time"`
	Change_date int32     `json:"change_date"`
}

func (st *TradeTimeHistory) ResetDefault() {
	st.Trade_time.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeTimeHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Trade_time.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeTimeHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeTimeHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeTimeHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Trade_time.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TradeTimeHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// InstrumentTradeTime struct implement
type InstrumentTradeTime struct {
	Trade_time_his map[string][]TradeTimeHistory `json:"trade_time_his"`
}

func (st *InstrumentTradeTime) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InstrumentTradeTime) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Trade_time_his = make(map[string][]TradeTimeHistory)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 []TradeTimeHistory

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			have, ty, err = readBuf.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]TradeTimeHistory, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = v0[i1].ReadBlock(readBuf, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SimpleList {
					err = fmt.Errorf("not support SimpleList type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.Trade_time_his[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InstrumentTradeTime) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InstrumentTradeTime, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InstrumentTradeTime) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Trade_time_his)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Trade_time_his {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v2)), 0)
		if err != nil {
			return err
		}

		for _, v := range v2 {

			err = v.WriteBlock(buf, 0)
			if err != nil {
				return err
			}

		}
	}

	return err
}

// WriteBlock encode struct
func (st *InstrumentTradeTime) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Xrxd struct implement
type Xrxd struct {
	Inst_id          string  `json:"inst_id"`
	Ex_date          int32   `json:"ex_date"`
	Regi_date        int32   `json:"regi_date"`
	Regi_close_price float64 `json:"regi_close_price"`
	Div_cash         float64 `json:"div_cash"`
	Div_share        float64 `json:"div_share"`
	Trab_share       float64 `json:"trab_share"`
	Place_rate       float64 `json:"place_rate"`
	Place_price      float64 `json:"place_price"`
	Ex_factor        float64 `json:"ex_factor"`
	Cuml_ex_factor   float64 `json:"cuml_ex_factor"`
	Ex_price         float64 `json:"ex_price"`
	Ex_div_price     float64 `json:"ex_div_price"`
	Publish_time     int64   `json:"publish_time"`
}

func (st *Xrxd) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Xrxd) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Ex_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Regi_date, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Regi_close_price, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Div_cash, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Div_share, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trab_share, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Place_rate, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Place_price, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ex_factor, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cuml_ex_factor, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ex_price, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ex_div_price, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Publish_time, 13, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Xrxd) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Xrxd, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Xrxd) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Ex_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Regi_date, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Regi_close_price, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Div_cash, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Div_share, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trab_share, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Place_rate, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Place_price, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ex_factor, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cuml_ex_factor, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ex_price, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ex_div_price, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Publish_time, 13)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Xrxd) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IndexComponent struct implement
type IndexComponent struct {
	Id        string `json:"id"`
	Parent_id string `json:"parent_id"`
	Check_in  int32  `json:"check_in"`
	Check_out int32  `json:"check_out"`
}

func (st *IndexComponent) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IndexComponent) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Parent_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Check_in, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Check_out, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IndexComponent) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IndexComponent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IndexComponent) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Parent_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Check_in, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Check_out, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IndexComponent) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// IndexComponentHistory struct implement
type IndexComponentHistory struct {
	Inst        IndexComponent `json:"inst"`
	Change_date int32          `json:"change_date"`
}

func (st *IndexComponentHistory) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *IndexComponentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *IndexComponentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require IndexComponentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *IndexComponentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *IndexComponentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SpecialFactor struct implement
type SpecialFactor struct {
	Inst_id    string `json:"inst_id"`
	Factor_key string `json:"factor_key"`
	Factol_val string `json:"factol_val"`
}

func (st *SpecialFactor) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SpecialFactor) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Factor_key, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Factol_val, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SpecialFactor) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SpecialFactor, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SpecialFactor) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Factor_key, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Factol_val, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SpecialFactor) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SpecialFactorHistory struct implement
type SpecialFactorHistory struct {
	Sf          SpecialFactor `json:"sf"`
	Change_date int32         `json:"change_date"`
}

func (st *SpecialFactorHistory) ResetDefault() {
	st.Sf.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SpecialFactorHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Sf.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SpecialFactorHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SpecialFactorHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SpecialFactorHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Sf.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SpecialFactorHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ETFInstrument struct implement
type ETFInstrument struct {
	Id         string  `json:"id"`
	Price_tick float64 `json:"price_tick"`
}

func (st *ETFInstrument) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ETFInstrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price_tick, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ETFInstrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ETFInstrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ETFInstrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price_tick, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ETFInstrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ETFInstrumentHistory struct implement
type ETFInstrumentHistory struct {
	Inst        ETFInstrument `json:"inst"`
	Change_date int32         `json:"change_date"`
}

func (st *ETFInstrumentHistory) ResetDefault() {
	st.Inst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ETFInstrumentHistory) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Inst.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Change_date, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ETFInstrumentHistory) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ETFInstrumentHistory, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ETFInstrumentHistory) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Inst.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Change_date, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ETFInstrumentHistory) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BondMap struct implement
type BondMap struct {
	Bond_code  string `json:"bond_code"`
	Stock_code string `json:"stock_code"`
}

func (st *BondMap) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BondMap) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Bond_code, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_code, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BondMap) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BondMap, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BondMap) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Bond_code, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_code, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BondMap) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from Quote.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type KBarType int32

const (
	KBarType_KB_NONE     = 0
	KBarType_KB_TICK     = 1
	KBarType_KB_1MINUTE  = 60
	KBarType_KB_5MINUTE  = 300
	KBarType_KB_15MINUTE = 900
	KBarType_KB_30MINUTE = 1800
	KBarType_KB_60MINUTE = 3600
	KBarType_KB_DAY      = 86400
)

// QtyPrice struct implement
type QtyPrice struct {
	Qty   int64   `json:"qty"`
	Price float64 `json:"price"`
}

func (st *QtyPrice) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QtyPrice) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Qty, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QtyPrice) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QtyPrice, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QtyPrice) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Qty, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QtyPrice) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Tick struct implement
type Tick struct {
	Inst_id        string            `json:"inst_id"`
	Trade_date     int32             `json:"trade_date"`
	Timestamp      int64             `json:"timestamp"`
	Last_price     float64           `json:"last_price"`
	Last_vol       int64             `json:"last_vol"`
	Total_vol      int64             `json:"total_vol"`
	Pos            int64             `json:"pos"`
	Last_turnover  float64           `json:"last_turnover"`
	Total_turnover float64           `json:"total_turnover"`
	Bid1_q         int64             `json:"bid1_q"`
	Bid2_q         int64             `json:"bid2_q"`
	Bid3_q         int64             `json:"bid3_q"`
	Bid4_q         int64             `json:"bid4_q"`
	Bid5_q         int64             `json:"bid5_q"`
	Bid6_q         int64             `json:"bid6_q"`
	Bid7_q         int64             `json:"bid7_q"`
	Bid8_q         int64             `json:"bid8_q"`
	Bid9_q         int64             `json:"bid9_q"`
	Bid10_q        int64             `json:"bid10_q"`
	Bid1_p         float64           `json:"bid1_p"`
	Bid2_p         float64           `json:"bid2_p"`
	Bid3_p         float64           `json:"bid3_p"`
	Bid4_p         float64           `json:"bid4_p"`
	Bid5_p         float64           `json:"bid5_p"`
	Bid6_p         float64           `json:"bid6_p"`
	Bid7_p         float64           `json:"bid7_p"`
	Bid8_p         float64           `json:"bid8_p"`
	Bid9_p         float64           `json:"bid9_p"`
	Bid10_p        float64           `json:"bid10_p"`
	Ask1_q         int64             `json:"ask1_q"`
	Ask2_q         int64             `json:"ask2_q"`
	Ask3_q         int64             `json:"ask3_q"`
	Ask4_q         int64             `json:"ask4_q"`
	Ask5_q         int64             `json:"ask5_q"`
	Ask6_q         int64             `json:"ask6_q"`
	Ask7_q         int64             `json:"ask7_q"`
	Ask8_q         int64             `json:"ask8_q"`
	Ask9_q         int64             `json:"ask9_q"`
	Ask10_q        int64             `json:"ask10_q"`
	Ask1_p         float64           `json:"ask1_p"`
	Ask2_p         float64           `json:"ask2_p"`
	Ask3_p         float64           `json:"ask3_p"`
	Ask4_p         float64           `json:"ask4_p"`
	Ask5_p         float64           `json:"ask5_p"`
	Ask6_p         float64           `json:"ask6_p"`
	Ask7_p         float64           `json:"ask7_p"`
	Ask8_p         float64           `json:"ask8_p"`
	Ask9_p         float64           `json:"ask9_p"`
	Ask10_p        float64           `json:"ask10_p"`
	Extend         map[string]string `json:"extend"`
	Stale          bool              `json:"stale"`
}

func (st *Tick) ResetDefault() {
	st.Stale = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Tick) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_price, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Last_vol, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Total_vol, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Pos, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_turnover, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_turnover, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid1_q, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid2_q, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid3_q, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid4_q, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid5_q, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid6_q, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid7_q, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid8_q, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid9_q, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Bid10_q, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid1_p, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid2_p, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid3_p, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid4_p, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid5_p, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid6_p, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid7_p, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid8_p, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid9_p, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Bid10_p, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask1_q, 29, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask2_q, 30, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask3_q, 31, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask4_q, 32, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask5_q, 33, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask6_q, 34, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask7_q, 35, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask8_q, 36, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask9_q, 37, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Ask10_q, 38, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask1_p, 39, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask2_p, 40, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask3_p, 41, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask4_p, 42, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask5_p, 43, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask6_p, 44, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask7_p, 45, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask8_p, 46, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask9_p, 47, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ask10_p, 48, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 49, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extend = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extend[k0] = v0
		}
	}

	err = readBuf.ReadBool(&st.Stale, 50, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Tick) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Tick, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Tick) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_price, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Last_vol, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Total_vol, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Pos, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_turnover, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_turnover, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid1_q, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid2_q, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid3_q, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid4_q, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid5_q, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid6_q, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid7_q, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid8_q, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid9_q, 17)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Bid10_q, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid1_p, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid2_p, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid3_p, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid4_p, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid5_p, 23)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid6_p, 24)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid7_p, 25)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid8_p, 26)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid9_p, 27)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Bid10_p, 28)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask1_q, 29)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask2_q, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask3_q, 31)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask4_q, 32)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask5_q, 33)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask6_q, 34)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask7_q, 35)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask8_q, 36)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask9_q, 37)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Ask10_q, 38)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask1_p, 39)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask2_p, 40)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask3_p, 41)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask4_p, 42)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask5_p, 43)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask6_p, 44)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask7_p, 45)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask8_p, 46)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask9_p, 47)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ask10_p, 48)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 49)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extend)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extend {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteBool(st.Stale, 50)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Tick) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TickGroup struct implement
type TickGroup struct {
	Ticks []Tick `json:"ticks"`
}

func (st *TickGroup) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TickGroup) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ticks = make([]Tick, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Ticks[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TickGroup) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TickGroup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TickGroup) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ticks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ticks {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TickGroup) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Bar struct implement
type Bar struct {
	Inst_id        string  `json:"inst_id"`
	Trade_date     int32   `json:"trade_date"`
	Timestamp      int64   `json:"timestamp"`
	Time_span      int64   `json:"time_span"`
	High           float64 `json:"high"`
	Low            float64 `json:"low"`
	Open           float64 `json:"open"`
	Close          float64 `json:"close"`
	Vol            int64   `json:"vol"`
	Total_vol      int64   `json:"total_vol"`
	Pos            int64   `json:"pos"`
	Turnover       float64 `json:"turnover"`
	Total_turnover float64 `json:"total_turnover"`
	Suspended      bool    `json:"suspended"`
}

func (st *Bar) ResetDefault() {
	st.Suspended = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Bar) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Time_span, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.High, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Low, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Open, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Vol, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Total_vol, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Pos, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Turnover, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_turnover, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Suspended, 13, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Bar) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Bar, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Bar) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Time_span, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.High, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Low, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Open, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Vol, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Total_vol, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Pos, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Turnover, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_turnover, 12)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Suspended, 13)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Bar) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BarGroup struct implement
type BarGroup struct {
	Bars []Bar `json:"bars"`
}

func (st *BarGroup) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BarGroup) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bars = make([]Bar, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Bars[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BarGroup) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BarGroup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BarGroup) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Bars)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bars {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BarGroup) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QuoteGroupNotify struct implement
type QuoteGroupNotify struct {
	Timestamp int64    `json:"timestamp"`
	Time_span int64    `json:"time_span"`
	Insts     []string `json:"insts"`
}

func (st *QuoteGroupNotify) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QuoteGroupNotify) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Timestamp, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Time_span, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Insts = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Insts[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QuoteGroupNotify) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QuoteGroupNotify, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QuoteGroupNotify) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Timestamp, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Time_span, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QuoteGroupNotify) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DailyStaticBefore struct implement
type DailyStaticBefore struct {
	Inst_id    string  `json:"inst_id"`
	Trade_date int32   `json:"trade_date"`
	Ceil       float64 `json:"ceil"`
	Floor      float64 `json:"floor"`
}

func (st *DailyStaticBefore) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DailyStaticBefore) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ceil, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Floor, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DailyStaticBefore) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DailyStaticBefore, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DailyStaticBefore) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ceil, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Floor, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DailyStaticBefore) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DailyStaticBeforeGroup struct implement
type DailyStaticBeforeGroup struct {
	Befores []DailyStaticBefore `json:"befores"`
}

func (st *DailyStaticBeforeGroup) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DailyStaticBeforeGroup) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Befores = make([]DailyStaticBefore, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Befores[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DailyStaticBeforeGroup) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DailyStaticBeforeGroup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DailyStaticBeforeGroup) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Befores)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Befores {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *DailyStaticBeforeGroup) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DailyStaticAfter struct implement
type DailyStaticAfter struct {
	Inst_id    string  `json:"inst_id"`
	Trade_date int32   `json:"trade_date"`
	High       float64 `json:"high"`
	Low        float64 `json:"low"`
	Open       float64 `json:"open"`
	Close      float64 `json:"close"`
	Settle     float64 `json:"settle"`
	Pre_close  float64 `json:"pre_close"`
	Pre_settle float64 `json:"pre_settle"`
	Suspended  bool    `json:"suspended"`
}

func (st *DailyStaticAfter) ResetDefault() {
	st.Suspended = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DailyStaticAfter) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.High, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Low, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Open, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Settle, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_close, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_settle, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Suspended, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DailyStaticAfter) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DailyStaticAfter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DailyStaticAfter) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.High, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Low, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Open, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Settle, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_close, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_settle, 8)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Suspended, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DailyStaticAfter) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DailyStaticAfterGroup struct implement
type DailyStaticAfterGroup struct {
	Afters []DailyStaticAfter `json:"afters"`
}

func (st *DailyStaticAfterGroup) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DailyStaticAfterGroup) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Afters = make([]DailyStaticAfter, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Afters[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DailyStaticAfterGroup) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DailyStaticAfterGroup, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DailyStaticAfterGroup) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Afters)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Afters {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *DailyStaticAfterGroup) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetBarReq struct implement
type GetBarReq struct {
	Inst_id    string            `json:"inst_id"`
	Inst_ids   []string          `json:"inst_ids"`
	Timespan   string            `json:"timespan"`
	Price_mode string            `json:"price_mode"`
	Start_time int64             `json:"start_time"`
	End_time   int64             `json:"end_time"`
	Count      int32             `json:"count"`
	Direct_db  bool              `json:"direct_db"`
	Start_date int32             `json:"start_date"`
	End_date   int32             `json:"end_date"`
	Extends    map[string]string `json:"extends"`
}

func (st *GetBarReq) ResetDefault() {
	st.Direct_db = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetBarReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Timespan, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_mode, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Start_time, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.End_time, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Count, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Direct_db, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Start_date, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.End_date, 9, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetBarReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetBarReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetBarReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Timespan, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_mode, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Start_time, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.End_time, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Count, 6)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Direct_db, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Start_date, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.End_date, 9)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extends {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetBarReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetBarRsp struct implement
type GetBarRsp struct {
	Bars      []Bar           `json:"bars"`
	Bar_group map[int64][]Bar `json:"bar_group"`
}

func (st *GetBarRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetBarRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bars = make([]Bar, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Bars[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Bar_group = make(map[int64][]Bar)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int64
			var v1 []Bar

			err = readBuf.ReadInt64(&k1, 0, false)
			if err != nil {
				return err
			}

			have, ty, err = readBuf.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]Bar, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = v1[i2].ReadBlock(readBuf, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SimpleList {
					err = fmt.Errorf("not support SimpleList type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.Bar_group[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetBarRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetBarRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetBarRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Bars)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bars {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Bar_group)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Bar_group {

		err = buf.WriteInt64(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v3)), 0)
		if err != nil {
			return err
		}

		for _, v := range v3 {

			err = v.WriteBlock(buf, 0)
			if err != nil {
				return err
			}

		}
	}

	return err
}

// WriteBlock encode struct
func (st *GetBarRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDailyBarReq struct implement
type GetDailyBarReq struct {
	Inst_ids   []string `json:"inst_ids"`
	Start_date int32    `json:"start_date"`
	End_date   int32    `json:"end_date"`
	Timespan   string   `json:"timespan"`
	Price_mode string   `json:"price_mode"`
	Direct_db  bool     `json:"direct_db"`
}

func (st *GetDailyBarReq) ResetDefault() {
	st.Direct_db = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetDailyBarReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Start_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.End_date, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Timespan, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_mode, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Direct_db, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetDailyBarReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDailyBarReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetDailyBarReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Start_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.End_date, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Timespan, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_mode, 4)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Direct_db, 5)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetDailyBarReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDailyBarRsp struct implement
type GetDailyBarRsp struct {
	Bars      []Bar           `json:"bars"`
	Bar_group map[int64][]Bar `json:"bar_group"`
}

func (st *GetDailyBarRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetDailyBarRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Bars = make([]Bar, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Bars[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Bar_group = make(map[int64][]Bar)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int64
			var v1 []Bar

			err = readBuf.ReadInt64(&k1, 0, false)
			if err != nil {
				return err
			}

			have, ty, err = readBuf.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]Bar, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = v1[i2].ReadBlock(readBuf, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SimpleList {
					err = fmt.Errorf("not support SimpleList type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.Bar_group[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetDailyBarRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDailyBarRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetDailyBarRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Bars)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Bars {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Bar_group)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Bar_group {

		err = buf.WriteInt64(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v3)), 0)
		if err != nil {
			return err
		}

		for _, v := range v3 {

			err = v.WriteBlock(buf, 0)
			if err != nil {
				return err
			}

		}
	}

	return err
}

// WriteBlock encode struct
func (st *GetDailyBarRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetTickReq struct implement
type GetTickReq struct {
	Inst_id    string            `json:"inst_id"`
	Inst_ids   []string          `json:"inst_ids"`
	Price_mode string            `json:"price_mode"`
	Start_time int64             `json:"start_time"`
	End_time   int64             `json:"end_time"`
	Count      int32             `json:"count"`
	Direct_db  bool              `json:"direct_db"`
	Extends    map[string]string `json:"extends"`
}

func (st *GetTickReq) ResetDefault() {
	st.Direct_db = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetTickReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Price_mode, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Start_time, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.End_time, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Count, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Direct_db, 6, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetTickReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetTickReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetTickReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Price_mode, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Start_time, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.End_time, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Count, 5)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Direct_db, 6)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extends {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetTickReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetTickRsp struct implement
type GetTickRsp struct {
	Ticks      []Tick           `json:"ticks"`
	Tick_group map[int64][]Tick `json:"tick_group"`
}

func (st *GetTickRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetTickRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ticks = make([]Tick, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Ticks[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Tick_group = make(map[int64][]Tick)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int64
			var v1 []Tick

			err = readBuf.ReadInt64(&k1, 0, false)
			if err != nil {
				return err
			}

			have, ty, err = readBuf.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]Tick, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = v1[i2].ReadBlock(readBuf, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SimpleList {
					err = fmt.Errorf("not support SimpleList type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.Tick_group[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetTickRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetTickRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetTickRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ticks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ticks {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Tick_group)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Tick_group {

		err = buf.WriteInt64(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v3)), 0)
		if err != nil {
			return err
		}

		for _, v := range v3 {

			err = v.WriteBlock(buf, 0)
			if err != nil {
				return err
			}

		}
	}

	return err
}

// WriteBlock encode struct
func (st *GetTickRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDailyTickReq struct implement
type GetDailyTickReq struct {
	Inst_ids   []string `json:"inst_ids"`
	Start_date int32    `json:"start_date"`
	End_date   int32    `json:"end_date"`
	Price_mode string   `json:"price_mode"`
	Direct_db  bool     `json:"direct_db"`
}

func (st *GetDailyTickReq) ResetDefault() {
	st.Direct_db = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetDailyTickReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Start_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.End_date, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_mode, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Direct_db, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetDailyTickReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDailyTickReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetDailyTickReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Start_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.End_date, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_mode, 3)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Direct_db, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetDailyTickReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetDailyTickRsp struct implement
type GetDailyTickRsp struct {
	Ticks      []Tick           `json:"ticks"`
	Tick_group map[int64][]Tick `json:"tick_group"`
}

func (st *GetDailyTickRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetDailyTickRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ticks = make([]Tick, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Ticks[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Tick_group = make(map[int64][]Tick)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 int64
			var v1 []Tick

			err = readBuf.ReadInt64(&k1, 0, false)
			if err != nil {
				return err
			}

			have, ty, err = readBuf.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					v1 = make([]Tick, length)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {

						err = v1[i2].ReadBlock(readBuf, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SimpleList {
					err = fmt.Errorf("not support SimpleList type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.Tick_group[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetDailyTickRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetDailyTickRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetDailyTickRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ticks)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ticks {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Tick_group)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Tick_group {

		err = buf.WriteInt64(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v3)), 0)
		if err != nil {
			return err
		}

		for _, v := range v3 {

			err = v.WriteBlock(buf, 0)
			if err != nil {
				return err
			}

		}
	}

	return err
}

// WriteBlock encode struct
func (st *GetDailyTickRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurBarReq struct implement
type GetCurBarReq struct {
	Kind      string   `json:"kind"`
	Run_id    string   `json:"run_id"`
	Timestamp int64    `json:"timestamp"`
	Inst_id   string   `json:"inst_id"`
	Inst_ids  []string `json:"inst_ids"`
	Timespan  int32    `json:"timespan"`
}

func (st *GetCurBarReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurBarReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Timespan, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurBarReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurBarReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurBarReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Timespan, 5)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurBarReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurBarRsp struct implement
type GetCurBarRsp struct {
	Data []Bar `json:"data"`
	Ret  Error `json:"ret"`
}

func (st *GetCurBarRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurBarRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]Bar, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Data[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurBarRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurBarRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurBarRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurBarRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurTickReq struct implement
type GetCurTickReq struct {
	Kind      string   `json:"kind"`
	Run_id    string   `json:"run_id"`
	Timestamp int64    `json:"timestamp"`
	Inst_id   string   `json:"inst_id"`
	Inst_ids  []string `json:"inst_ids"`
}

func (st *GetCurTickReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurTickReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurTickReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurTickReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurTickReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurTickReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurTickRsp struct implement
type GetCurTickRsp struct {
	Data []Tick `json:"data"`
	Ret  Error  `json:"ret"`
}

func (st *GetCurTickRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurTickRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Data = make([]Tick, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Data[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurTickRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurTickRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurTickRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Data)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Data {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurTickRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

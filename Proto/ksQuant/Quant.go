// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from Quant.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// MarketSetting struct implement
type MarketSetting struct {
	Market        string `json:"market"`
	Befor_trading int64  `json:"befor_trading"`
	Close_trading int64  `json:"close_trading"`
}

func (st *MarketSetting) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *MarketSetting) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Market, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Befor_trading, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Close_trading, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *MarketSetting) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MarketSetting, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *MarketSetting) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Market, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Befor_trading, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Close_trading, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *MarketSetting) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTCommission struct implement
type BTCommission struct {
	Mode  string  `json:"mode"`
	Value float64 `json:"value"`
}

func (st *BTCommission) ResetDefault() {
	st.Mode = "ABSR"
	st.Value = 0.0001
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTCommission) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Mode, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Value, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTCommission) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTCommission, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTCommission) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Mode, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Value, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BTCommission) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTLimitOrder struct implement
type BTLimitOrder struct {
	Mode  string  `json:"mode"`
	Value float64 `json:"value"`
}

func (st *BTLimitOrder) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTLimitOrder) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Mode, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Value, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTLimitOrder) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTLimitOrder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTLimitOrder) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Mode, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Value, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BTLimitOrder) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTDynamics struct implement
type BTDynamics struct {
	Change_date int32             `json:"change_date"`
	Dynamics    map[string]string `json:"dynamics"`
}

func (st *BTDynamics) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTDynamics) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Change_date, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Dynamics = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Dynamics[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTDynamics) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTDynamics, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTDynamics) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Change_date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Dynamics)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Dynamics {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTDynamics) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTAccount struct implement
type BTAccount struct {
	Id        string            `json:"id"`
	Market    string            `json:"market"`
	Init_cash float64           `json:"init_cash"`
	Extends   map[string]string `json:"extends"`
}

func (st *BTAccount) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTAccount) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Init_cash, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTAccount) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTAccount, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTAccount) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Init_cash, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTAccount) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTParam struct implement
type BTParam struct {
	Id                      string               `json:"id"`
	Desc                    string               `json:"desc"`
	Start_date              int64                `json:"start_date"`
	Stop_date               int64                `json:"stop_date"`
	Match_period            int32                `json:"match_period"`
	Replay_mode             string               `json:"replay_mode"`
	Timers                  map[string]string    `json:"timers"`
	Before_market_open_time int32                `json:"before_market_open_time"`
	Close_trade_time        int32                `json:"close_trade_time"`
	Params                  map[string]Parameter `json:"params"`
	Commission              BTCommission         `json:"commission"`
	Limit_order             BTLimitOrder         `json:"limit_order"`
	Slippage                int32                `json:"slippage"`
	Sync                    bool                 `json:"sync"`
	Match_style             string               `json:"match_style"`
	Accounts                map[string]BTAccount `json:"accounts"`
	Dynamics                []BTDynamics         `json:"dynamics"`
	Extends                 map[string]string    `json:"extends"`
}

func (st *BTParam) ResetDefault() {
	st.Start_date = -1
	st.Stop_date = -1
	st.Commission.ResetDefault()
	st.Limit_order.ResetDefault()
	st.Slippage = 0
	st.Sync = false
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTParam) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Desc, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Start_date, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Stop_date, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Match_period, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Replay_mode, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 6, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Timers = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Timers[k0] = v0
		}
	}

	err = readBuf.ReadInt32(&st.Before_market_open_time, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Close_trade_time, 8, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 9, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Params = make(map[string]Parameter)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 Parameter

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = v1.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Params[k1] = v1
		}
	}

	err = st.Commission.ReadBlock(readBuf, 10, false)
	if err != nil {
		return err
	}

	err = st.Limit_order.ReadBlock(readBuf, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Slippage, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Sync, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Match_style, 15, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 16, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Accounts = make(map[string]BTAccount)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 BTAccount

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = v2.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Accounts[k2] = v2
		}
	}

	have, ty, err = readBuf.SkipToNoCheck(17, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Dynamics = make([]BTDynamics, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Dynamics[i3].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 18, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i4, e4 := int32(0), length; i4 < e4; i4++ {
			var k4 string
			var v4 string

			err = readBuf.ReadString(&k4, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v4, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k4] = v4
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTParam) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTParam) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Desc, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Start_date, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Stop_date, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Match_period, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Replay_mode, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Timers)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.Timers {

		err = buf.WriteString(k5, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v5, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Before_market_open_time, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Close_trade_time, 8)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Params)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.Params {

		err = buf.WriteString(k6, 0)
		if err != nil {
			return err
		}

		err = v6.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = st.Commission.WriteBlock(buf, 10)
	if err != nil {
		return err
	}

	err = st.Limit_order.WriteBlock(buf, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Slippage, 13)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Sync, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Match_style, 15)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for k7, v7 := range st.Accounts {

		err = buf.WriteString(k7, 0)
		if err != nil {
			return err
		}

		err = v7.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 17)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Dynamics)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Dynamics {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 18)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k8, v8 := range st.Extends {

		err = buf.WriteString(k8, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v8, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTParam) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTRunInfo struct implement
type BTRunInfo struct {
	Id          string              `json:"id"`
	State       string              `json:"state"`
	Start_time  int64               `json:"start_time"`
	Stop_time   int64               `json:"stop_time"`
	Progress    float64             `json:"progress"`
	Update      int64               `json:"update"`
	Insts       map[string][]string `json:"insts"`
	Bar_counts  map[string]int64    `json:"bar_counts"`
	Date_counts map[string]int64    `json:"date_counts"`
}

func (st *BTRunInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTRunInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.State, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Start_time, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Stop_time, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Progress, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Update, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 6, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Insts = make(map[string][]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 []string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			have, ty, err = readBuf.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]string, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = readBuf.ReadString(&v0[i1], 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SimpleList {
					err = fmt.Errorf("not support SimpleList type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.Insts[k0] = v0
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 7, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Bar_counts = make(map[string]int64)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 int64

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt64(&v2, 1, false)
			if err != nil {
				return err
			}

			st.Bar_counts[k2] = v2
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 8, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Date_counts = make(map[string]int64)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 string
			var v3 int64

			err = readBuf.ReadString(&k3, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt64(&v3, 1, false)
			if err != nil {
				return err
			}

			st.Date_counts[k3] = v3
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTRunInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTRunInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTRunInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.State, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Start_time, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Stop_time, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Progress, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Update, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Insts)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.Insts {

		err = buf.WriteString(k4, 0)
		if err != nil {
			return err
		}

		err = buf.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v4)), 0)
		if err != nil {
			return err
		}

		for _, v := range v4 {

			err = buf.WriteString(v, 0)
			if err != nil {
				return err
			}

		}
	}

	err = buf.WriteHead(codec.MAP, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Bar_counts)), 0)
	if err != nil {
		return err
	}

	for k5, v5 := range st.Bar_counts {

		err = buf.WriteString(k5, 0)
		if err != nil {
			return err
		}

		err = buf.WriteInt64(v5, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Date_counts)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.Date_counts {

		err = buf.WriteString(k6, 0)
		if err != nil {
			return err
		}

		err = buf.WriteInt64(v6, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTRunInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTStrategyRunId struct implement
type BTStrategyRunId struct {
	Strategy_id string `json:"strategy_id"`
	Run_id      string `json:"run_id"`
	Created     int64  `json:"created"`
}

func (st *BTStrategyRunId) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTStrategyRunId) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Created, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTStrategyRunId) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTStrategyRunId, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTStrategyRunId) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Created, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BTStrategyRunId) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTStrategySnap struct implement
type BTStrategySnap struct {
	Date             int32       `json:"date"`
	Id               string      `json:"id"`
	Run_id           string      `json:"run_id"`
	Pnl              PnL         `json:"pnl"`
	Indicator        Indicator   `json:"indicator"`
	Focus_insts      []string    `json:"focus_insts"`
	Associated_insts []string    `json:"associated_insts"`
	Commission       float64     `json:"commission"`
	Positions        []Position  `json:"positions"`
	Orders           []Order     `json:"orders"`
	Executions       []Execution `json:"executions"`
}

func (st *BTStrategySnap) ResetDefault() {
	st.Pnl.ResetDefault()
	st.Indicator.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTStrategySnap) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Pnl.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	err = st.Indicator.ReadBlock(readBuf, 4, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Focus_insts = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Focus_insts[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Associated_insts = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Associated_insts[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadFloat64(&st.Commission, 7, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Positions = make([]Position, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Positions[i2].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]Order, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Orders[i3].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Executions = make([]Execution, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = st.Executions[i4].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTStrategySnap) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTStrategySnap, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTStrategySnap) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 2)
	if err != nil {
		return err
	}

	err = st.Pnl.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = st.Indicator.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Focus_insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Focus_insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Associated_insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Associated_insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteFloat64(st.Commission, 7)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Positions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Positions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Executions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Executions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTStrategySnap) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTAssetSnap struct implement
type BTAssetSnap struct {
	Date       int32       `json:"date"`
	Id         string      `json:"id"`
	Run_id     string      `json:"run_id"`
	Cash       Cash        `json:"cash"`
	Pnl        PnL         `json:"pnl"`
	Indicator  Indicator   `json:"indicator"`
	Positions  []Position  `json:"positions"`
	Orders     []Order     `json:"orders"`
	Executions []Execution `json:"executions"`
}

func (st *BTAssetSnap) ResetDefault() {
	st.Cash.ResetDefault()
	st.Pnl.ResetDefault()
	st.Indicator.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTAssetSnap) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Cash.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	err = st.Pnl.ReadBlock(readBuf, 4, false)
	if err != nil {
		return err
	}

	err = st.Indicator.ReadBlock(readBuf, 5, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Positions = make([]Position, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Positions[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]Order, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Orders[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Executions = make([]Execution, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Executions[i2].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTAssetSnap) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTAssetSnap, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTAssetSnap) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 2)
	if err != nil {
		return err
	}

	err = st.Cash.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = st.Pnl.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	err = st.Indicator.WriteBlock(buf, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Positions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Positions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Executions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Executions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTAssetSnap) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTSnap struct implement
type BTSnap struct {
	Id               string      `json:"id"`
	Pnl              PnL         `json:"pnl"`
	Indicator        Indicator   `json:"indicator"`
	Positions        []Position  `json:"positions"`
	Orders           []Order     `json:"orders"`
	Executions       []Execution `json:"executions"`
	Focus_insts      []string    `json:"focus_insts"`
	Associated_insts []string    `json:"associated_insts"`
	Commission       float64     `json:"commission"`
}

func (st *BTSnap) ResetDefault() {
	st.Pnl.ResetDefault()
	st.Indicator.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTSnap) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = st.Pnl.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Indicator.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Positions = make([]Position, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Positions[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]Order, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Orders[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Executions = make([]Execution, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Executions[i2].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Focus_insts = make([]string, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = readBuf.ReadString(&st.Focus_insts[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Associated_insts = make([]string, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = readBuf.ReadString(&st.Associated_insts[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadFloat64(&st.Commission, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTSnap) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTSnap, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTSnap) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = st.Pnl.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Indicator.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Positions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Positions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Executions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Executions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Focus_insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Focus_insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Associated_insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Associated_insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteFloat64(st.Commission, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BTSnap) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTRunDetailInfo struct implement
type BTRunDetailInfo struct {
	Basic BTParam          `json:"basic"`
	Run   BTRunInfo        `json:"run"`
	Snap  BTSnap           `json:"snap"`
	His   map[int32]BTSnap `json:"his"`
}

func (st *BTRunDetailInfo) ResetDefault() {
	st.Basic.ResetDefault()
	st.Run.ResetDefault()
	st.Snap.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTRunDetailInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Basic.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Run.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Snap.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.His = make(map[int32]BTSnap)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 BTSnap

			err = readBuf.ReadInt32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.His[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTRunDetailInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTRunDetailInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTRunDetailInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Basic.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Run.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Snap.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.His)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.His {

		err = buf.WriteInt32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTRunDetailInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimParam struct implement
type SimParam struct {
	Id          string            `json:"id"`
	Desc        string            `json:"desc"`
	Commission  BTCommission      `json:"commission"`
	Limit_order BTLimitOrder      `json:"limit_order"`
	Slippage    int32             `json:"slippage"`
	Sync        bool              `json:"sync"`
	Dynamics    map[string]string `json:"dynamics"`
}

func (st *SimParam) ResetDefault() {
	st.Commission.ResetDefault()
	st.Limit_order.ResetDefault()
	st.Sync = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimParam) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Desc, 1, false)
	if err != nil {
		return err
	}

	err = st.Commission.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	err = st.Limit_order.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Slippage, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Sync, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 6, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Dynamics = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Dynamics[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimParam) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimParam) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Desc, 1)
	if err != nil {
		return err
	}

	err = st.Commission.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = st.Limit_order.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Slippage, 4)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Sync, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Dynamics)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Dynamics {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimParam) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimRunInfo struct implement
type SimRunInfo struct {
	Id           string   `json:"id"`
	Strategy_ids []string `json:"strategy_ids"`
	State        string   `json:"state"`
	Custommsg    string   `json:"custommsg"`
	Overallpnl   float64  `json:"overallpnl"`
	Update       int64    `json:"update"`
}

func (st *SimRunInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimRunInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Strategy_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Strategy_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.State, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Custommsg, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Overallpnl, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Update, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimRunInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimRunInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimRunInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Strategy_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Strategy_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.State, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Custommsg, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Overallpnl, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Update, 5)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SimRunInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimStrategySnap struct implement
type SimStrategySnap struct {
	Pnl              PnL         `json:"pnl"`
	Indicator        Indicator   `json:"indicator"`
	Positions        []Position  `json:"positions"`
	Orders           []Order     `json:"orders"`
	Executions       []Execution `json:"executions"`
	Focus_insts      []string    `json:"focus_insts"`
	Associated_insts []string    `json:"associated_insts"`
	Commission       float64     `json:"commission"`
}

func (st *SimStrategySnap) ResetDefault() {
	st.Pnl.ResetDefault()
	st.Indicator.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimStrategySnap) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Pnl.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Indicator.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Positions = make([]Position, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Positions[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]Order, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Orders[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Executions = make([]Execution, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Executions[i2].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Focus_insts = make([]string, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = readBuf.ReadString(&st.Focus_insts[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Associated_insts = make([]string, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = readBuf.ReadString(&st.Associated_insts[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadFloat64(&st.Commission, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimStrategySnap) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimStrategySnap, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimStrategySnap) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Pnl.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Indicator.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Positions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Positions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Executions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Executions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Focus_insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Focus_insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Associated_insts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Associated_insts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteFloat64(st.Commission, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SimStrategySnap) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimRunDetailInfo struct implement
type SimRunDetailInfo struct {
	Basic SimParam                  `json:"basic"`
	Run   SimRunInfo                `json:"run"`
	Snap  SimStrategySnap           `json:"snap"`
	His   map[int32]SimStrategySnap `json:"his"`
}

func (st *SimRunDetailInfo) ResetDefault() {
	st.Basic.ResetDefault()
	st.Run.ResetDefault()
	st.Snap.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimRunDetailInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Basic.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Run.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Snap.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.His = make(map[int32]SimStrategySnap)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 SimStrategySnap

			err = readBuf.ReadInt32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.His[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimRunDetailInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimRunDetailInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimRunDetailInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Basic.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Run.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Snap.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.His)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.His {

		err = buf.WriteInt32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimRunDetailInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RTParam struct implement
type RTParam struct {
	Id       string            `json:"id"`
	Desc     string            `json:"desc"`
	Sync     bool              `json:"sync"`
	Dynamics map[string]string `json:"dynamics"`
}

func (st *RTParam) ResetDefault() {
	st.Sync = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RTParam) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Desc, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Sync, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Dynamics = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Dynamics[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RTParam) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RTParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RTParam) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Desc, 1)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Sync, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Dynamics)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Dynamics {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *RTParam) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RTRunDetailInfo struct implement
type RTRunDetailInfo struct {
	Basic RTParam `json:"basic"`
}

func (st *RTRunDetailInfo) ResetDefault() {
	st.Basic.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RTRunDetailInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Basic.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RTRunDetailInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RTRunDetailInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RTRunDetailInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Basic.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *RTRunDetailInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetBTParamsReq struct implement
type GetBTParamsReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetBTParamsReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetBTParamsReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetBTParamsReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetBTParamsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetBTParamsReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetBTParamsReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetBTParamsRsp struct implement
type GetBTParamsRsp struct {
	Info BTParam `json:"info"`
}

func (st *GetBTParamsRsp) ResetDefault() {
	st.Info.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetBTParamsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Info.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetBTParamsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetBTParamsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetBTParamsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Info.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetBTParamsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateBTParamsReq struct implement
type UpdateBTParamsReq struct {
	Param BTParam `json:"param"`
}

func (st *UpdateBTParamsReq) ResetDefault() {
	st.Param.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateBTParamsReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Param.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateBTParamsReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateBTParamsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateBTParamsReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Param.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateBTParamsReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateBTParamsRsp struct implement
type UpdateBTParamsRsp struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *UpdateBTParamsRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateBTParamsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateBTParamsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateBTParamsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateBTParamsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateBTParamsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAllBTRunReq struct implement
type GetAllBTRunReq struct {
	Run_ids      []string `json:"run_ids"`
	Strategy_ids []string `json:"strategy_ids"`
	With_snap    bool     `json:"with_snap"`
	With_his     bool     `json:"with_his"`
}

func (st *GetAllBTRunReq) ResetDefault() {
	st.With_snap = true
	st.With_his = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAllBTRunReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Run_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Run_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Strategy_ids = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Strategy_ids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadBool(&st.With_snap, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.With_his, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAllBTRunReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAllBTRunReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAllBTRunReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Run_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Run_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Strategy_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Strategy_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteBool(st.With_snap, 2)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.With_his, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetAllBTRunReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAllBTRunRsp struct implement
type GetAllBTRunRsp struct {
	Info []BTRunDetailInfo `json:"info"`
}

func (st *GetAllBTRunRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAllBTRunRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Info = make([]BTRunDetailInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Info[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAllBTRunRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAllBTRunRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAllBTRunRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Info)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Info {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetAllBTRunRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StartBTRunBatchReq struct implement
type StartBTRunBatchReq struct {
	Strategy_ids []string `json:"strategy_ids"`
	Run_mode     string   `json:"run_mode"`
}

func (st *StartBTRunBatchReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StartBTRunBatchReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Strategy_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Strategy_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Run_mode, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StartBTRunBatchReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StartBTRunBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StartBTRunBatchReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Strategy_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Strategy_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Run_mode, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StartBTRunBatchReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StartBTRunBatchRsp struct implement
type StartBTRunBatchRsp struct {
	Run_id string `json:"run_id"`
}

func (st *StartBTRunBatchRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StartBTRunBatchRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StartBTRunBatchRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StartBTRunBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StartBTRunBatchRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StartBTRunBatchRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StopBTRunBatchReq struct implement
type StopBTRunBatchReq struct {
	Run_id string `json:"run_id"`
}

func (st *StopBTRunBatchReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StopBTRunBatchReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StopBTRunBatchReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StopBTRunBatchReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StopBTRunBatchReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StopBTRunBatchReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StopBTRunBatchRsp struct implement
type StopBTRunBatchRsp struct {
	Run_id string `json:"run_id"`
}

func (st *StopBTRunBatchRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StopBTRunBatchRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StopBTRunBatchRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StopBTRunBatchRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StopBTRunBatchRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StopBTRunBatchRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTLastIndicatorReq struct implement
type GetCurrBTLastIndicatorReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTLastIndicatorReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTLastIndicatorReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTLastIndicatorReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTLastIndicatorReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTLastIndicatorReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTLastIndicatorReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTLastIndicatorRsp struct implement
type GetCurrBTLastIndicatorRsp struct {
	Value Indicator `json:"value"`
}

func (st *GetCurrBTLastIndicatorRsp) ResetDefault() {
	st.Value.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTLastIndicatorRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Value.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTLastIndicatorRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTLastIndicatorRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTLastIndicatorRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Value.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTLastIndicatorRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisIndicatorReq struct implement
type GetCurrBTHisIndicatorReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTHisIndicatorReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisIndicatorReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisIndicatorReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisIndicatorReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisIndicatorReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisIndicatorReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisIndicatorRsp struct implement
type GetCurrBTHisIndicatorRsp struct {
	Values map[int32]Indicator `json:"values"`
}

func (st *GetCurrBTHisIndicatorRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisIndicatorRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Values = make(map[int32]Indicator)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 Indicator

			err = readBuf.ReadInt32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Values[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisIndicatorRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisIndicatorRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisIndicatorRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Values)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Values {

		err = buf.WriteInt32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisIndicatorRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisPnLReq struct implement
type GetCurrBTHisPnLReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTHisPnLReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisPnLReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisPnLReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisPnLReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisPnLReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisPnLReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisPnLRsp struct implement
type GetCurrBTHisPnLRsp struct {
	Values map[int32]PnL `json:"values"`
}

func (st *GetCurrBTHisPnLRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisPnLRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Values = make(map[int32]PnL)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 PnL

			err = readBuf.ReadInt32(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Values[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisPnLRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisPnLRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisPnLRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Values)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Values {

		err = buf.WriteInt32(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisPnLRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisOrderReq struct implement
type GetCurrBTHisOrderReq struct {
	Strategy_id  string `json:"strategy_id"`
	Order_status string `json:"order_status"`
	Inst_id      string `json:"inst_id"`
}

func (st *GetCurrBTHisOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_status, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_status, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisOrderRsp struct implement
type GetCurrBTHisOrderRsp struct {
	Orders []Order `json:"orders"`
}

func (st *GetCurrBTHisOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]Order, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Orders[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisExecutionReq struct implement
type GetCurrBTHisExecutionReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTHisExecutionReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisExecutionReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisExecutionReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisExecutionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisExecutionReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisExecutionReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisExecutionRsp struct implement
type GetCurrBTHisExecutionRsp struct {
	Executions []Execution `json:"executions"`
}

func (st *GetCurrBTHisExecutionRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisExecutionRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Executions = make([]Execution, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Executions[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisExecutionRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisExecutionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisExecutionRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Executions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Executions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisExecutionRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisPosReq struct implement
type GetCurrBTHisPosReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTHisPosReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisPosReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisPosReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisPosReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisPosReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisPosReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisPosRsp struct implement
type GetCurrBTHisPosRsp struct {
	Positions []DailyPositions `json:"positions"`
}

func (st *GetCurrBTHisPosRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisPosRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Positions = make([]DailyPositions, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Positions[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisPosRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisPosRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisPosRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Positions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Positions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisPosRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisAssetReq struct implement
type GetCurrBTHisAssetReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTHisAssetReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisAssetReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisAssetReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisAssetReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisAssetReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisAssetReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisAssetRsp struct implement
type GetCurrBTHisAssetRsp struct {
	Assets map[int32][]Asset `json:"assets"`
}

func (st *GetCurrBTHisAssetRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisAssetRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Assets = make(map[int32][]Asset)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 int32
			var v0 []Asset

			err = readBuf.ReadInt32(&k0, 0, false)
			if err != nil {
				return err
			}

			have, ty, err = readBuf.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}

			if have {
				if ty == codec.LIST {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					v0 = make([]Asset, length)
					for i1, e1 := int32(0), length; i1 < e1; i1++ {

						err = v0[i1].ReadBlock(readBuf, 0, false)
						if err != nil {
							return err
						}

					}
				} else if ty == codec.SimpleList {
					err = fmt.Errorf("not support SimpleList type")
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not")
					if err != nil {
						return err
					}

				}
			}

			st.Assets[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisAssetRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisAssetRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisAssetRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Assets)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Assets {

		err = buf.WriteInt32(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteHead(codec.LIST, 1)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v2)), 0)
		if err != nil {
			return err
		}

		for _, v := range v2 {

			err = v.WriteBlock(buf, 0)
			if err != nil {
				return err
			}

		}
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisAssetRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTLogReq struct implement
type GetCurrBTLogReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTLogReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTLogReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTLogReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTLogReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTLogReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTLogReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTLogRsp struct implement
type GetCurrBTLogRsp struct {
	Logs []RunLog `json:"logs"`
}

func (st *GetCurrBTLogRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTLogRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Logs = make([]RunLog, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Logs[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTLogRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTLogRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTLogRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Logs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Logs {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTLogRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisInstReq struct implement
type GetCurrBTHisInstReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetCurrBTHisInstReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisInstReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisInstReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisInstReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisInstReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisInstReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyRunInfoReq struct implement
type GetStrategyRunInfoReq struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *GetStrategyRunInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyRunInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyRunInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyRunInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyRunInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyRunInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisInstRsp struct implement
type GetCurrBTHisInstRsp struct {
	Inst []string `json:"inst"`
}

func (st *GetCurrBTHisInstRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisInstRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisInstRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisInstRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisInstRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisInstRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisOrderDetailReq struct implement
type GetCurrBTHisOrderDetailReq struct {
	Strategy_id  string `json:"strategy_id"`
	Order_status string `json:"order_status"`
	Inst_id      string `json:"inst_id"`
}

func (st *GetCurrBTHisOrderDetailReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisOrderDetailReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_status, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisOrderDetailReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisOrderDetailReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisOrderDetailReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_status, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisOrderDetailReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCurrBTHisOrderDetailRsp struct implement
type GetCurrBTHisOrderDetailRsp struct {
	Executions []Execution `json:"executions"`
	Orders     []Order     `json:"orders"`
}

func (st *GetCurrBTHisOrderDetailRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCurrBTHisOrderDetailRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Executions = make([]Execution, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Executions[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]Order, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Orders[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCurrBTHisOrderDetailRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCurrBTHisOrderDetailRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCurrBTHisOrderDetailRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Executions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Executions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCurrBTHisOrderDetailRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateSimTradeReq struct implement
type UpdateSimTradeReq struct {
	Id          string            `json:"id"`
	Desc        string            `json:"desc"`
	Commission  BTCommission      `json:"commission"`
	Limit_order BTLimitOrder      `json:"limit_order"`
	Slippage    int32             `json:"slippage"`
	Sync        bool              `json:"sync"`
	Extends     map[string]string `json:"extends"`
}

func (st *UpdateSimTradeReq) ResetDefault() {
	st.Commission.ResetDefault()
	st.Limit_order.ResetDefault()
	st.Sync = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateSimTradeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Desc, 1, false)
	if err != nil {
		return err
	}

	err = st.Commission.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	err = st.Limit_order.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Slippage, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Sync, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 6, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateSimTradeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateSimTradeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateSimTradeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Desc, 1)
	if err != nil {
		return err
	}

	err = st.Commission.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = st.Limit_order.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Slippage, 4)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Sync, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UpdateSimTradeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateSimTradeRsp struct implement
type UpdateSimTradeRsp struct {
	Run_id  string           `json:"run_id"`
	Details SimRunDetailInfo `json:"details"`
}

func (st *UpdateSimTradeRsp) ResetDefault() {
	st.Details.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateSimTradeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Details.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateSimTradeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateSimTradeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateSimTradeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = st.Details.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateSimTradeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateRealTimeReq struct implement
type UpdateRealTimeReq struct {
	Id      string            `json:"id"`
	Desc    string            `json:"desc"`
	Sync    bool              `json:"sync"`
	Extends map[string]string `json:"extends"`
}

func (st *UpdateRealTimeReq) ResetDefault() {
	st.Sync = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateRealTimeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Desc, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Sync, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateRealTimeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateRealTimeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateRealTimeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Desc, 1)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Sync, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UpdateRealTimeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateRealTimeRsp struct implement
type UpdateRealTimeRsp struct {
	Run_id  string          `json:"run_id"`
	Details RTRunDetailInfo `json:"details"`
}

func (st *UpdateRealTimeRsp) ResetDefault() {
	st.Details.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateRealTimeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Details.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateRealTimeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateRealTimeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateRealTimeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = st.Details.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateRealTimeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyReq struct implement
type GetStrategyReq struct {
	Id string `json:"id"`
}

func (st *GetStrategyReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyRsp struct implement
type GetStrategyRsp struct {
	Info StrategyInfo `json:"info"`
}

func (st *GetStrategyRsp) ResetDefault() {
	st.Info.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Info.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Info.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddStrategyReq struct implement
type AddStrategyReq struct {
	Option StrategyOption `json:"option"`
}

func (st *AddStrategyReq) ResetDefault() {
	st.Option.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddStrategyReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Option.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddStrategyReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddStrategyReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddStrategyReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Option.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddStrategyReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddStrategyRsp struct implement
type AddStrategyRsp struct {
	Info StrategyInfo `json:"info"`
}

func (st *AddStrategyRsp) ResetDefault() {
	st.Info.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddStrategyRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Info.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddStrategyRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddStrategyRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddStrategyRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Info.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddStrategyRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyConnectReq struct implement
type StrategyConnectReq struct {
	Run_id      string         `json:"run_id"`
	Strategy_id string         `json:"strategy_id"`
	Run_mode    int32          `json:"run_mode"`
	Option      StrategyOption `json:"option"`
}

func (st *StrategyConnectReq) ResetDefault() {
	st.Option.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyConnectReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Run_mode, 2, false)
	if err != nil {
		return err
	}

	err = st.Option.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyConnectReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyConnectReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyConnectReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Run_mode, 2)
	if err != nil {
		return err
	}

	err = st.Option.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyConnectReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyConnectRsp struct implement
type StrategyConnectRsp struct {
	Info StrategyInfo `json:"info"`
	Ret  Error        `json:"ret"`
}

func (st *StrategyConnectRsp) ResetDefault() {
	st.Info.ResetDefault()
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyConnectRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Info.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyConnectRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyConnectRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyConnectRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Info.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyConnectRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyBTConnectReq struct implement
type StrategyBTConnectReq struct {
	Run_id      string  `json:"run_id"`
	Strategy_id string  `json:"strategy_id"`
	Auto_start  bool    `json:"auto_start"`
	With_param  bool    `json:"with_param"`
	Snap        BTParam `json:"snap"`
}

func (st *StrategyBTConnectReq) ResetDefault() {
	st.Auto_start = true
	st.With_param = true
	st.Snap.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyBTConnectReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Auto_start, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.With_param, 3, false)
	if err != nil {
		return err
	}

	err = st.Snap.ReadBlock(readBuf, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyBTConnectReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyBTConnectReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyBTConnectReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Auto_start, 2)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.With_param, 3)
	if err != nil {
		return err
	}

	err = st.Snap.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyBTConnectReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyBTConnectRsp struct implement
type StrategyBTConnectRsp struct {
	Run_id string       `json:"run_id"`
	Info   StrategyInfo `json:"info"`
	Param  BTParam      `json:"param"`
}

func (st *StrategyBTConnectRsp) ResetDefault() {
	st.Info.ResetDefault()
	st.Param.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyBTConnectRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Info.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Param.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyBTConnectRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyBTConnectRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyBTConnectRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = st.Info.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Param.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyBTConnectRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyCommonReq struct implement
type StrategyCommonReq struct {
	Func string `json:"func"`
	Buf  []int8 `json:"buf"`
}

func (st *StrategyCommonReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyCommonReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Func, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Buf = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadInt8(&st.Buf[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Buf, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyCommonReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyCommonReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyCommonReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Func, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.SimpleList, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Buf)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Buf)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyCommonReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyCommonRsp struct implement
type StrategyCommonRsp struct {
	Buf []int8 `json:"buf"`
}

func (st *StrategyCommonRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyCommonRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Buf = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadInt8(&st.Buf[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Buf, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyCommonRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyCommonRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyCommonRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.SimpleList, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Buf)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Buf)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyCommonRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTRunDetailContext struct implement
type BTRunDetailContext struct {
	Strategy_id string           `json:"strategy_id"`
	Run_id      string           `json:"run_id"`
	Orders      []Order          `json:"orders"`
	Executions  []Execution      `json:"executions"`
	Pnls        []PnL            `json:"pnls"`
	Indicators  []Indicator      `json:"indicators"`
	Cash        []Cash           `json:"cash"`
	Daily_pos   []DailyPositions `json:"daily_pos"`
	Assets      []Asset          `json:"assets"`
}

func (st *BTRunDetailContext) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTRunDetailContext) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Orders = make([]Order, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Orders[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Executions = make([]Execution, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Executions[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Pnls = make([]PnL, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Pnls[i2].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Indicators = make([]Indicator, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = st.Indicators[i3].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Cash = make([]Cash, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = st.Cash[i4].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Daily_pos = make([]DailyPositions, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = st.Daily_pos[i5].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Assets = make([]Asset, length)
			for i6, e6 := int32(0), length; i6 < e6; i6++ {

				err = st.Assets[i6].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTRunDetailContext) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTRunDetailContext, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTRunDetailContext) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Orders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Orders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Executions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Executions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Pnls)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Pnls {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Indicators)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Indicators {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Cash)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Cash {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Daily_pos)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Daily_pos {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Assets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Assets {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTRunDetailContext) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTContextRecord struct implement
type BTContextRecord struct {
	Strategy_id string `json:"strategy_id"`
	Run_id      string `json:"run_id"`
	Buf         []int8 `json:"buf"`
}

func (st *BTContextRecord) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTContextRecord) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Buf = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadInt8(&st.Buf[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Buf, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTContextRecord) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTContextRecord, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTContextRecord) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.SimpleList, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Buf)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Buf)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BTContextRecord) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetRunningPosInstReq struct implement
type GetRunningPosInstReq struct {
	Strategy_id string   `json:"strategy_id"`
	Account_id  string   `json:"account_id"`
	Side        []string `json:"side"`
}

func (st *GetRunningPosInstReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetRunningPosInstReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Side = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Side[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetRunningPosInstReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetRunningPosInstReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetRunningPosInstReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Side)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Side {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetRunningPosInstReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetRunningPosInstRsp struct implement
type GetRunningPosInstRsp struct {
	Inst_ids []string `json:"inst_ids"`
}

func (st *GetRunningPosInstRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetRunningPosInstRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetRunningPosInstRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetRunningPosInstRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetRunningPosInstRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetRunningPosInstRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryRunningPositionReq struct implement
type QueryRunningPositionReq struct {
	Strategy_id string `json:"strategy_id"`
	Account_id  string `json:"account_id"`
	Inst_id     string `json:"inst_id"`
	Side        string `json:"side"`
}

func (st *QueryRunningPositionReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryRunningPositionReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryRunningPositionReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryRunningPositionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryRunningPositionReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryRunningPositionReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryRunningPositionRsp struct implement
type QueryRunningPositionRsp struct {
	Positions []Position `json:"positions"`
}

func (st *QueryRunningPositionRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryRunningPositionRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Positions = make([]Position, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Positions[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryRunningPositionRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryRunningPositionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryRunningPositionRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Positions)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Positions {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryRunningPositionRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

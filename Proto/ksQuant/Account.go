// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from Account.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// TradeChannel struct implement
type TradeChannel struct {
	Channel_id    string            `json:"channel_id"`
	Channel_type  string            `json:"channel_type"`
	Alias         string            `json:"alias"`
	Protocol_type string            `json:"protocol_type"`
	Channel_args  map[string]string `json:"channel_args"`
	Extra         map[string]string `json:"extra"`
}

func (st *TradeChannel) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeChannel) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Channel_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel_type, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Alias, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Protocol_type, 3, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 4, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Channel_args = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Channel_args[k0] = v0
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 5, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeChannel) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeChannel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeChannel) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Channel_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel_type, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Alias, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Protocol_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Channel_args)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Channel_args {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TradeChannel) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SingleCommission struct implement
type SingleCommission struct {
	Comm float64 `json:"comm"`
}

func (st *SingleCommission) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SingleCommission) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadFloat64(&st.Comm, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SingleCommission) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SingleCommission, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SingleCommission) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteFloat64(st.Comm, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SingleCommission) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// MultiCommission struct implement
type MultiCommission struct {
	Comm         float64 `json:"comm"`
	Stamp_tax    float64 `json:"stamp_tax"`
	Transfer_fee float64 `json:"transfer_fee"`
	Exchange_fee float64 `json:"exchange_fee"`
	Other        float64 `json:"other"`
}

func (st *MultiCommission) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *MultiCommission) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadFloat64(&st.Comm, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Stamp_tax, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Transfer_fee, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Exchange_fee, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Other, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *MultiCommission) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MultiCommission, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *MultiCommission) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteFloat64(st.Comm, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Stamp_tax, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Transfer_fee, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Exchange_fee, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Other, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *MultiCommission) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TradeAccount struct implement
type TradeAccount struct {
	Account_id         string            `json:"account_id"`
	Password           string            `json:"password"`
	Counter_id         int32             `json:"counter_id"`
	Counter_code       string            `json:"counter_code"`
	Support_order_side []string          `json:"support_order_side"`
	Support_trade_type []string          `json:"support_trade_type"`
	Title              string            `json:"title"`
	Intro              string            `json:"intro"`
	Channel_id         string            `json:"channel_id"`
	Endpoint           string            `json:"endpoint"`
	Sync               bool              `json:"sync"`
	Commission_type    string            `json:"commission_type"`
	S_commission       SingleCommission  `json:"s_commission"`
	M_commission       MultiCommission   `json:"m_commission"`
	Status             string            `json:"status"`
	Extra              map[string]string `json:"extra"`
}

func (st *TradeAccount) ResetDefault() {
	st.Sync = true
	st.S_commission.ResetDefault()
	st.M_commission.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeAccount) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Password, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_code, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Support_order_side = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Support_order_side[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Support_trade_type = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Support_trade_type[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Title, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Intro, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Endpoint, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Sync, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Commission_type, 11, false)
	if err != nil {
		return err
	}

	err = st.S_commission.ReadBlock(readBuf, 12, false)
	if err != nil {
		return err
	}

	err = st.M_commission.ReadBlock(readBuf, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status, 14, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 15, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra = make(map[string]string)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 string

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v2, 1, false)
			if err != nil {
				return err
			}

			st.Extra[k2] = v2
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeAccount) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeAccount, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeAccount) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Password, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_code, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Support_order_side)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Support_order_side {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Support_trade_type)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Support_trade_type {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Title, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Intro, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Endpoint, 9)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Sync, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Commission_type, 11)
	if err != nil {
		return err
	}

	err = st.S_commission.WriteBlock(buf, 12)
	if err != nil {
		return err
	}

	err = st.M_commission.WriteBlock(buf, 13)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status, 14)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TradeAccount) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyOrder struct implement
type StrategyOrder struct {
	Order_id        string            `json:"order_id"`
	Strategy_id     string            `json:"strategy_id"`
	User_id         string            `json:"user_id"`
	Account_id      string            `json:"account_id"`
	Symbol          string            `json:"symbol"`
	Code            string            `json:"code"`
	Market_id       string            `json:"market_id"`
	Side            string            `json:"side"`
	Qty             int64             `json:"qty"`
	Price           float64           `json:"price"`
	Price_type      string            `json:"price_type"`
	Entrust_id      string            `json:"entrust_id"`
	Order_status    string            `json:"order_status"`
	Cum_qty         int64             `json:"cum_qty"`
	Avg_price       float64           `json:"avg_price"`
	Last_qty        int64             `json:"last_qty"`
	Last_price      float64           `json:"last_price"`
	Cancel_qty      int64             `json:"cancel_qty"`
	Request_message string            `json:"request_message"`
	Counter_message string            `json:"counter_message"`
	System_message  string            `json:"system_message"`
	Created         int64             `json:"created"`
	Modified        int64             `json:"modified"`
	Trade_date      int32             `json:"trade_date"`
	Extends         map[string]string `json:"extends"`
}

func (st *StrategyOrder) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyOrder) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Order_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Symbol, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Code, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Qty, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_status, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Cum_qty, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Avg_price, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Last_qty, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_price, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Cancel_qty, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Request_message, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_message, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.System_message, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Created, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Modified, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 23, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 24, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyOrder) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyOrder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyOrder) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Symbol, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Code, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Qty, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_status, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Cum_qty, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Avg_price, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Last_qty, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_price, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Cancel_qty, 17)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Request_message, 18)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_message, 19)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.System_message, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Created, 21)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Modified, 22)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 23)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 24)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *StrategyOrder) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// PnL struct implement
type PnL struct {
	Id       string  `json:"id"`
	Actual   float64 `json:"actual"`
	Ur       float64 `json:"ur"`
	Daily    float64 `json:"daily"`
	Dailyur  float64 `json:"dailyur"`
	Overall  float64 `json:"overall"`
	Cum      float64 `json:"cum"`
	Last_nav float64 `json:"last_nav"`
	Date     int32   `json:"date"`
	M2m      float64 `json:"m2m"`
}

func (st *PnL) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *PnL) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Actual, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Ur, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Daily, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Dailyur, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Overall, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cum, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_nav, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Date, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.M2m, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *PnL) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PnL, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *PnL) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Actual, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Ur, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Daily, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Dailyur, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Overall, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cum, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_nav, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Date, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.M2m, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *PnL) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Cash struct implement
type Cash struct {
	Id             string  `json:"id"`
	Available      float64 `json:"available"`
	Balance        float64 `json:"balance"`
	Frozen         float64 `json:"frozen"`
	Order_frozen   float64 `json:"order_frozen"`
	Cum_inout      float64 `json:"cum_inout"`
	Cum_commission float64 `json:"cum_commission"`
	Last_nav       float64 `json:"last_nav"`
	Date           int32   `json:"date"`
}

func (st *Cash) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Cash) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Available, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Balance, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_frozen, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cum_inout, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cum_commission, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_nav, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Date, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Cash) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Cash, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Cash) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Available, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Balance, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_frozen, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cum_inout, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cum_commission, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_nav, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Date, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Cash) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Indicator struct implement
type Indicator struct {
	Id               string  `json:"id"`
	Last_nav         float64 `json:"last_nav"`
	Pnl_ratio        float64 `json:"pnl_ratio"`
	Pnl_ratio_annual float64 `json:"pnl_ratio_annual"`
	Sharp_ratio      float64 `json:"sharp_ratio"`
	Volatility       float64 `json:"volatility"`
	Max_drawdown     float64 `json:"max_drawdown"`
	Risk_ratio       float64 `json:"risk_ratio"`
	Open_count       int32   `json:"open_count"`
	Close_count      int32   `json:"close_count"`
	Win_count        int32   `json:"win_count"`
	Lose_count       int32   `json:"lose_count"`
	Year_win_ratio   float64 `json:"year_win_ratio"`
	Month_win_ratio  float64 `json:"month_win_ratio"`
	Day_win_ratio    float64 `json:"day_win_ratio"`
	Date             int32   `json:"date"`
}

func (st *Indicator) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Indicator) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_nav, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pnl_ratio, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pnl_ratio_annual, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Sharp_ratio, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Volatility, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Max_drawdown, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Risk_ratio, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Open_count, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Close_count, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Win_count, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Lose_count, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Year_win_ratio, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Month_win_ratio, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Day_win_ratio, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Date, 15, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Indicator) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Indicator, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Indicator) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_nav, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pnl_ratio, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pnl_ratio_annual, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Sharp_ratio, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Volatility, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Max_drawdown, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Risk_ratio, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Open_count, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Close_count, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Win_count, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Lose_count, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Year_win_ratio, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Month_win_ratio, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Day_win_ratio, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Date, 15)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Indicator) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyIndicator struct implement
type StrategyIndicator struct {
	Run_id string    `json:"run_id"`
	Ind    Indicator `json:"ind"`
}

func (st *StrategyIndicator) ResetDefault() {
	st.Ind.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyIndicator) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Ind.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyIndicator) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyIndicator, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyIndicator) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = st.Ind.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyIndicator) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account struct implement
type Account struct {
	Id          string       `json:"id"`
	Currency    string       `json:"currency"`
	Desc        string       `json:"desc"`
	Name        string       `json:"name"`
	Markets     []string     `json:"markets"`
	Enable_real bool         `json:"enable_real"`
	M_trade     TradeAccount `json:"m_trade"`
}

func (st *Account) ResetDefault() {
	st.Enable_real = true
	st.M_trade.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Account) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Desc, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Markets = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Markets[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadBool(&st.Enable_real, 5, false)
	if err != nil {
		return err
	}

	err = st.M_trade.ReadBlock(readBuf, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Account) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Account) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Desc, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Markets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Markets {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteBool(st.Enable_real, 5)
	if err != nil {
		return err
	}

	err = st.M_trade.WriteBlock(buf, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Account) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Asset struct implement
type Asset struct {
	Id           string    `json:"id"`
	Run_id       string    `json:"run_id"`
	Cash         Cash      `json:"cash"`
	Pnl          PnL       `json:"pnl"`
	Indicator    Indicator `json:"indicator"`
	Total        float64   `json:"total"`
	Market_value float64   `json:"market_value"`
	Date         int32     `json:"date"`
}

func (st *Asset) ResetDefault() {
	st.Cash.ResetDefault()
	st.Pnl.ResetDefault()
	st.Indicator.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Asset) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = st.Cash.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	err = st.Pnl.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	err = st.Indicator.ReadBlock(readBuf, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Market_value, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Date, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Asset) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Asset, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Asset) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = st.Cash.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = st.Pnl.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = st.Indicator.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Market_value, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Date, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Asset) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddAccountReq struct implement
type AddAccountReq struct {
	Basic        Account `json:"basic"`
	Deposit_cash float64 `json:"deposit_cash"`
}

func (st *AddAccountReq) ResetDefault() {
	st.Basic.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Basic.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Deposit_cash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Basic.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Deposit_cash, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddAccountRsp struct implement
type AddAccountRsp struct {
	Id string `json:"id"`
}

func (st *AddAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelAccountReq struct implement
type DelAccountReq struct {
	Id string `json:"id"`
}

func (st *DelAccountReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DelAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelAccountRsp struct implement
type DelAccountRsp struct {
	Extends map[string]string `json:"extends"`
}

func (st *DelAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *DelAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateAccountReq struct implement
type UpdateAccountReq struct {
	Basic Account `json:"basic"`
}

func (st *UpdateAccountReq) ResetDefault() {
	st.Basic.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Basic.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Basic.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateAccountRsp struct implement
type UpdateAccountRsp struct {
	Id string `json:"id"`
}

func (st *UpdateAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimDepositReq struct implement
type SimDepositReq struct {
	Id           string  `json:"id"`
	Deposit_cash float64 `json:"deposit_cash"`
}

func (st *SimDepositReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimDepositReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Deposit_cash, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimDepositReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimDepositReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimDepositReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Deposit_cash, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SimDepositReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimDepositRsp struct implement
type SimDepositRsp struct {
	Account Asset `json:"account"`
}

func (st *SimDepositRsp) ResetDefault() {
	st.Account.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimDepositRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Account.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimDepositRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimDepositRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimDepositRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Account.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SimDepositRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAssetReq struct implement
type GetAssetReq struct {
	Kind   string   `json:"kind"`
	Run_id string   `json:"run_id"`
	Type   string   `json:"type"`
	Ids    []string `json:"ids"`
}

func (st *GetAssetReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAssetReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Type, 2, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAssetReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAssetReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAssetReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Type, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetAssetReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAssetRsp struct implement
type GetAssetRsp struct {
	Accounts []Asset `json:"accounts"`
	Ret      Error   `json:"ret"`
}

func (st *GetAssetRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAssetRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Accounts = make([]Asset, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Accounts[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAssetRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAssetRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAssetRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Accounts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetAssetRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAccountReq struct implement
type GetAccountReq struct {
	Ids         []string `json:"ids"`
	Market      string   `json:"market"`
	Filter_real bool     `json:"filter_real"`
}

func (st *GetAccountReq) ResetDefault() {
	st.Filter_real = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Market, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Filter_real, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Market, 1)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Filter_real, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAccountRsp struct implement
type GetAccountRsp struct {
	Accounts []Account `json:"accounts"`
}

func (st *GetAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Accounts = make([]Account, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Accounts[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Accounts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryAccountReq struct implement
type QueryAccountReq struct {
	Run_id      string   `json:"run_id"`
	Strategy_id string   `json:"strategy_id"`
	Ids         []string `json:"ids"`
	Market      []string `json:"market"`
}

func (st *QueryAccountReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryAccountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Market = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Market[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryAccountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryAccountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryAccountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Market)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Market {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryAccountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryAccountRsp struct implement
type QueryAccountRsp struct {
	M_trade  []TradeAccount `json:"m_trade"`
	Accounts []Account      `json:"accounts"`
}

func (st *QueryAccountRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryAccountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.M_trade = make([]TradeAccount, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.M_trade[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Accounts = make([]Account, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Accounts[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryAccountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryAccountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryAccountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.M_trade)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.M_trade {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Accounts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryAccountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

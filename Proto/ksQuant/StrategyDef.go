// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from StrategyDef.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type SubProcState int32

const (
	SubProcState_SPS_STOPPED     = 0
	SubProcState_SPS_STARTING    = 1
	SubProcState_SPS_RUNNING     = 2
	SubProcState_SPS_PENDING_RUN = 3
	SubProcState_SPS_ZOMBIE      = 4
	SubProcState_SPS_TERMINATE   = 5
)

type ParamType int32

const (
	ParamType_SPT_NONE  = 0
	ParamType_SPT_BASIC = 1
	ParamType_SPT_Inst  = 2
)

type PiType int32

const (
	PiType_PI_NONE   = 0
	PiType_PI_TARGET = 1
	PiType_PI_EXIT   = 2
)

type ExecutionMode int32

const (
	ExecutionMode_EM_START     = 0
	ExecutionMode_EM_CANCELING = 1
	ExecutionMode_EM_CANCELED  = 2
	ExecutionMode_EM_AMENDING  = 3
	ExecutionMode_EM_AMENDED   = 4
	ExecutionMode_EM_ENTERING  = 5
	ExecutionMode_EM_END       = 6
)

type RunLogLevel int32

const (
	RunLogLevel_REMOTE_NONE  = 0
	RunLogLevel_REMOTE_DEBUG = 1
	RunLogLevel_REMOTE_INFO  = 2
	RunLogLevel_REMOTE_WARN  = 3
	RunLogLevel_REMOTE_ERROR = 4
	RunLogLevel_REMOTE_ANY   = 5
)

type CancelType int32

const (
	CancelType_CT_NONE = 0
	CancelType_CT_INST = 1
	CancelType_CT_ID   = 2
	CancelType_CT_ALL  = 3
)

// const as define in ksf file
const (
	EPK_NOTE string = "EPK_NOTE"
	EPK_HOST string = "EPK_HOST"
	EPK_PID  string = "EPK_PID"
)

// Parameter struct implement
type Parameter struct {
	Name     string `json:"name"`
	Etype    string `json:"etype"`
	Required bool   `json:"required"`
	Value    string `json:"value"`
	Update   int64  `json:"update"`
}

func (st *Parameter) ResetDefault() {
	st.Required = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Parameter) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Name, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Etype, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Required, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Value, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Update, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Parameter) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Parameter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Parameter) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Name, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Etype, 1)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Required, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Value, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Update, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Parameter) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyOption struct implement
type StrategyOption struct {
	Name        string               `json:"name"`
	Group       string               `json:"group"`
	Stype       string               `json:"stype"`
	Desc        string               `json:"desc"`
	User_id     string               `json:"user_id"`
	Is_private  bool                 `json:"is_private"`
	Source_code string               `json:"source_code"`
	Params      map[string]Parameter `json:"params"`
	Extends     map[string]string    `json:"extends"`
	Lang        string               `json:"lang"`
}

func (st *StrategyOption) ResetDefault() {
	st.Is_private = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyOption) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Name, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Group, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stype, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Desc, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_private, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Source_code, 6, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 7, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Params = make(map[string]Parameter)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 Parameter

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Params[k0] = v0
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 8, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	err = readBuf.ReadString(&st.Lang, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyOption) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyOption, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyOption) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Name, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Group, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stype, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Desc, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_private, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Source_code, 6)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = v2.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extends {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Lang, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyOption) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyTemplate struct implement
type StrategyTemplate struct {
	Id     string         `json:"id"`
	Option StrategyOption `json:"option"`
}

func (st *StrategyTemplate) ResetDefault() {
	st.Option.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyTemplate) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = st.Option.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyTemplate) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyTemplate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyTemplate) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = st.Option.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyTemplate) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyDynamicParam struct implement
type StrategyDynamicParam struct {
	Analyzer_params map[string]Parameter `json:"analyzer_params"`
	Extends         map[string]string    `json:"extends"`
	Update          int64                `json:"update"`
}

func (st *StrategyDynamicParam) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyDynamicParam) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Analyzer_params = make(map[string]Parameter)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 Parameter

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Analyzer_params[k0] = v0
		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	err = readBuf.ReadInt64(&st.Update, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyDynamicParam) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyDynamicParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyDynamicParam) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Analyzer_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Analyzer_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = v2.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extends {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt64(st.Update, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyDynamicParam) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyRunTimeState struct implement
type StrategyRunTimeState struct {
	Id       string `json:"id"`
	Run_time int64  `json:"run_time"`
	State    string `json:"state"`
}

func (st *StrategyRunTimeState) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyRunTimeState) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Run_time, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.State, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyRunTimeState) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyRunTimeState, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyRunTimeState) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Run_time, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.State, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyRunTimeState) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyInfo struct implement
type StrategyInfo struct {
	Id             string                 `json:"id"`
	Option         StrategyOption         `json:"option"`
	Create         int64                  `json:"create"`
	Update         int64                  `json:"update"`
	Last_runid     string                 `json:"last_runid"`
	Run_time_state []StrategyRunTimeState `json:"run_time_state"`
}

func (st *StrategyInfo) ResetDefault() {
	st.Option.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = st.Option.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Create, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Update, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Last_runid, 4, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Run_time_state = make([]StrategyRunTimeState, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Run_time_state[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = st.Option.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Create, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Update, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Last_runid, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Run_time_state)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Run_time_state {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *StrategyInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TargetPositionInstruction struct implement
type TargetPositionInstruction struct {
	Kind            string            `json:"kind"`
	Id              string            `json:"id"`
	Run_id          string            `json:"run_id"`
	Strategy_id     string            `json:"strategy_id"`
	Account_id      string            `json:"account_id"`
	Inst_id         string            `json:"inst_id"`
	Pos_side        string            `json:"pos_side"`
	Target_pos_type string            `json:"target_pos_type"`
	Qty             float64           `json:"qty"`
	Percent         float64           `json:"percent"`
	Price           float64           `json:"price"`
	Remarks         string            `json:"remarks"`
	Tif             string            `json:"tif"`
	Price_list      string            `json:"price_list"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *TargetPositionInstruction) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TargetPositionInstruction) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pos_side, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Target_pos_type, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Qty, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Percent, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remarks, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Tif, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_list, 13, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 14, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TargetPositionInstruction) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TargetPositionInstruction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TargetPositionInstruction) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pos_side, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Target_pos_type, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Qty, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Percent, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remarks, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Tif, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_list, 13)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TargetPositionInstruction) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TargetPositionInstructionList struct implement
type TargetPositionInstructionList struct {
	Instrs []TargetPositionInstruction `json:"instrs"`
}

func (st *TargetPositionInstructionList) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TargetPositionInstructionList) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Instrs = make([]TargetPositionInstruction, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Instrs[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TargetPositionInstructionList) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TargetPositionInstructionList, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TargetPositionInstructionList) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Instrs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Instrs {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TargetPositionInstructionList) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TargetPositionInstructionKey struct implement
type TargetPositionInstructionKey struct {
	Inst_id      string `json:"inst_id"`
	PositionSide string `json:"positionSide"`
}

func (st *TargetPositionInstructionKey) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TargetPositionInstructionKey) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.PositionSide, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TargetPositionInstructionKey) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TargetPositionInstructionKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TargetPositionInstructionKey) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.PositionSide, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TargetPositionInstructionKey) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderInstruction struct implement
type OrderInstruction struct {
	Kind         string  `json:"kind"`
	Id           string  `json:"id"`
	Run_id       string  `json:"run_id"`
	Strategy_id  string  `json:"strategy_id"`
	Account_id   string  `json:"account_id"`
	Inst_id      string  `json:"inst_id"`
	Tif          int32   `json:"tif"`
	PositionSide string  `json:"positionSide"`
	Qty          float64 `json:"qty"`
	Price        float64 `json:"price"`
}

func (st *OrderInstruction) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderInstruction) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Tif, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.PositionSide, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Qty, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderInstruction) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderInstruction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderInstruction) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Tif, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.PositionSide, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Qty, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *OrderInstruction) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ForceSettlePosition struct implement
type ForceSettlePosition struct {
	Kind         string  `json:"kind"`
	Id           string  `json:"id"`
	Run_id       string  `json:"run_id"`
	Strategy_id  string  `json:"strategy_id"`
	Account_id   string  `json:"account_id"`
	Inst_id      string  `json:"inst_id"`
	PositionSide string  `json:"positionSide"`
	Price        float64 `json:"price"`
	Remarks      string  `json:"remarks"`
}

func (st *ForceSettlePosition) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ForceSettlePosition) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.PositionSide, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remarks, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ForceSettlePosition) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ForceSettlePosition, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ForceSettlePosition) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.PositionSide, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remarks, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ForceSettlePosition) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyFocusInstruments struct implement
type StrategyFocusInstruments struct {
	Inst_ids  []string `json:"inst_ids"`
	Inst_sets []string `json:"inst_sets"`
}

func (st *StrategyFocusInstruments) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyFocusInstruments) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_sets = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Inst_sets[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyFocusInstruments) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyFocusInstruments, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyFocusInstruments) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_sets)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_sets {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *StrategyFocusInstruments) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SetFocusInstrumentsReq struct implement
type SetFocusInstrumentsReq struct {
	Kind        string                   `json:"kind"`
	Run_id      string                   `json:"run_id"`
	Strategy_id string                   `json:"strategy_id"`
	Focus       StrategyFocusInstruments `json:"focus"`
}

func (st *SetFocusInstrumentsReq) ResetDefault() {
	st.Focus.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SetFocusInstrumentsReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = st.Focus.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SetFocusInstrumentsReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SetFocusInstrumentsReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SetFocusInstrumentsReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = st.Focus.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SetFocusInstrumentsReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SetFocusInstrumentsRsp struct implement
type SetFocusInstrumentsRsp struct {
	Strategy_id string   `json:"strategy_id"`
	Inst_ids    []string `json:"inst_ids"`
	Ret         Error    `json:"ret"`
}

func (st *SetFocusInstrumentsRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SetFocusInstrumentsRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SetFocusInstrumentsRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SetFocusInstrumentsRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SetFocusInstrumentsRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SetFocusInstrumentsRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// EVExternalMsg struct implement
type EVExternalMsg struct {
	Level       RunLogLevel `json:"level"`
	Msg         string      `json:"msg"`
	Strategy_id string      `json:"strategy_id"`
	Run_id      string      `json:"run_id"`
	Timestamp   int64       `json:"timestamp"`
}

func (st *EVExternalMsg) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *EVExternalMsg) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32((*int32)(&st.Level), 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *EVExternalMsg) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EVExternalMsg, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *EVExternalMsg) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(int32(st.Level), 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *EVExternalMsg) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ExternalStrategyExit struct implement
type ExternalStrategyExit struct {
	Code int32  `json:"code"`
	Msg  string `json:"msg"`
}

func (st *ExternalStrategyExit) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ExternalStrategyExit) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ExternalStrategyExit) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ExternalStrategyExit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ExternalStrategyExit) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Code, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ExternalStrategyExit) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CachedInst struct implement
type CachedInst struct {
	Inst_id string `json:"inst_id"`
}

func (st *CachedInst) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CachedInst) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Inst_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CachedInst) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CachedInst, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CachedInst) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Inst_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CachedInst) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderQtyInstruction struct implement
type OrderQtyInstruction struct {
	Id          string  `json:"id"`
	Run_id      string  `json:"run_id"`
	Strategy_id string  `json:"strategy_id"`
	Account_id  string  `json:"account_id"`
	Inst_id     string  `json:"inst_id"`
	Qty         float64 `json:"qty"`
	Price       float64 `json:"price"`
	Side        string  `json:"side"`
	Remarks     string  `json:"remarks"`
}

func (st *OrderQtyInstruction) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderQtyInstruction) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Qty, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remarks, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderQtyInstruction) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderQtyInstruction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderQtyInstruction) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Qty, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remarks, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *OrderQtyInstruction) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderValueInstruction struct implement
type OrderValueInstruction struct {
	Id             string  `json:"id"`
	Run_id         string  `json:"run_id"`
	Strategy_id    string  `json:"strategy_id"`
	Account_id     string  `json:"account_id"`
	Inst_id        string  `json:"inst_id"`
	Value          float64 `json:"value"`
	Price          float64 `json:"price"`
	OrderSide      int32   `json:"orderSide"`
	PositionEffect int32   `json:"positionEffect"`
	Tif            int32   `json:"tif"`
	Remarks        string  `json:"remarks"`
}

func (st *OrderValueInstruction) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderValueInstruction) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Value, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.OrderSide, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.PositionEffect, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Tif, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remarks, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderValueInstruction) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderValueInstruction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderValueInstruction) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Value, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.OrderSide, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.PositionEffect, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Tif, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remarks, 10)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *OrderValueInstruction) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderPercentInstruction struct implement
type OrderPercentInstruction struct {
	Id             string  `json:"id"`
	Run_id         string  `json:"run_id"`
	Strategy_id    string  `json:"strategy_id"`
	Account_id     string  `json:"account_id"`
	Inst_id        string  `json:"inst_id"`
	Percent        float64 `json:"percent"`
	Price          float64 `json:"price"`
	OrderSide      int32   `json:"orderSide"`
	PositionEffect int32   `json:"positionEffect"`
	Tif            int32   `json:"tif"`
	Remarks        string  `json:"remarks"`
}

func (st *OrderPercentInstruction) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderPercentInstruction) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Percent, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.OrderSide, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.PositionEffect, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Tif, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remarks, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderPercentInstruction) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderPercentInstruction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderPercentInstruction) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Percent, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.OrderSide, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.PositionEffect, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Tif, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remarks, 10)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *OrderPercentInstruction) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderCancelInstruction struct implement
type OrderCancelInstruction struct {
	Run_id      string `json:"run_id"`
	Strategy_id string `json:"strategy_id"`
	Account_id  string `json:"account_id"`
	Cancel_by   string `json:"cancel_by"`
	Inst_id     string `json:"inst_id"`
	Order_id    string `json:"order_id"`
	Entrust_id  string `json:"entrust_id"`
	Side        string `json:"side"`
	Remarks     string `json:"remarks"`
}

func (st *OrderCancelInstruction) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderCancelInstruction) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_by, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remarks, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderCancelInstruction) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderCancelInstruction, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderCancelInstruction) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_by, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remarks, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *OrderCancelInstruction) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyStatus struct implement
type StrategyStatus struct {
	AccountId     string `json:"accountId"`
	AllTerminated bool   `json:"allTerminated"`
}

func (st *StrategyStatus) ResetDefault() {
	st.AllTerminated = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyStatus) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.AccountId, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.AllTerminated, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyStatus) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyStatus) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.AccountId, 0)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.AllTerminated, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyStatus) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAllStrategyReq struct implement
type GetAllStrategyReq struct {
	User_id []string `json:"user_id"`
	Stype   []string `json:"stype"`
	Group   []string `json:"group"`
	Detail  bool     `json:"detail"`
}

func (st *GetAllStrategyReq) ResetDefault() {
	st.Detail = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAllStrategyReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.User_id = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.User_id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stype = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Stype[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Group = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Group[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadBool(&st.Detail, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAllStrategyReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAllStrategyReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAllStrategyReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.User_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.User_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Stype)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stype {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Group)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Group {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteBool(st.Detail, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetAllStrategyReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAllStrategyRsp struct implement
type GetAllStrategyRsp struct {
	Details []StrategyInfo `json:"details"`
	Ret     Error          `json:"ret"`
}

func (st *GetAllStrategyRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAllStrategyRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Details = make([]StrategyInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Details[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAllStrategyRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAllStrategyRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAllStrategyRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Details)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Details {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetAllStrategyRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelStrategyReq struct implement
type DelStrategyReq struct {
	Strategy_ids []string          `json:"strategy_ids"`
	Extends      map[string]string `json:"extends"`
}

func (st *DelStrategyReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelStrategyReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Strategy_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Strategy_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelStrategyReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelStrategyReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelStrategyReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Strategy_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Strategy_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extends {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *DelStrategyReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelStrategyRsp struct implement
type DelStrategyRsp struct {
	Extends map[string]string `json:"extends"`
	Ret     Error             `json:"ret"`
}

func (st *DelStrategyRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelStrategyRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelStrategyRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelStrategyRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelStrategyRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DelStrategyRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateStrategyReq struct implement
type UpdateStrategyReq struct {
	Info StrategyInfo `json:"info"`
}

func (st *UpdateStrategyReq) ResetDefault() {
	st.Info.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateStrategyReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Info.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateStrategyReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateStrategyReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateStrategyReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Info.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateStrategyReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateStrategyRsp struct implement
type UpdateStrategyRsp struct {
	Detail StrategyInfo `json:"detail"`
	Ret    Error        `json:"ret"`
}

func (st *UpdateStrategyRsp) ResetDefault() {
	st.Detail.ResetDefault()
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateStrategyRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Detail.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateStrategyRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateStrategyRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateStrategyRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Detail.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateStrategyRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddParametersReq struct implement
type AddParametersReq struct {
	Strategy_id string            `json:"strategy_id"`
	Params      []Parameter       `json:"params"`
	Extends     map[string]string `json:"extends"`
}

func (st *AddParametersReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddParametersReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Params = make([]Parameter, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Params[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddParametersReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddParametersReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddParametersReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Params)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Params {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extends {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AddParametersReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddParametersRsp struct implement
type AddParametersRsp struct {
	Extends map[string]string `json:"extends"`
	Ret     Error             `json:"ret"`
}

func (st *AddParametersRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddParametersRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddParametersRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddParametersRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddParametersRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddParametersRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelParametersReq struct implement
type DelParametersReq struct {
	Strategy_id string            `json:"strategy_id"`
	Param_name  string            `json:"param_name"`
	Extends     map[string]string `json:"extends"`
}

func (st *DelParametersReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelParametersReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Param_name, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelParametersReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelParametersReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelParametersReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Param_name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *DelParametersReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DelParametersRsp struct implement
type DelParametersRsp struct {
	Extends map[string]string `json:"extends"`
	Ret     Error             `json:"ret"`
}

func (st *DelParametersRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DelParametersRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DelParametersRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DelParametersRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DelParametersRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DelParametersRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateParametersReq struct implement
type UpdateParametersReq struct {
	Strategy_id string            `json:"strategy_id"`
	Params      Parameter         `json:"params"`
	Extends     map[string]string `json:"extends"`
}

func (st *UpdateParametersReq) ResetDefault() {
	st.Params.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateParametersReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	err = st.Params.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateParametersReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateParametersReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateParametersReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = st.Params.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UpdateParametersReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateParametersRsp struct implement
type UpdateParametersRsp struct {
	Extends map[string]string `json:"extends"`
	Ret     Error             `json:"ret"`
}

func (st *UpdateParametersRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateParametersRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateParametersRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateParametersRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateParametersRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateParametersRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetParametersReq struct implement
type GetParametersReq struct {
	Strategy_id string            `json:"strategy_id"`
	Extends     map[string]string `json:"extends"`
}

func (st *GetParametersReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetParametersReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetParametersReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetParametersReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetParametersReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetParametersReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetParametersRsp struct implement
type GetParametersRsp struct {
	Strategy_id string            `json:"strategy_id"`
	Params      []Parameter       `json:"params"`
	Extends     map[string]string `json:"extends"`
	Ret         Error             `json:"ret"`
}

func (st *GetParametersRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetParametersRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Params = make([]Parameter, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Params[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 2, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	err = st.Ret.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetParametersRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetParametersRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetParametersRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Params)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Params {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extends {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetParametersRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyPnlReq struct implement
type GetStrategyPnlReq struct {
	Kind   string   `json:"kind"`
	Run_id string   `json:"run_id"`
	Ids    []string `json:"ids"`
}

func (st *GetStrategyPnlReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyPnlReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyPnlReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyPnlReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyPnlReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyPnlReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyPnlRsp struct implement
type GetStrategyPnlRsp struct {
	Pnls []PnL `json:"pnls"`
	Ret  Error `json:"ret"`
}

func (st *GetStrategyPnlRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyPnlRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Pnls = make([]PnL, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Pnls[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyPnlRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyPnlRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyPnlRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Pnls)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Pnls {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyPnlRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyPosReq struct implement
type GetStrategyPosReq struct {
	Kind       string   `json:"kind"`
	Run_id     string   `json:"run_id"`
	Strateg_id string   `json:"strateg_id"`
	Inst_ids   []string `json:"inst_ids"`
	Side       []string `json:"side"`
}

func (st *GetStrategyPosReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyPosReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strateg_id, 2, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Side = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Side[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyPosReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyPosReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyPosReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strateg_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Side)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Side {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyPosReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyPosRsp struct implement
type GetStrategyPosRsp struct {
	Poses []Position `json:"poses"`
	Ret   Error      `json:"ret"`
}

func (st *GetStrategyPosRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyPosRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Poses = make([]Position, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Poses[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyPosRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyPosRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyPosRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Poses)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Poses {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyPosRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyPosInstReq struct implement
type GetStrategyPosInstReq struct {
	Kind       string   `json:"kind"`
	Run_id     string   `json:"run_id"`
	Strateg_id string   `json:"strateg_id"`
	Side       []string `json:"side"`
}

func (st *GetStrategyPosInstReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyPosInstReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strateg_id, 2, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Side = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Side[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyPosInstReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyPosInstReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyPosInstReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strateg_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Side)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Side {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyPosInstReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyPosInstRsp struct implement
type GetStrategyPosInstRsp struct {
	Inst_ids []string `json:"inst_ids"`
	Ret      Error    `json:"ret"`
}

func (st *GetStrategyPosInstRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyPosInstRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Inst_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Inst_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyPosInstRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyPosInstRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyPosInstRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Inst_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Inst_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyPosInstRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyIndicatorReq struct implement
type GetStrategyIndicatorReq struct {
	Kind         string   `json:"kind"`
	Run_id       string   `json:"run_id"`
	Strategy_ids []string `json:"strategy_ids"`
}

func (st *GetStrategyIndicatorReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyIndicatorReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Kind, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Strategy_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Strategy_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyIndicatorReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyIndicatorReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyIndicatorReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Kind, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Strategy_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Strategy_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyIndicatorReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetStrategyIndicatorRsp struct implement
type GetStrategyIndicatorRsp struct {
	Indicators []Indicator `json:"indicators"`
}

func (st *GetStrategyIndicatorRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetStrategyIndicatorRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Indicators = make([]Indicator, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Indicators[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetStrategyIndicatorRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetStrategyIndicatorRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetStrategyIndicatorRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Indicators)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Indicators {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetStrategyIndicatorRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// EventConfirm struct implement
type EventConfirm struct {
	Rsp_time     int64  `json:"rsp_time"`
	Trigger_time int64  `json:"trigger_time"`
	Strategy_id  string `json:"strategy_id"`
	Timer_name   string `json:"timer_name"`
	Unique_id    int32  `json:"unique_id"`
}

func (st *EventConfirm) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *EventConfirm) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Rsp_time, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trigger_time, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Timer_name, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Unique_id, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *EventConfirm) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EventConfirm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *EventConfirm) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Rsp_time, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trigger_time, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Timer_name, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Unique_id, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *EventConfirm) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// MarketNotify struct implement
type MarketNotify struct {
	Timestamp int64  `json:"timestamp"`
	Tradedate int32  `json:"tradedate"`
	Market    string `json:"market"`
}

func (st *MarketNotify) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *MarketNotify) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Timestamp, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Tradedate, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *MarketNotify) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require MarketNotify, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *MarketNotify) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Timestamp, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Tradedate, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *MarketNotify) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BeforeMarketOpenNotify struct implement
type BeforeMarketOpenNotify struct {
	Timestamp  int64  `json:"timestamp"`
	Tradedate  int32  `json:"tradedate"`
	Market     string `json:"market"`
	Close_time int64  `json:"close_time"`
}

func (st *BeforeMarketOpenNotify) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BeforeMarketOpenNotify) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Timestamp, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Tradedate, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Close_time, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BeforeMarketOpenNotify) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BeforeMarketOpenNotify, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BeforeMarketOpenNotify) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Timestamp, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Tradedate, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Close_time, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BeforeMarketOpenNotify) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AfterMarketCloseNotify struct implement
type AfterMarketCloseNotify struct {
	Timestamp int64  `json:"timestamp"`
	Tradedate int32  `json:"tradedate"`
	Market    string `json:"market"`
}

func (st *AfterMarketCloseNotify) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AfterMarketCloseNotify) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Timestamp, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Tradedate, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AfterMarketCloseNotify) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AfterMarketCloseNotify, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AfterMarketCloseNotify) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Timestamp, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Tradedate, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AfterMarketCloseNotify) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AfterMarketCloseConfirm struct implement
type AfterMarketCloseConfirm struct {
	Market    string `json:"market"`
	Timestamp int64  `json:"timestamp"`
}

func (st *AfterMarketCloseConfirm) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AfterMarketCloseConfirm) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Market, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AfterMarketCloseConfirm) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AfterMarketCloseConfirm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AfterMarketCloseConfirm) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Market, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AfterMarketCloseConfirm) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyTimerNotify struct implement
type StrategyTimerNotify struct {
	Timestamp     int64  `json:"timestamp"`
	Timer_name    string `json:"timer_name"`
	Crond_str     string `json:"crond_str"`
	Is_trade_date bool   `json:"is_trade_date"`
}

func (st *StrategyTimerNotify) ResetDefault() {
	st.Is_trade_date = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyTimerNotify) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Timestamp, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Timer_name, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Crond_str, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Is_trade_date, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyTimerNotify) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyTimerNotify, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyTimerNotify) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Timestamp, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Timer_name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Crond_str, 2)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_trade_date, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyTimerNotify) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyReady struct implement
type StrategyReady struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *StrategyReady) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyReady) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyReady) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyReady, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyReady) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyReady) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AllStrategyReady struct implement
type AllStrategyReady struct {
	Ids []string `json:"ids"`
}

func (st *AllStrategyReady) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AllStrategyReady) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AllStrategyReady) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AllStrategyReady, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AllStrategyReady) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AllStrategyReady) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StrategyOver struct implement
type StrategyOver struct {
	Strategy_id string `json:"strategy_id"`
}

func (st *StrategyOver) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StrategyOver) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Strategy_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StrategyOver) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StrategyOver, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StrategyOver) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Strategy_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *StrategyOver) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BackTestResult struct implement
type BackTestResult struct {
	Run_id      string    `json:"run_id"`
	Strategy_id string    `json:"strategy_id"`
	Indicator   Indicator `json:"indicator"`
	Pnl         PnL       `json:"pnl"`
	Asset       []Asset   `json:"asset"`
	Day_count   int32     `json:"day_count"`
	Quote_count int64     `json:"quote_count"`
	Cost_time   int64     `json:"cost_time"`
}

func (st *BackTestResult) ResetDefault() {
	st.Indicator.ResetDefault()
	st.Pnl.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BackTestResult) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Run_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 1, false)
	if err != nil {
		return err
	}

	err = st.Indicator.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	err = st.Pnl.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Asset = make([]Asset, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Asset[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Day_count, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Quote_count, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Cost_time, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BackTestResult) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BackTestResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BackTestResult) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Run_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 1)
	if err != nil {
		return err
	}

	err = st.Indicator.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = st.Pnl.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Asset)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Asset {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Day_count, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Quote_count, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Cost_time, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BackTestResult) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTOverNotify struct implement
type BTOverNotify struct {
	Bt_results map[string]BackTestResult `json:"bt_results"`
}

func (st *BTOverNotify) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTOverNotify) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Bt_results = make(map[string]BackTestResult)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 BackTestResult

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = v0.ReadBlock(readBuf, 1, false)
			if err != nil {
				return err
			}

			st.Bt_results[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTOverNotify) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTOverNotify, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTOverNotify) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Bt_results)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Bt_results {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = v1.WriteBlock(buf, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BTOverNotify) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BTTerminate struct implement
type BTTerminate struct {
	Reason Error `json:"reason"`
}

func (st *BTTerminate) ResetDefault() {
	st.Reason.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BTTerminate) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Reason.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BTTerminate) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BTTerminate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BTTerminate) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Reason.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BTTerminate) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ReplayQuoteConfirm struct implement
type ReplayQuoteConfirm struct {
	Rsp_time     int64  `json:"rsp_time"`
	Trigger_time int64  `json:"trigger_time"`
	Strategy_id  string `json:"strategy_id"`
}

func (st *ReplayQuoteConfirm) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ReplayQuoteConfirm) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Rsp_time, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trigger_time, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ReplayQuoteConfirm) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ReplayQuoteConfirm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ReplayQuoteConfirm) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Rsp_time, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trigger_time, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ReplayQuoteConfirm) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

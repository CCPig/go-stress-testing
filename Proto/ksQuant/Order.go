// Package ksQuant comment
// This file was generated by ksf2go 1.3.20
// Generated from Order.ksf
package ksQuant

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type OrdStatus int32

const (
	OrdStatus_OST_NONE                 = 0
	OrdStatus_OST_NEW                  = 1
	OrdStatus_OST_PARTIALLY_FILLED     = 2
	OrdStatus_OST_FILLED               = 3
	OrdStatus_OST_DONE_FOR_DAY         = 4
	OrdStatus_OST_CANCELED             = 5
	OrdStatus_OST_REPLACED             = 6
	OrdStatus_OST_PENDING_CANCEL       = 7
	OrdStatus_OST_STOPPED              = 8
	OrdStatus_OST_REJECTED             = 9
	OrdStatus_OST_SUSPENDED            = 10
	OrdStatus_OST_PENDING_NEW          = 11
	OrdStatus_OST_CALCULATED           = 12
	OrdStatus_OST_EXPIRED              = 13
	OrdStatus_OST_ACCEPTED_FOR_BIDDING = 14
	OrdStatus_OST_PENDING_REPLACE      = 15
)

type ExecType int32

const (
	ExecType_EXEC_NONE             = 0
	ExecType_EXEC_NEW              = 1
	ExecType_EXEC_PARTIALLY_FILLED = 2
	ExecType_EXEC_FILLED           = 3
	ExecType_EXEC_DONE_FOR_DAY     = 4
	ExecType_EXEC_CANCELED         = 5
	ExecType_EXEC_REPLACE          = 6
	ExecType_EXEC_PENDING_CANCEL   = 7
	ExecType_EXEC_STOPPED          = 8
	ExecType_EXEC_REJECTED         = 9
	ExecType_EXEC_SUSPENDED        = 10
	ExecType_EXEC_PENDING_NEW      = 11
	ExecType_EXEC_CALCULATED       = 12
	ExecType_EXEC_EXPIRED          = 13
	ExecType_EXEC_RESTATED         = 14
	ExecType_EXEC_PENDING_REPLACE  = 15
	ExecType_EXEC_NEW_CANCEL       = 16
	ExecType_EXEC_REJECTED_NEW     = 17
	ExecType_EXEC_REJECTED_CANCEL  = 18
)

// EnterOrderReq struct implement
type EnterOrderReq struct {
	Account_id   string            `json:"account_id"`
	Run_id       string            `json:"run_id"`
	Strategy_id  string            `json:"strategy_id"`
	Inst_id      string            `json:"inst_id"`
	Side         string            `json:"side"`
	Tif          string            `json:"tif"`
	Price_type   string            `json:"price_type"`
	Qty          int64             `json:"qty"`
	Price        float64           `json:"price"`
	Trade_date   int32             `json:"trade_date"`
	Timestamp    int64             `json:"timestamp"`
	Remark       string            `json:"remark"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *EnterOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *EnterOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Tif, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Qty, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remark, 11, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 12, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *EnterOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EnterOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *EnterOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Tif, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Qty, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remark, 11)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *EnterOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// EnterOrderRsp struct implement
type EnterOrderRsp struct {
	User_id      string            `json:"user_id"`
	Channel      string            `json:"channel"`
	Task_id      string            `json:"task_id"`
	Order_id     string            `json:"order_id"`
	Entrust_id   string            `json:"entrust_id"`
	Ret          Error             `json:"ret"`
	Err_src      string            `json:"err_src"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *EnterOrderRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *EnterOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 4, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Err_src, 7, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *EnterOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require EnterOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *EnterOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 4)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Err_src, 7)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *EnterOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderReq struct implement
type CancelOrderReq struct {
	User_id      string            `json:"user_id"`
	Channel      string            `json:"channel"`
	Account_id   string            `json:"account_id"`
	Account_type string            `json:"account_type"`
	Task_id      string            `json:"task_id"`
	Order_id     string            `json:"order_id"`
	Entrust_id   string            `json:"entrust_id"`
	Inst_id      string            `json:"inst_id"`
	Market_id    string            `json:"market_id"`
	Exchange     string            `json:"exchange"`
	Service_id   string            `json:"service_id"`
	Service_node string            `json:"service_node"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *CancelOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Market_id, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Service_id, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Service_node, 12, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Market_id, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Service_id, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Service_node, 12)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderRsp struct implement
type CancelOrderRsp struct {
	User_id      string            `json:"user_id"`
	Channel      string            `json:"channel"`
	Task_id      string            `json:"task_id"`
	Order_id     string            `json:"order_id"`
	Entrust_id   string            `json:"entrust_id"`
	Ret          Error             `json:"ret"`
	Err_src      string            `json:"err_src"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *CancelOrderRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Entrust_id, 4, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Err_src, 6, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Entrust_id, 4)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Err_src, 6)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Order struct implement
type Order struct {
	Id              string            `json:"id"`
	Run_id          string            `json:"run_id"`
	Strategy_id     string            `json:"strategy_id"`
	Account_id      string            `json:"account_id"`
	Inst_id         string            `json:"inst_id"`
	Side            string            `json:"side"`
	Tif             string            `json:"tif"`
	Price_type      string            `json:"price_type"`
	Qty             int64             `json:"qty"`
	Price           float64           `json:"price"`
	Trade_date      int32             `json:"trade_date"`
	Timestamp       int64             `json:"timestamp"`
	Remark          string            `json:"remark"`
	Frozen_price    float64           `json:"frozen_price"`
	Order_status    string            `json:"order_status"`
	Cum_qty         int64             `json:"cum_qty"`
	Cancel_qty      int64             `json:"cancel_qty"`
	Avg_price       float64           `json:"avg_price"`
	Commission      float64           `json:"commission"`
	Market_value    float64           `json:"market_value"`
	Request_message string            `json:"request_message"`
	Counter_message string            `json:"counter_message"`
	System_message  string            `json:"system_message"`
	Ret             Error             `json:"ret"`
	Created         int64             `json:"created"`
	Modified        int64             `json:"modified"`
	Version         int32             `json:"version"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *Order) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Order) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Tif, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Qty, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remark, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_price, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_status, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Cum_qty, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Cancel_qty, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Avg_price, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Market_value, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Request_message, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_message, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.System_message, 22, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Created, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Modified, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Version, 26, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 27, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Order) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Order, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Order) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Tif, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Qty, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remark, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_price, 13)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_status, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Cum_qty, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Cancel_qty, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Avg_price, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Market_value, 19)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Request_message, 20)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_message, 21)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.System_message, 22)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 23)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Created, 24)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Modified, 25)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Version, 26)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 27)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Order) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Execution struct implement
type Execution struct {
	Id           string            `json:"id"`
	Order_id     string            `json:"order_id"`
	Run_id       string            `json:"run_id"`
	Strategy_id  string            `json:"strategy_id"`
	Account_id   string            `json:"account_id"`
	Inst_id      string            `json:"inst_id"`
	Side         string            `json:"side"`
	Last_qty     int64             `json:"last_qty"`
	Last_price   float64           `json:"last_price"`
	Commission   float64           `json:"commission"`
	Trade_date   int32             `json:"trade_date"`
	Timestamp    int64             `json:"timestamp"`
	Trade_type   string            `json:"trade_type"`
	Ret          Error             `json:"ret"`
	Created      int64             `json:"created"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *Execution) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Execution) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Run_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Strategy_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Inst_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Last_qty, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_price, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Timestamp, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_type, 12, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Created, 14, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 15, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Execution) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Execution, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Execution) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Run_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Strategy_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Inst_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Last_qty, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_price, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Timestamp, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_type, 12)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Created, 14)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Execution) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderUpdate struct implement
type OrderUpdate struct {
	Order     Order     `json:"order"`
	Execution Execution `json:"execution"`
}

func (st *OrderUpdate) ResetDefault() {
	st.Order.ResetDefault()
	st.Execution.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderUpdate) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Order.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Execution.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderUpdate) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderUpdate) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Order.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Execution.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *OrderUpdate) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryOrderCond struct implement
type QueryOrderCond struct {
	Begin_date  string   `json:"begin_date"`
	End_date    string   `json:"end_date"`
	User_id     []string `json:"user_id"`
	Channel     []string `json:"channel"`
	Account_id  []string `json:"account_id"`
	Strategy_id []string `json:"strategy_id"`
	Algo_id     []string `json:"algo_id"`
	Algo_type   []string `json:"algo_type"`
	Completed   []string `json:"completed"`
}

func (st *QueryOrderCond) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryOrderCond) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Begin_date, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_date, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.User_id = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.User_id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Channel = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Channel[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_id = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Account_id[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Strategy_id = make([]string, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = readBuf.ReadString(&st.Strategy_id[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Algo_id = make([]string, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = readBuf.ReadString(&st.Algo_id[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(7, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Algo_type = make([]string, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = readBuf.ReadString(&st.Algo_type[i5], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Completed = make([]string, length)
			for i6, e6 := int32(0), length; i6 < e6; i6++ {

				err = readBuf.ReadString(&st.Completed[i6], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryOrderCond) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryOrderCond, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryOrderCond) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Begin_date, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.User_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.User_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Channel)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Channel {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Strategy_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Strategy_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Algo_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Algo_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Algo_type)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Algo_type {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Completed)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Completed {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryOrderCond) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryOrderSort struct implement
type QueryOrderSort struct {
	Sort_field string `json:"sort_field"`
	Sort_type  string `json:"sort_type"`
}

func (st *QueryOrderSort) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryOrderSort) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Sort_field, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sort_type, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryOrderSort) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryOrderSort, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryOrderSort) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Sort_field, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sort_type, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryOrderSort) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryOrderReq struct implement
type QueryOrderReq struct {
	Client ClientInfo     `json:"client"`
	Token  string         `json:"token"`
	Cond   QueryOrderCond `json:"cond"`
	Sort   QueryOrderSort `json:"sort"`
	Page   Pagination     `json:"page"`
}

func (st *QueryOrderReq) ResetDefault() {
	st.Client.ResetDefault()
	st.Cond.ResetDefault()
	st.Sort.ResetDefault()
	st.Page.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Client.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Token, 1, false)
	if err != nil {
		return err
	}

	err = st.Cond.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	err = st.Sort.ReadBlock(readBuf, 3, false)
	if err != nil {
		return err
	}

	err = st.Page.ReadBlock(readBuf, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Client.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Token, 1)
	if err != nil {
		return err
	}

	err = st.Cond.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	err = st.Sort.WriteBlock(buf, 3)
	if err != nil {
		return err
	}

	err = st.Page.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryOrderRsp struct implement
type QueryOrderRsp struct {
	Records []Order    `json:"records"`
	Page    Pagination `json:"page"`
	Ret     Error      `json:"ret"`
}

func (st *QueryOrderRsp) ResetDefault() {
	st.Page.ResetDefault()
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Records = make([]Order, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Records[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Page.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Records)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Records {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Page.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryOrderCountReq struct implement
type QueryOrderCountReq struct {
	Client ClientInfo     `json:"client"`
	Token  string         `json:"token"`
	Cond   QueryOrderCond `json:"cond"`
}

func (st *QueryOrderCountReq) ResetDefault() {
	st.Client.ResetDefault()
	st.Cond.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryOrderCountReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Client.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Token, 1, false)
	if err != nil {
		return err
	}

	err = st.Cond.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryOrderCountReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryOrderCountReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryOrderCountReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Client.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Token, 1)
	if err != nil {
		return err
	}

	err = st.Cond.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryOrderCountReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryOrderCountRsp struct implement
type QueryOrderCountRsp struct {
	Total_count int64 `json:"total_count"`
	Ret         Error `json:"ret"`
}

func (st *QueryOrderCountRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryOrderCountRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Total_count, 0, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryOrderCountRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryOrderCountRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryOrderCountRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Total_count, 0)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryOrderCountRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetOrderReq struct implement
type GetOrderReq struct {
	Cond QueryOrderCond `json:"cond"`
	Sort QueryOrderSort `json:"sort"`
	Page Pagination     `json:"page"`
}

func (st *GetOrderReq) ResetDefault() {
	st.Cond.ResetDefault()
	st.Sort.ResetDefault()
	st.Page.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Cond.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Sort.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Page.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Cond.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Sort.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Page.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetOrderRsp struct implement
type GetOrderRsp struct {
	Records []Order    `json:"records"`
	Page    Pagination `json:"page"`
	Ret     Error      `json:"ret"`
}

func (st *GetOrderRsp) ResetDefault() {
	st.Page.ResetDefault()
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Records = make([]Order, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Records[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = st.Page.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = st.Ret.ReadBlock(readBuf, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Records)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Records {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = st.Page.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = st.Ret.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateOrderReq struct implement
type UpdateOrderReq struct {
	Record Order `json:"record"`
}

func (st *UpdateOrderReq) ResetDefault() {
	st.Record.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Record.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Record.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateOrderRsp struct implement
type UpdateOrderRsp struct {
	Ret Error `json:"ret"`
}

func (st *UpdateOrderRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Ret.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Ret.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RestoreOrderReq struct implement
type RestoreOrderReq struct {
	Report_failed bool `json:"report_failed"`
}

func (st *RestoreOrderReq) ResetDefault() {
	st.Report_failed = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RestoreOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadBool(&st.Report_failed, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RestoreOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RestoreOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RestoreOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteBool(st.Report_failed, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *RestoreOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RestoreOrderRsp struct implement
type RestoreOrderRsp struct {
	Ret Error `json:"ret"`
}

func (st *RestoreOrderRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RestoreOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Ret.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RestoreOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RestoreOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RestoreOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Ret.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *RestoreOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

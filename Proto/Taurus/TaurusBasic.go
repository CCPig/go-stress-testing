// Package Taurus comment
// This file was generated by ksf2go 1.3.21
// Generated from TaurusBasic.ksf
package Taurus

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// const as define in ksf file
const (
	ACCESS_AUTH_CTX        string = "access_auth"
	STRONG_CHECK           string = "s"
	WEAK_CHECK             string = "w"
	NONE_CHECK             string = "n"
	PRIVILEGE_TYPE_QUICK   string = "s"
	PRIVILEGE_TYPE_REFRESH string = "w"
)

// InterfaceInfo struct implement
type InterfaceInfo struct {
	Infos map[string]string `json:"infos"`
}

func (st *InterfaceInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InterfaceInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Infos = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Infos[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InterfaceInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InterfaceInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InterfaceInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Infos)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Infos {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *InterfaceInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ConnPrivelegeUpdate struct implement
type ConnPrivelegeUpdate struct {
	Quick   bool   `json:"quick"`
	Refresh bool   `json:"refresh"`
	Type    string `json:"type"`
}

func (st *ConnPrivelegeUpdate) ResetDefault() {
	st.Quick = true
	st.Refresh = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ConnPrivelegeUpdate) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadBool(&st.Quick, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Refresh, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Type, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ConnPrivelegeUpdate) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ConnPrivelegeUpdate, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ConnPrivelegeUpdate) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteBool(st.Quick, 0)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Refresh, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Type, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ConnPrivelegeUpdate) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// NotifyEvent struct implement
type NotifyEvent struct {
	Type    string            `json:"type"`
	Extends map[string]string `json:"extends"`
}

func (st *NotifyEvent) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *NotifyEvent) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Type, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *NotifyEvent) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NotifyEvent, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *NotifyEvent) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extends {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *NotifyEvent) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Result struct implement
type Result struct {
	Code int32  `json:"code"`
	Msg  string `json:"msg"`
}

func (st *Result) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Result) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Msg, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Result) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Result, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Result) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Code, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Msg, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Result) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SubAccStatusReq struct implement
type SubAccStatusReq struct {
	Ids []string `json:"ids"`
}

func (st *SubAccStatusReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SubAccStatusReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SubAccStatusReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SubAccStatusReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SubAccStatusReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SubAccStatusReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SubAccStatusRsp struct implement
type SubAccStatusRsp struct {
	Ret Result `json:"ret"`
}

func (st *SubAccStatusRsp) ResetDefault() {
	st.Ret.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SubAccStatusRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Ret.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SubAccStatusRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SubAccStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SubAccStatusRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Ret.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SubAccStatusRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccessAuthInfo struct implement
type AccessAuthInfo struct {
	User_id string `json:"user_id"`
	Acc_id  string `json:"acc_id"`
	Refresh string `json:"refresh"`
	Quick   string `json:"quick"`
	Extends string `json:"extends"`
}

func (st *AccessAuthInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccessAuthInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Acc_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Refresh, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Quick, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Extends, 10, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccessAuthInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccessAuthInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccessAuthInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Acc_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Refresh, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Quick, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Extends, 10)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccessAuthInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Pagination struct implement
type Pagination struct {
	Offset     int64  `json:"offset"`
	PageSize   int64  `json:"pageSize"`
	TotalCount int64  `json:"totalCount"`
	Prefix     string `json:"prefix"`
}

func (st *Pagination) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Pagination) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Offset, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.PageSize, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.TotalCount, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Prefix, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Pagination) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Pagination, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Pagination) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Offset, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.PageSize, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.TotalCount, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Prefix, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Pagination) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ClientInfo struct implement
type ClientInfo struct {
	User_id      string            `json:"user_id"`
	Channel      string            `json:"channel"`
	Guid         string            `json:"guid"`
	Xua          string            `json:"xua"`
	Imei         string            `json:"imei"`
	Macs         []string          `json:"macs"`
	Hosts        []string          `json:"hosts"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *ClientInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ClientInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Guid, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Xua, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Imei, 4, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Macs = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Macs[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Hosts = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Hosts[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 7, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 string

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v2, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k2] = v2
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ClientInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ClientInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ClientInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Guid, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Xua, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Imei, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Macs)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Macs {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Hosts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Hosts {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ClientInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserProfile struct implement
type UserProfile struct {
	Ch_name      string            `json:"ch_name"`
	Nick_name    string            `json:"nick_name"`
	Card_type    string            `json:"card_type"`
	Card_id      string            `json:"card_id"`
	Mail         string            `json:"mail"`
	Tel_no       string            `json:"tel_no"`
	Remark       string            `json:"remark"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *UserProfile) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserProfile) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Ch_name, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Nick_name, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Card_type, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Card_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Mail, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Tel_no, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Remark, 6, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 7, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserProfile) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserProfile, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserProfile) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Ch_name, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Nick_name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Card_type, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Card_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Mail, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Tel_no, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Remark, 6)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UserProfile) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserAccPerm struct implement
type UserAccPerm struct {
	Account_id    string            `json:"account_id"`
	Whether_login bool              `json:"whether_login"`
	Extra_params  map[string]string `json:"extra_params"`
}

func (st *UserAccPerm) ResetDefault() {
	st.Whether_login = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserAccPerm) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Whether_login, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 3, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserAccPerm) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserAccPerm, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserAccPerm) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Whether_login, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UserAccPerm) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// User struct implement
type User struct {
	Profile      UserProfile       `json:"profile"`
	Client       ClientInfo        `json:"client"`
	Id           string            `json:"id"`
	Passwd       string            `json:"passwd"`
	Status       string            `json:"status"`
	Type         string            `json:"type"`
	Mod_pass     bool              `json:"mod_pass"`
	Reg_date     string            `json:"reg_date"`
	Mod_date     string            `json:"mod_date"`
	Permission   string            `json:"permission"`
	Accounts     []UserAccPerm     `json:"accounts"`
	Extra_params map[string]string `json:"extra_params"`
	Roles        []UserRole        `json:"roles"`
}

func (st *User) ResetDefault() {
	st.Profile.ResetDefault()
	st.Client.ResetDefault()
	st.Mod_pass = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *User) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Profile.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = st.Client.ReadBlock(readBuf, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Id, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Passwd, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Type, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadBool(&st.Mod_pass, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Reg_date, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Mod_date, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Permission, 9, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Accounts = make([]UserAccPerm, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Accounts[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 11, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	have, ty, err = readBuf.SkipToNoCheck(12, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Roles = make([]UserRole, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = st.Roles[i2].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *User) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require User, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *User) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Profile.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = st.Client.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Passwd, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Type, 5)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Mod_pass, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Reg_date, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Mod_date, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Permission, 9)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Accounts)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Accounts {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Roles)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Roles {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *User) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLoginReq struct implement
type AccountLoginReq struct {
	Account_id   string            `json:"account_id"`
	Pwd          string            `json:"pwd"`
	Request_id   int32             `json:"request_id"`
	Client       ClientInfo        `json:"client"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *AccountLoginReq) ResetDefault() {
	st.Client.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLoginReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pwd, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	err = st.Client.ReadBlock(readBuf, 26, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLoginReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLoginReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLoginReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pwd, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = st.Client.WriteBlock(buf, 26)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountLoginReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLoginRsp struct implement
type AccountLoginRsp struct {
	Address      string            `json:"address"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *AccountLoginRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLoginRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Address, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLoginRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLoginRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLoginRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Address, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountLoginRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Account struct implement
type Account struct {
	Id              string            `json:"id"`
	Account_type    string            `json:"account_type"`
	Id_type         string            `json:"id_type"`
	Counter_type    string            `json:"counter_type"`
	Op_station      string            `json:"op_station"`
	Branch_no       string            `json:"branch_no"`
	Name            string            `json:"name"`
	Env             string            `json:"env"`
	Counter_node_id string            `json:"counter_node_id"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *Account) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Account) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_type, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Id_type, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Op_station, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Branch_no, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Env, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_node_id, 8, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 9, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Account) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Account, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Account) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_type, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Id_type, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Op_station, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Branch_no, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Env, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_node_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Account) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UserNameInfo struct implement
type UserNameInfo struct {
	User_id   string `json:"user_id"`
	User_name string `json:"user_name"`
}

func (st *UserNameInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UserNameInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.User_name, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UserNameInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UserNameInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UserNameInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.User_name, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UserNameInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SecureInfo struct implement
type SecureInfo struct {
	Market    string `json:"market"`
	Secure_id string `json:"secure_id"`
	Name      string `json:"name"`
}

func (st *SecureInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SecureInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Market, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Secure_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Name, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SecureInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SecureInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SecureInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Market, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Secure_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Name, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SecureInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLoginAuthInfo struct implement
type AccountLoginAuthInfo struct {
	Quick_token string       `json:"quick_token"`
	Con_list    []string     `json:"con_list"`
	Client_name string       `json:"client_name"`
	Client_id   string       `json:"client_id"`
	Fund_id     string       `json:"fund_id"`
	Secures     []SecureInfo `json:"secures"`
	Init_date   int32        `json:"init_date"`
	Cur_time    uint32       `json:"cur_time"`
	Branch_no   string       `json:"branch_no"`
	Node_id     string       `json:"node_id"`
}

func (st *AccountLoginAuthInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLoginAuthInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Quick_token, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Con_list = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Con_list[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Client_name, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Client_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Fund_id, 4, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Secures = make([]SecureInfo, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = st.Secures[i1].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Init_date, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadUint32(&st.Cur_time, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Branch_no, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Node_id, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLoginAuthInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLoginAuthInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLoginAuthInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Quick_token, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Con_list)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Con_list {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Client_name, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Client_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Fund_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Secures)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Secures {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Init_date, 6)
	if err != nil {
		return err
	}

	err = buf.WriteUint32(st.Cur_time, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Branch_no, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Node_id, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountLoginAuthInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// PassThroughFuncReq struct implement
type PassThroughFuncReq struct {
	Extra_params map[string]string `json:"extra_params"`
}

func (st *PassThroughFuncReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *PassThroughFuncReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *PassThroughFuncReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PassThroughFuncReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *PassThroughFuncReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *PassThroughFuncReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// PassThroughFuncRsp struct implement
type PassThroughFuncRsp struct {
	Rsp_type       int32               `json:"rsp_type"`
	Extra_params   map[string]string   `json:"extra_params"`
	V_extra_params []map[string]string `json:"v_extra_params"`
	Account_id     string              `json:"account_id"`
}

func (st *PassThroughFuncRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *PassThroughFuncRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Rsp_type, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.V_extra_params = make([]map[string]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				have, err = readBuf.SkipTo(codec.MAP, 0, false)
				if err != nil {
					return err
				}

				if have {
					err = readBuf.ReadInt32(&length, 0, true)
					if err != nil {
						return err
					}

					st.V_extra_params[i1] = make(map[string]string)
					for i2, e2 := int32(0), length; i2 < e2; i2++ {
						var k2 string
						var v2 string

						err = readBuf.ReadString(&k2, 0, false)
						if err != nil {
							return err
						}

						err = readBuf.ReadString(&v2, 1, false)
						if err != nil {
							return err
						}

						st.V_extra_params[i1][k2] = v2
					}
				}
			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Account_id, 3, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *PassThroughFuncRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PassThroughFuncRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *PassThroughFuncRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Rsp_type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.V_extra_params)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.V_extra_params {

		err = buf.WriteHead(codec.MAP, 0)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(int32(len(v)), 0)
		if err != nil {
			return err
		}

		for k4, v4 := range v {

			err = buf.WriteString(k4, 0)
			if err != nil {
				return err
			}

			err = buf.WriteString(v4, 1)
			if err != nil {
				return err
			}

		}
	}

	err = buf.WriteString(st.Account_id, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *PassThroughFuncRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

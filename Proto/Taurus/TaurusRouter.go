// Package Taurus comment
// This file was generated by ksf2go 1.3.21
// Generated from TaurusRouter.ksf
package Taurus

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// Node struct implement
type Node struct {
	Ip   string `json:"ip"`
	Port string `json:"port"`
}

func (st *Node) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Node) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Ip, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Port, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Node) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Node, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Node) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Ip, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Port, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *Node) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CounterInfo struct implement
type CounterInfo struct {
	Counter_id     string   `json:"counter_id"`
	Counter_type   string   `json:"counter_type"`
	Counter_name   string   `json:"counter_name"`
	Channel        []string `json:"channel"`
	Counter_env    string   `json:"counter_env"`
	Counter_status string   `json:"counter_status"`
	Creator        string   `json:"creator"`
	Create_time    string   `json:"create_time"`
	Update_time    string   `json:"update_time"`
	Servant_name   string   `json:"servant_name"`
}

func (st *CounterInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CounterInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_name, 2, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Channel = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Channel[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Counter_env, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_status, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Creator, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Create_time, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Update_time, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Servant_name, 9, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CounterInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CounterInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CounterInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_name, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Channel)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Channel {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Counter_env, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_status, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Creator, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Create_time, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Update_time, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Servant_name, 9)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CounterInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// NodeInfo struct implement
type NodeInfo struct {
	Node_id          string            `json:"node_id"`
	Node_name        string            `json:"node_name"`
	Counter_type     string            `json:"counter_type"`
	Channel          string            `json:"channel"`
	Node_status      string            `json:"node_status"`
	Node_addr        Node              `json:"node_addr"`
	Servant_name     string            `json:"servant_name"`
	Creator          string            `json:"creator"`
	Create_time      string            `json:"create_time"`
	Update_time      string            `json:"update_time"`
	Full_servant_key string            `json:"full_servant_key"`
	Full_servant     string            `json:"full_servant"`
	Account_list     map[string]int32  `json:"account_list"`
	Cur_online_num   int32             `json:"cur_online_num"`
	Capacity         int32             `json:"capacity"`
	Extra_params     map[string]string `json:"extra_params"`
}

func (st *NodeInfo) ResetDefault() {
	st.Node_addr.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *NodeInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Node_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Node_name, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Channel, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Node_status, 4, false)
	if err != nil {
		return err
	}

	err = st.Node_addr.ReadBlock(readBuf, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Servant_name, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Creator, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Create_time, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Update_time, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Full_servant_key, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Full_servant, 11, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 12, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Account_list = make(map[string]int32)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 int32

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Account_list[k0] = v0
		}
	}

	err = readBuf.ReadInt32(&st.Cur_online_num, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Capacity, 14, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *NodeInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require NodeInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *NodeInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Node_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Node_name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Channel, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Node_status, 4)
	if err != nil {
		return err
	}

	err = st.Node_addr.WriteBlock(buf, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Servant_name, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Creator, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Create_time, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Update_time, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Full_servant_key, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Full_servant, 11)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_list)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Account_list {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteInt32(v2, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Cur_online_num, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Capacity, 14)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *NodeInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountInfo struct implement
type AccountInfo struct {
	Account_no     string   `json:"account_no"`
	Account_id     string   `json:"account_id"`
	Counter_type   string   `json:"counter_type"`
	Counter_env    string   `json:"counter_env"`
	Counter_status string   `json:"counter_status"`
	Creator        string   `json:"creator"`
	Create_time    string   `json:"create_time"`
	Update_time    string   `json:"update_time"`
	Vec_node_id    []string `json:"vec_node_id"`
	Servant_name   string   `json:"servant_name"`
	Account_type   string   `json:"account_type"`
	Account_name   string   `json:"account_name"`
	Branch         string   `json:"branch"`
	Permission     string   `json:"permission"`
}

func (st *AccountInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_no, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_env, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_status, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Creator, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Create_time, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Update_time, 7, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_node_id = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Vec_node_id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Servant_name, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_type, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_name, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Branch, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Permission, 13, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_no, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_env, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_status, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Creator, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Create_time, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Update_time, 7)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_node_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_node_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Servant_name, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_type, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_name, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Branch, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Permission, 13)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountStatus struct implement
type AccountStatus struct {
	Account_id       string            `json:"account_id"`
	Counter_type     string            `json:"counter_type"`
	Login_status     string            `json:"login_status"`
	Node_id          string            `json:"node_id"`
	Node_addr        Node              `json:"node_addr"`
	Servant_name     string            `json:"servant_name"`
	Connect_status   string            `json:"connect_status"`
	Full_servant_key string            `json:"full_servant_key"`
	Status           int32             `json:"status"`
	Extra_params     map[string]string `json:"extra_params"`
}

func (st *AccountStatus) ResetDefault() {
	st.Node_addr.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountStatus) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Login_status, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Node_id, 3, false)
	if err != nil {
		return err
	}

	err = st.Node_addr.ReadBlock(readBuf, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Servant_name, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Connect_status, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Full_servant_key, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Status, 8, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountStatus) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountStatus) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Login_status, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Node_id, 3)
	if err != nil {
		return err
	}

	err = st.Node_addr.WriteBlock(buf, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Servant_name, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Connect_status, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Full_servant_key, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Status, 8)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountStatus) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Node2AccLogined struct implement
type Node2AccLogined struct {
	Counter_node   Node     `json:"counter_node"`
	Counter_type   string   `json:"counter_type"`
	Vec_account_id []string `json:"vec_account_id"`
}

func (st *Node2AccLogined) ResetDefault() {
	st.Counter_node.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Node2AccLogined) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Counter_node.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_account_id = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Vec_account_id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Node2AccLogined) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Node2AccLogined, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Node2AccLogined) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Counter_node.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_account_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_account_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Node2AccLogined) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAccountInfoReq struct implement
type GetAccountInfoReq struct {
	Account_ids   []string `json:"account_ids"`
	Account_nos   []string `json:"account_nos"`
	Counter_types []string `json:"counter_types"`
}

func (st *GetAccountInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAccountInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_nos = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Account_nos[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Counter_types = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Counter_types[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAccountInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAccountInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAccountInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_nos)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_nos {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Counter_types)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Counter_types {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetAccountInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAccountInfoRsp struct implement
type GetAccountInfoRsp struct {
	Vec_accountInfo []AccountInfo `json:"vec_accountInfo"`
}

func (st *GetAccountInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAccountInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Vec_accountInfo = make([]AccountInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.Vec_accountInfo[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAccountInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAccountInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAccountInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_accountInfo)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_accountInfo {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetAccountInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyAccountInfoReq struct implement
type ModifyAccountInfoReq struct {
	Infos []AccountInfo `json:"infos"`
}

func (st *ModifyAccountInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyAccountInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Infos = make([]AccountInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Infos[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyAccountInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyAccountInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyAccountInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Infos)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Infos {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ModifyAccountInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountPermission struct implement
type AccountPermission struct {
	Account_id string `json:"account_id"`
	Permission string `json:"permission"`
}

func (st *AccountPermission) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountPermission) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Permission, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountPermission) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountPermission, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountPermission) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Permission, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccountPermission) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyAccountInfoRsp struct implement
type ModifyAccountInfoRsp struct {
	Acc_perms []AccountPermission `json:"acc_perms"`
}

func (st *ModifyAccountInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyAccountInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Acc_perms = make([]AccountPermission, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Acc_perms[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyAccountInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyAccountInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyAccountInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Acc_perms)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Acc_perms {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ModifyAccountInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteAccountInfoReq struct implement
type DeleteAccountInfoReq struct {
	Account_ids []string `json:"account_ids"`
}

func (st *DeleteAccountInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteAccountInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteAccountInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteAccountInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteAccountInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *DeleteAccountInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteAccountInfoRsp struct implement
type DeleteAccountInfoRsp struct {
	Ttt string `json:"ttt"`
}

func (st *DeleteAccountInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteAccountInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Ttt, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteAccountInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteAccountInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteAccountInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Ttt, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteAccountInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddAccInfosReq struct implement
type AddAccInfosReq struct {
	Infos []AccountInfo `json:"infos"`
}

func (st *AddAccInfosReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddAccInfosReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Infos = make([]AccountInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Infos[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddAccInfosReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddAccInfosReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddAccInfosReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Infos)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Infos {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AddAccInfosReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddAccInfosRsp struct implement
type AddAccInfosRsp struct {
	Acc_perms []AccountPermission `json:"acc_perms"`
	Extends   map[string]string   `json:"extends"`
}

func (st *AddAccInfosRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddAccInfosRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Acc_perms = make([]AccountPermission, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Acc_perms[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddAccInfosRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddAccInfosRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddAccInfosRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Acc_perms)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Acc_perms {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extends {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AddAccInfosRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAccountStatusReq struct implement
type GetAccountStatusReq struct {
	Account_id   string `json:"account_id"`
	Counter_type string `json:"counter_type"`
}

func (st *GetAccountStatusReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAccountStatusReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAccountStatusReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAccountStatusReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAccountStatusReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetAccountStatusReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetAccountStatusRsp struct implement
type GetAccountStatusRsp struct {
	Vec_account_status []AccountStatus `json:"vec_account_status"`
}

func (st *GetAccountStatusRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetAccountStatusRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_account_status = make([]AccountStatus, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_account_status[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetAccountStatusRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetAccountStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetAccountStatusRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_account_status)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_account_status {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetAccountStatusRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyAccountStatusReq struct implement
type ModifyAccountStatusReq struct {
	Account_status AccountStatus `json:"account_status"`
}

func (st *ModifyAccountStatusReq) ResetDefault() {
	st.Account_status.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyAccountStatusReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Account_status.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyAccountStatusReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyAccountStatusReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyAccountStatusReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Account_status.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyAccountStatusReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyAccountStatusRsp struct implement
type ModifyAccountStatusRsp struct {
	Ttt string `json:"ttt"`
}

func (st *ModifyAccountStatusRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyAccountStatusRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Ttt, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyAccountStatusRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyAccountStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyAccountStatusRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Ttt, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyAccountStatusRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteAccountStatusReq struct implement
type DeleteAccountStatusReq struct {
	Account_id   string `json:"account_id"`
	Counter_type string `json:"counter_type"`
}

func (st *DeleteAccountStatusReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteAccountStatusReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteAccountStatusReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteAccountStatusReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteAccountStatusReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteAccountStatusReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteAccountStatusRsp struct implement
type DeleteAccountStatusRsp struct {
	Msg string `json:"msg"`
}

func (st *DeleteAccountStatusRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteAccountStatusRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteAccountStatusRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteAccountStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteAccountStatusRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteAccountStatusRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCounterInfoReq struct implement
type GetCounterInfoReq struct {
	Account_id   string `json:"account_id"`
	Counter_type string `json:"counter_type"`
}

func (st *GetCounterInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCounterInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_type, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCounterInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCounterInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCounterInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_type, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetCounterInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCounterInfoRsp struct implement
type GetCounterInfoRsp struct {
	Vec_counter_info []CounterInfo `json:"vec_counter_info"`
}

func (st *GetCounterInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCounterInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_counter_info = make([]CounterInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_counter_info[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCounterInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCounterInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCounterInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_counter_info)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_counter_info {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCounterInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyCounterInfoReq struct implement
type ModifyCounterInfoReq struct {
	Counter_info CounterInfo `json:"counter_info"`
}

func (st *ModifyCounterInfoReq) ResetDefault() {
	st.Counter_info.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyCounterInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Counter_info.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyCounterInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyCounterInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyCounterInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Counter_info.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyCounterInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyCounterInfoRsp struct implement
type ModifyCounterInfoRsp struct {
	Msg string `json:"msg"`
}

func (st *ModifyCounterInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyCounterInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyCounterInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyCounterInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyCounterInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyCounterInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteCounterInfoReq struct implement
type DeleteCounterInfoReq struct {
	Counter_type string `json:"counter_type"`
}

func (st *DeleteCounterInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteCounterInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_type, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteCounterInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteCounterInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteCounterInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_type, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteCounterInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteCounterInfoRsp struct implement
type DeleteCounterInfoRsp struct {
	Msg string `json:"msg"`
}

func (st *DeleteCounterInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteCounterInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteCounterInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteCounterInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteCounterInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteCounterInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetNodeInfoReq struct implement
type GetNodeInfoReq struct {
	Node_ids   []string `json:"node_ids"`
	Node_names []string `json:"node_names"`
}

func (st *GetNodeInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetNodeInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Node_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Node_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Node_names = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Node_names[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetNodeInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetNodeInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetNodeInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Node_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Node_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Node_names)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Node_names {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetNodeInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetNodeInfoRsp struct implement
type GetNodeInfoRsp struct {
	Vec_node_info []NodeInfo `json:"vec_node_info"`
}

func (st *GetNodeInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetNodeInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_node_info = make([]NodeInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_node_info[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetNodeInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetNodeInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetNodeInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_node_info)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_node_info {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetNodeInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyNodeInfoReq struct implement
type ModifyNodeInfoReq struct {
	Node_info NodeInfo `json:"node_info"`
}

func (st *ModifyNodeInfoReq) ResetDefault() {
	st.Node_info.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyNodeInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Node_info.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyNodeInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyNodeInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyNodeInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Node_info.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyNodeInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyNodeInfoRsp struct implement
type ModifyNodeInfoRsp struct {
	Msg string `json:"msg"`
}

func (st *ModifyNodeInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyNodeInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyNodeInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyNodeInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyNodeInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyNodeInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteNodeInfoReq struct implement
type DeleteNodeInfoReq struct {
	Node_id string `json:"node_id"`
}

func (st *DeleteNodeInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteNodeInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Node_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteNodeInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteNodeInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteNodeInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Node_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteNodeInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteNodeInfoRsp struct implement
type DeleteNodeInfoRsp struct {
	Msg string `json:"msg"`
}

func (st *DeleteNodeInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteNodeInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteNodeInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteNodeInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteNodeInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteNodeInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateAccountStatusReq struct implement
type UpdateAccountStatusReq struct {
	Counter_type string               `json:"counter_type"`
	Vec_status   []AccountLoginStatus `json:"vec_status"`
}

func (st *UpdateAccountStatusReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateAccountStatusReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_type, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_status = make([]AccountLoginStatus, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_status[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateAccountStatusReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateAccountStatusReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateAccountStatusReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_status)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_status {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UpdateAccountStatusReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UpdateAccountStatusRsp struct implement
type UpdateAccountStatusRsp struct {
	Msg string `json:"msg"`
}

func (st *UpdateAccountStatusRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UpdateAccountStatusRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Msg, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UpdateAccountStatusRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UpdateAccountStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UpdateAccountStatusRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Msg, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *UpdateAccountStatusRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCounterTypeRsp struct implement
type GetCounterTypeRsp struct {
	Vec_counter_type []string `json:"vec_counter_type"`
}

func (st *GetCounterTypeRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCounterTypeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_counter_type = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Vec_counter_type[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCounterTypeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCounterTypeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCounterTypeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_counter_type)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_counter_type {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCounterTypeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetNodeIdReq struct implement
type GetNodeIdReq struct {
	Counter_type string `json:"counter_type"`
}

func (st *GetNodeIdReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetNodeIdReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_type, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetNodeIdReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetNodeIdReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetNodeIdReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_type, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetNodeIdReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetNodeIdRsp struct implement
type GetNodeIdRsp struct {
	Counter_type string   `json:"counter_type"`
	Vec_node_id  []string `json:"vec_node_id"`
}

func (st *GetNodeIdRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetNodeIdRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_type, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_node_id = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Vec_node_id[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetNodeIdRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetNodeIdRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetNodeIdRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_node_id)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_node_id {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetNodeIdRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetNodeIdByAddrReq struct implement
type GetNodeIdByAddrReq struct {
	Addr Node `json:"addr"`
}

func (st *GetNodeIdByAddrReq) ResetDefault() {
	st.Addr.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetNodeIdByAddrReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Addr.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetNodeIdByAddrReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetNodeIdByAddrReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetNodeIdByAddrReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Addr.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetNodeIdByAddrReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetNodeIdByAddrRsp struct implement
type GetNodeIdByAddrRsp struct {
	NodeId string `json:"nodeId"`
}

func (st *GetNodeIdByAddrRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetNodeIdByAddrRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.NodeId, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetNodeIdByAddrRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetNodeIdByAddrRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetNodeIdByAddrRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.NodeId, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetNodeIdByAddrRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BindAccountNodeReq struct implement
type BindAccountNodeReq struct {
	Account_id string   `json:"account_id"`
	Node_ids   []string `json:"node_ids"`
}

func (st *BindAccountNodeReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BindAccountNodeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Node_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Node_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BindAccountNodeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BindAccountNodeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BindAccountNodeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Node_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Node_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BindAccountNodeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BindAccountNodeRsp struct implement
type BindAccountNodeRsp struct {
	Account_id string   `json:"account_id"`
	Node_ids   []string `json:"node_ids"`
}

func (st *BindAccountNodeRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BindAccountNodeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Node_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Node_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BindAccountNodeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BindAccountNodeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BindAccountNodeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Node_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Node_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *BindAccountNodeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UnbindAccountNodeReq struct implement
type UnbindAccountNodeReq struct {
	Account_id string   `json:"account_id"`
	Node_ids   []string `json:"node_ids"`
}

func (st *UnbindAccountNodeReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UnbindAccountNodeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Node_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Node_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UnbindAccountNodeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UnbindAccountNodeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UnbindAccountNodeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Node_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Node_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UnbindAccountNodeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UnbindAccountNodeRsp struct implement
type UnbindAccountNodeRsp struct {
	Account_id string   `json:"account_id"`
	Node_ids   []string `json:"node_ids"`
}

func (st *UnbindAccountNodeRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UnbindAccountNodeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(1, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Node_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Node_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UnbindAccountNodeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UnbindAccountNodeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UnbindAccountNodeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Node_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Node_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UnbindAccountNodeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RealCounter struct implement
type RealCounter struct {
	Counter_id   string `json:"counter_id"`
	Counter_name string `json:"counter_name"`
	Servant_name string `json:"servant_name"`
}

func (st *RealCounter) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RealCounter) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_name, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Servant_name, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RealCounter) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RealCounter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RealCounter) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Servant_name, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *RealCounter) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetCounterListRsp struct implement
type GetCounterListRsp struct {
	Vec_counter []RealCounter `json:"vec_counter"`
}

func (st *GetCounterListRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetCounterListRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_counter = make([]RealCounter, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_counter[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetCounterListRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetCounterListRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetCounterListRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_counter)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_counter {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *GetCounterListRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// GetServantNameRsp struct implement
type GetServantNameRsp struct {
	Servant_name string `json:"servant_name"`
}

func (st *GetServantNameRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *GetServantNameRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Servant_name, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *GetServantNameRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require GetServantNameRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *GetServantNameRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Servant_name, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *GetServantNameRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RiskRule struct implement
type RiskRule struct {
	Risk_id      string            `json:"risk_id"`
	Account_id   string            `json:"account_id"`
	Level        string            `json:"level"`
	Risk_type    int32             `json:"risk_type"`
	Compare_type string            `json:"compare_type"`
	Value        float64           `json:"value"`
	Status       string            `json:"status"`
	Risk_operate string            `json:"risk_operate"`
	Exchange     []string          `json:"exchange"`
	Product      []string          `json:"product"`
	Instrument   []string          `json:"instrument"`
	Desc         string            `json:"desc"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *RiskRule) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RiskRule) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Risk_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Level, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Risk_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Compare_type, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Value, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Risk_operate, 7, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(8, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Exchange = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Exchange[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(9, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Product = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Product[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(10, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Instrument = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Instrument[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Desc, 11, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 string
			var v3 string

			err = readBuf.ReadString(&k3, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v3, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k3] = v3
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RiskRule) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RiskRule, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RiskRule) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Risk_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Level, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Risk_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Compare_type, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Value, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Risk_operate, 7)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Exchange)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Exchange {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Product)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Product {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Instrument)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Instrument {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Desc, 11)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.Extra_params {

		err = buf.WriteString(k4, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v4, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *RiskRule) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RiskRuleRecord struct implement
type RiskRuleRecord struct {
	Rule            RiskRule          `json:"rule"`
	Current_operate string            `json:"current_operate"`
	Trigger_value   float64           `json:"trigger_value"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *RiskRuleRecord) ResetDefault() {
	st.Rule.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RiskRuleRecord) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Rule.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Current_operate, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trigger_value, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RiskRuleRecord) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RiskRuleRecord, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RiskRuleRecord) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Rule.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Current_operate, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trigger_value, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *RiskRuleRecord) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddRiskRuleReq struct implement
type AddRiskRuleReq struct {
	Risk_rule RiskRule `json:"risk_rule"`
}

func (st *AddRiskRuleReq) ResetDefault() {
	st.Risk_rule.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddRiskRuleReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Risk_rule.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddRiskRuleReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddRiskRuleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddRiskRuleReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Risk_rule.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddRiskRuleReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AddRiskRuleRsp struct implement
type AddRiskRuleRsp struct {
	Risk_rule RiskRule `json:"risk_rule"`
}

func (st *AddRiskRuleRsp) ResetDefault() {
	st.Risk_rule.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AddRiskRuleRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Risk_rule.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AddRiskRuleRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AddRiskRuleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AddRiskRuleRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Risk_rule.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AddRiskRuleRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyRiskRuleReq struct implement
type ModifyRiskRuleReq struct {
	Risk_rule RiskRule `json:"risk_rule"`
}

func (st *ModifyRiskRuleReq) ResetDefault() {
	st.Risk_rule.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyRiskRuleReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Risk_rule.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyRiskRuleReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyRiskRuleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyRiskRuleReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Risk_rule.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyRiskRuleReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModifyRiskRuleRsp struct implement
type ModifyRiskRuleRsp struct {
	Risk_rule RiskRule `json:"risk_rule"`
}

func (st *ModifyRiskRuleRsp) ResetDefault() {
	st.Risk_rule.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModifyRiskRuleRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Risk_rule.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModifyRiskRuleRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModifyRiskRuleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModifyRiskRuleRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Risk_rule.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModifyRiskRuleRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteRiskRuleReq struct implement
type DeleteRiskRuleReq struct {
	Risk_id      string            `json:"risk_id"`
	Account_id   string            `json:"account_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *DeleteRiskRuleReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteRiskRuleReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Risk_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteRiskRuleReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteRiskRuleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteRiskRuleReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Risk_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *DeleteRiskRuleReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryRiskRuleReq struct implement
type QueryRiskRuleReq struct {
	Risk_id       string            `json:"risk_id"`
	Account_id    string            `json:"account_id"`
	Vec_risk_type []int32           `json:"vec_risk_type"`
	Extra_params  map[string]string `json:"extra_params"`
}

func (st *QueryRiskRuleReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryRiskRuleReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Risk_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_risk_type = make([]int32, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadInt32(&st.Vec_risk_type[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryRiskRuleReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryRiskRuleReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryRiskRuleReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Risk_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_risk_type)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_risk_type {

		err = buf.WriteInt32(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryRiskRuleReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryRiskRuleRsp struct implement
type QueryRiskRuleRsp struct {
	Vec_risk_rule []RiskRule `json:"vec_risk_rule"`
}

func (st *QueryRiskRuleRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryRiskRuleRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_risk_rule = make([]RiskRule, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_risk_rule[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryRiskRuleRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryRiskRuleRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryRiskRuleRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_risk_rule)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_risk_rule {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QueryRiskRuleRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Package Taurus comment
// This file was generated by ksf2go 1.3.21
// Generated from TaurusSimCounter.ksf
package Taurus

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// SimAsset struct implement
type SimAsset struct {
	Account_id                  string            `json:"account_id"`
	Counter_id                  string            `json:"counter_id"`
	Fund_account                string            `json:"fund_account"`
	Currency_id                 string            `json:"currency_id"`
	Account_type                string            `json:"account_type"`
	Total_asset                 float64           `json:"total_asset"`
	Pre_balance                 float64           `json:"pre_balance"`
	Pre_margin                  float64           `json:"pre_margin"`
	Cur_margin                  float64           `json:"cur_margin"`
	Fetch_asset                 float64           `json:"fetch_asset"`
	Available_asset             float64           `json:"available_asset"`
	Frozen_asset                float64           `json:"frozen_asset"`
	Deposit                     float64           `json:"deposit"`
	Withdraw                    float64           `json:"withdraw"`
	Frozen_royalty              float64           `json:"frozen_royalty"`
	Frozen_commission           float64           `json:"frozen_commission"`
	Royalty                     float64           `json:"royalty"`
	Commission                  float64           `json:"commission"`
	Close_profit                float64           `json:"close_profit"`
	Position_profit             float64           `json:"position_profit"`
	Debt_amt                    float64           `json:"debt_amt"`
	Credit_quota                float64           `json:"credit_quota"`
	Available_credit_quota      float64           `json:"available_credit_quota"`
	Credit_sell_frozen_amt      float64           `json:"credit_sell_frozen_amt"`
	Credit_sell_buy_entrust_amt float64           `json:"credit_sell_buy_entrust_amt"`
	Credit_sell_buy_done_amt    float64           `json:"credit_sell_buy_done_amt"`
	Credit_sell_buy_payback_amt float64           `json:"credit_sell_buy_payback_amt"`
	Extra_params                map[string]string `json:"extra_params"`
}

func (st *SimAsset) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimAsset) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Fund_account, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_type, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_asset, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_balance, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_margin, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cur_margin, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Fetch_asset, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Available_asset, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_asset, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Deposit, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Withdraw, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_royalty, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_commission, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Royalty, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Position_profit, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Debt_amt, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Credit_quota, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Available_credit_quota, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Credit_sell_frozen_amt, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Credit_sell_buy_entrust_amt, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Credit_sell_buy_done_amt, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Credit_sell_buy_payback_amt, 27, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimAsset) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimAsset, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimAsset) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Fund_account, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_type, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_asset, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_balance, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_margin, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cur_margin, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Fetch_asset, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Available_asset, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_asset, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Deposit, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Withdraw, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_royalty, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_commission, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Royalty, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Position_profit, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Debt_amt, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Credit_quota, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Available_credit_quota, 23)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Credit_sell_frozen_amt, 24)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Credit_sell_buy_entrust_amt, 25)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Credit_sell_buy_done_amt, 26)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Credit_sell_buy_payback_amt, 27)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimAsset) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimPosition struct implement
type SimPosition struct {
	Account_id          string            `json:"account_id"`
	Counter_id          string            `json:"counter_id"`
	Exchange_id         string            `json:"exchange_id"`
	Instrument_id       string            `json:"instrument_id"`
	Instrument_name     string            `json:"instrument_name"`
	Pos_direction       string            `json:"pos_direction"`
	Long_frozen_volume  float64           `json:"long_frozen_volume"`
	Short_frozen_volume float64           `json:"short_frozen_volume"`
	Margin              float64           `json:"margin"`
	Yestoday_volume     float64           `json:"yestoday_volume"`
	Total_volume        float64           `json:"total_volume"`
	Today_volume        float64           `json:"today_volume"`
	Available_volume    float64           `json:"available_volume"`
	Subs_volume         float64           `json:"subs_volume"`
	Rede_volume         float64           `json:"rede_volume"`
	Total_buy_volume    float64           `json:"total_buy_volume"`
	Total_sell_volume   float64           `json:"total_sell_volume"`
	Today_buy_volume    float64           `json:"today_buy_volume"`
	Today_sell_volume   float64           `json:"today_sell_volume"`
	Cost_balance        float64           `json:"cost_balance"`
	Total_buy_amt       float64           `json:"total_buy_amt"`
	Total_sell_amt      float64           `json:"total_sell_amt"`
	Today_buy_amt       float64           `json:"today_buy_amt"`
	Today_sell_amt      float64           `json:"today_sell_amt"`
	Cost_price          float64           `json:"cost_price"`
	Dilute_cost_price   float64           `json:"dilute_cost_price"`
	Last_price          float64           `json:"last_price"`
	Avg_price           float64           `json:"avg_price"`
	Allotment_volume    float64           `json:"allotment_volume"`
	Allotment_amt       float64           `json:"allotment_amt"`
	Market_value        float64           `json:"market_value"`
	Float_profit        float64           `json:"float_profit"`
	Close_profit        float64           `json:"close_profit"`
	M2m_profit          float64           `json:"m2m_profit"`
	Brow_index          string            `json:"brow_index"`
	Extra_params        map[string]string `json:"extra_params"`
}

func (st *SimPosition) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimPosition) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_name, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pos_direction, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Long_frozen_volume, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Short_frozen_volume, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Margin, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Yestoday_volume, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_volume, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_volume, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Available_volume, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Subs_volume, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Rede_volume, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_buy_volume, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_sell_volume, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_buy_volume, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_sell_volume, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cost_balance, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_buy_amt, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_sell_amt, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_buy_amt, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_sell_amt, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cost_price, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Dilute_cost_price, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_price, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Avg_price, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Allotment_volume, 29, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Allotment_amt, 30, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Market_value, 31, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Float_profit, 32, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit, 33, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.M2m_profit, 34, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 40, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 50, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimPosition) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimPosition, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimPosition) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_name, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pos_direction, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Long_frozen_volume, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Short_frozen_volume, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Margin, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Yestoday_volume, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_volume, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_volume, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Available_volume, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Subs_volume, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Rede_volume, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_buy_volume, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_sell_volume, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_buy_volume, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_sell_volume, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cost_balance, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_buy_amt, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_sell_amt, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_buy_amt, 23)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_sell_amt, 24)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cost_price, 25)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Dilute_cost_price, 26)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_price, 27)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Avg_price, 28)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Allotment_volume, 29)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Allotment_amt, 30)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Market_value, 31)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Float_profit, 32)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit, 33)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.M2m_profit, 34)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 40)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 50)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimPosition) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimOrderInfo struct implement
type SimOrderInfo struct {
	Account_id           string            `json:"account_id"`
	Counter_id           string            `json:"counter_id"`
	Local_order_id       string            `json:"local_order_id"`
	Sys_order_id         string            `json:"sys_order_id"`
	Instrument_id        string            `json:"instrument_id"`
	Exchange             string            `json:"exchange"`
	Instrument_name      string            `json:"instrument_name"`
	Stock_holder_id      string            `json:"stock_holder_id"`
	Batch_id             string            `json:"batch_id"`
	Order_side           string            `json:"order_side"`
	Offset_flag          string            `json:"offset_flag"`
	Hedge_flag           string            `json:"hedge_flag"`
	Order_volume         float64           `json:"order_volume"`
	Order_price          float64           `json:"order_price"`
	Order_status         string            `json:"order_status"`
	Status_msg           string            `json:"status_msg"`
	Trade_volume         float64           `json:"trade_volume"`
	Cancel_volume        float64           `json:"cancel_volume"`
	Trade_avg_price      float64           `json:"trade_avg_price"`
	Trade_amt            float64           `json:"trade_amt"`
	Order_date           int32             `json:"order_date"`
	Order_time           int64             `json:"order_time"`
	Price_type           string            `json:"price_type"`
	Cancel_flag          string            `json:"cancel_flag"`
	Task_id              string            `json:"task_id"`
	Algo_id              string            `json:"algo_id"`
	Algo_type            string            `json:"algo_type"`
	Source_terminal_info string            `json:"source_terminal_info"`
	Brow_index           int64             `json:"brow_index"`
	Extra_params         map[string]string `json:"extra_params"`
}

func (st *SimOrderInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimOrderInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_name, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Batch_id, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Offset_flag, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge_flag, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_volume, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_price, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_status, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status_msg, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_volume, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cancel_volume, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_avg_price, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_amt, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Order_date, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Order_time, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_id, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_type, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Source_terminal_info, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 30, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimOrderInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimOrderInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimOrderInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_name, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Batch_id, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Offset_flag, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge_flag, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_volume, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_price, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_status, 15)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status_msg, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_volume, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cancel_volume, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_avg_price, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_amt, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Order_date, 21)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Order_time, 22)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 23)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 24)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_id, 26)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_type, 27)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Source_terminal_info, 28)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 30)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimOrderInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimTradeInfo struct implement
type SimTradeInfo struct {
	Account_id           string            `json:"account_id"`
	Counter_id           string            `json:"counter_id"`
	Local_order_id       string            `json:"local_order_id"`
	Sys_order_id         string            `json:"sys_order_id"`
	Trade_id             string            `json:"trade_id"`
	Instrument_id        string            `json:"instrument_id"`
	Exchange             string            `json:"exchange"`
	Instrument_name      string            `json:"instrument_name"`
	Stock_holder_id      string            `json:"stock_holder_id"`
	Batch_id             string            `json:"batch_id"`
	Order_side           string            `json:"order_side"`
	Offset_flag          string            `json:"offset_flag"`
	Hedge_flag           string            `json:"hedge_flag"`
	Order_volume         float64           `json:"order_volume"`
	Order_price          float64           `json:"order_price"`
	Trade_volume         float64           `json:"trade_volume"`
	Trade_price          float64           `json:"trade_price"`
	Trade_amt            float64           `json:"trade_amt"`
	Cancel_flag          string            `json:"cancel_flag"`
	Commission           float64           `json:"commission"`
	Order_date           int32             `json:"order_date"`
	Order_time           int64             `json:"order_time"`
	Trade_date           int32             `json:"trade_date"`
	Trade_time           int64             `json:"trade_time"`
	Task_id              string            `json:"task_id"`
	Algo_id              string            `json:"algo_id"`
	Algo_type            string            `json:"algo_type"`
	Source_terminal_info string            `json:"source_terminal_info"`
	Brow_index           int64             `json:"brow_index"`
	Extra_params         map[string]string `json:"extra_params"`
}

func (st *SimTradeInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimTradeInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_name, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Batch_id, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Offset_flag, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge_flag, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_volume, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_price, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_volume, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_price, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_amt, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Order_date, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Order_time, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trade_time, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_id, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_type, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Source_terminal_info, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Brow_index, 30, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimTradeInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimTradeInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimTradeInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_name, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Batch_id, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Offset_flag, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge_flag, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_volume, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_price, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_volume, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_price, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_amt, 18)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Order_date, 21)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Order_time, 22)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 23)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trade_time, 24)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_id, 26)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_type, 27)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Source_terminal_info, 28)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Brow_index, 30)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimTradeInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimParams struct implement
type SimParams struct {
	Is_async       int32             `json:"is_async"`
	Trade_coeff    float64           `json:"trade_coeff"`
	Split_mode     int32             `json:"split_mode"`
	Num            int32             `json:"num"`
	Rate           float64           `json:"rate"`
	Fix_num        int32             `json:"fix_num"`
	Is_rand_cancel int32             `json:"is_rand_cancel"`
	Push_interval  int32             `json:"push_interval"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *SimParams) ResetDefault() {
	st.Is_async = 0
	st.Trade_coeff = 1
	st.Split_mode = 0
	st.Num = 3
	st.Rate = 1
	st.Fix_num = 100
	st.Is_rand_cancel = 0
	st.Push_interval = 2000
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimParams) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Is_async, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_coeff, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Split_mode, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Num, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Rate, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Fix_num, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Is_rand_cancel, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Push_interval, 7, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimParams) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimParams, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimParams) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Is_async, 0)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_coeff, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Split_mode, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Num, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Rate, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Fix_num, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Is_rand_cancel, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Push_interval, 7)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimParams) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimStockHolderInfo struct implement
type SimStockHolderInfo struct {
	Account_id        string            `json:"account_id"`
	Exchange_id       string            `json:"exchange_id"`
	Stock_holder_id   string            `json:"stock_holder_id"`
	Stock_holder_name string            `json:"stock_holder_name"`
	Fund_account_id   string            `json:"fund_account_id"`
	Currency_id       string            `json:"currency_id"`
	Trade_access      string            `json:"trade_access"`
	Stock_holder_type string            `json:"stock_holder_type"`
	Equity_vol        int32             `json:"equity_vol"`
	Extra_params      map[string]string `json:"extra_params"`
}

func (st *SimStockHolderInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimStockHolderInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_name, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Fund_account_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_access, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_type, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Equity_vol, 8, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimStockHolderInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimStockHolderInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimStockHolderInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_name, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Fund_account_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_access, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_type, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Equity_vol, 8)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimStockHolderInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimTradeCommRsp struct implement
type SimTradeCommRsp struct {
	Request_id   int32             `json:"request_id"`
	Func         string            `json:"func"`
	Param        []int8            `json:"param"`
	Is_last      int32             `json:"is_last"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimTradeCommRsp) ResetDefault() {
	st.Is_last = 1
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimTradeCommRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Request_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Func, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Param = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadInt8(&st.Param[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Param, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Is_last, 4, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimTradeCommRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimTradeCommRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimTradeCommRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Request_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Func, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.SimpleList, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Param)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Param)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Is_last, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimTradeCommRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimInitReq struct implement
type SimInitReq struct {
	Params     SimParams `json:"params"`
	Request_id int32     `json:"request_id"`
}

func (st *SimInitReq) ResetDefault() {
	st.Params.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimInitReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Params.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimInitReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimInitReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimInitReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Params.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SimInitReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimLoginReq struct implement
type SimLoginReq struct {
	Counter_id   string            `json:"counter_id"`
	Account_id   string            `json:"account_id"`
	Pwd          string            `json:"pwd"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimLoginReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimLoginReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pwd, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 3, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimLoginReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimLoginReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimLoginReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pwd, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimLoginReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimLoginRsp struct implement
type SimLoginRsp struct {
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimLoginRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimLoginRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimLoginRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimLoginRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimLoginRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimLoginRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimLogoutReq struct implement
type SimLogoutReq struct {
	Counter_id   string            `json:"counter_id"`
	Account_id   string            `json:"account_id"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimLogoutReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimLogoutReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Counter_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimLogoutReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimLogoutReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimLogoutReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Counter_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimLogoutReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimLogoutRsp struct implement
type SimLogoutRsp struct {
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimLogoutRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimLogoutRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimLogoutRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimLogoutRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimLogoutRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimLogoutRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimOrderInsertReq struct implement
type SimOrderInsertReq struct {
	Params               SimParams         `json:"params"`
	Account_id           string            `json:"account_id"`
	Counter_id           string            `json:"counter_id"`
	Instrument_type      string            `json:"instrument_type"`
	Instrument_id        string            `json:"instrument_id"`
	Order_side           string            `json:"order_side"`
	Offset_flag          string            `json:"offset_flag"`
	Hedge_flag           string            `json:"hedge_flag"`
	Volume               float64           `json:"volume"`
	Price_type           string            `json:"price_type"`
	Price                float64           `json:"price"`
	Exchange_id          string            `json:"exchange_id"`
	Stock_holder_id      string            `json:"stock_holder_id"`
	Branch_id            string            `json:"branch_id"`
	Batch_id             string            `json:"batch_id"`
	Task_id              string            `json:"task_id"`
	Algo_id              string            `json:"algo_id"`
	Algo_type            string            `json:"algo_type"`
	Source_terminal_info string            `json:"source_terminal_info"`
	Request_id           int32             `json:"request_id"`
	Extra_params         map[string]string `json:"extra_params"`
}

func (st *SimOrderInsertReq) ResetDefault() {
	st.Params.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimOrderInsertReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.Params.ReadBlock(readBuf, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Offset_flag, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge_flag, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Volume, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Branch_id, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Batch_id, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_id, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Algo_type, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Source_terminal_info, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimOrderInsertReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimOrderInsertReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimOrderInsertReq) WriteTo(buf *codec.Buffer) (err error) {

	err = st.Params.WriteBlock(buf, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Offset_flag, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge_flag, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Volume, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 13)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Branch_id, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Batch_id, 15)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 21)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_id, 22)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Algo_type, 23)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Source_terminal_info, 24)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimOrderInsertReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimOrderInsertRsp struct implement
type SimOrderInsertRsp struct {
	Local_order_id string            `json:"local_order_id"`
	Sys_order_id   string            `json:"sys_order_id"`
	Task_id        string            `json:"task_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *SimOrderInsertRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimOrderInsertRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Local_order_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimOrderInsertRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimOrderInsertRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimOrderInsertRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Local_order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimOrderInsertRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimOrderCancelReq struct implement
type SimOrderCancelReq struct {
	Account_id           string            `json:"account_id"`
	Counter_id           string            `json:"counter_id"`
	Exchange_id          string            `json:"exchange_id"`
	Sys_order_id         string            `json:"sys_order_id"`
	Local_order_id       string            `json:"local_order_id"`
	Source_terminal_info string            `json:"source_terminal_info"`
	Stock_holder_id      string            `json:"stock_holder_id"`
	Instrument_id        string            `json:"instrument_id"`
	Task_id              string            `json:"task_id"`
	Request_id           int32             `json:"request_id"`
	Extra_params         map[string]string `json:"extra_params"`
}

func (st *SimOrderCancelReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimOrderCancelReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Source_terminal_info, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 10, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimOrderCancelReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimOrderCancelReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimOrderCancelReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Source_terminal_info, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 9)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 10)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimOrderCancelReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimOrderCancelRsp struct implement
type SimOrderCancelRsp struct {
	Cancel_order_id string            `json:"cancel_order_id"`
	Sys_order_id    string            `json:"sys_order_id"`
	Local_order_id  string            `json:"local_order_id"`
	Task_id         string            `json:"task_id"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *SimOrderCancelRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimOrderCancelRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Cancel_order_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 3, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimOrderCancelRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimOrderCancelRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimOrderCancelRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Cancel_order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimOrderCancelRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryAssetReq struct implement
type SimQryAssetReq struct {
	Account_id   string            `json:"account_id"`
	Counter_id   string            `json:"counter_id"`
	Currency_id  string            `json:"currency_id"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimQryAssetReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryAssetReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 4, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryAssetReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryAssetReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryAssetReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryAssetReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryAssetRsp struct implement
type SimQryAssetRsp struct {
	Vec_asset []SimAsset `json:"vec_asset"`
}

func (st *SimQryAssetRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryAssetRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_asset = make([]SimAsset, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_asset[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryAssetRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryAssetRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryAssetRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_asset)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_asset {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryAssetRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryPositionDetailReq struct implement
type SimQryPositionDetailReq struct {
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimQryPositionDetailReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryPositionDetailReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Request_id, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryPositionDetailReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryPositionDetailReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryPositionDetailReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Request_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryPositionDetailReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryPositionDetailRsp struct implement
type SimQryPositionDetailRsp struct {
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimQryPositionDetailRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryPositionDetailRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryPositionDetailRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryPositionDetailRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryPositionDetailRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryPositionDetailRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryPositionReq struct implement
type SimQryPositionReq struct {
	Account_id      string            `json:"account_id"`
	Counter_id      string            `json:"counter_id"`
	Exchange_id     string            `json:"exchange_id"`
	Instrument_id   string            `json:"instrument_id"`
	Pos_side        string            `json:"pos_side"`
	Stock_holder_id string            `json:"stock_holder_id"`
	Brow_index      string            `json:"brow_index"`
	Record_count    int32             `json:"record_count"`
	Request_id      int32             `json:"request_id"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *SimQryPositionReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryPositionReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pos_side, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 12, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryPositionReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryPositionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryPositionReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pos_side, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 12)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryPositionReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryPositionRsp struct implement
type SimQryPositionRsp struct {
	Vec_position []SimPosition `json:"vec_position"`
}

func (st *SimQryPositionRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryPositionRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_position = make([]SimPosition, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_position[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryPositionRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryPositionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryPositionRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_position)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_position {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryPositionRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryOrderReq struct implement
type SimQryOrderReq struct {
	Account_id      string            `json:"account_id"`
	Counter_id      string            `json:"counter_id"`
	Local_order_id  string            `json:"local_order_id"`
	Sys_order_id    string            `json:"sys_order_id"`
	Exchange_id     string            `json:"exchange_id"`
	Instrument_id   string            `json:"instrument_id"`
	Order_side      string            `json:"order_side"`
	Cancel_flag     string            `json:"cancel_flag"`
	Stock_holder_id string            `json:"stock_holder_id"`
	Start_time      string            `json:"start_time"`
	End_time        string            `json:"end_time"`
	Brow_index      string            `json:"brow_index"`
	Record_count    int32             `json:"record_count"`
	Request_id      int32             `json:"request_id"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *SimQryOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Start_time, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 14, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Start_time, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 14)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryOrderRsp struct implement
type SimQryOrderRsp struct {
	Vec_order []SimOrderInfo `json:"vec_order"`
}

func (st *SimQryOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_order = make([]SimOrderInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_order[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_order {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryTradeReq struct implement
type SimQryTradeReq struct {
	Account_id      string            `json:"account_id"`
	Counter_id      string            `json:"counter_id"`
	Local_order_id  string            `json:"local_order_id"`
	Sys_order_id    string            `json:"sys_order_id"`
	Trade_id        string            `json:"trade_id"`
	Batch_id        string            `json:"batch_id"`
	Exchange_id     string            `json:"exchange_id"`
	Instrument_id   string            `json:"instrument_id"`
	Order_side      string            `json:"order_side"`
	Cancel_flag     string            `json:"cancel_flag"`
	Stock_holder_id string            `json:"stock_holder_id"`
	Start_time      string            `json:"start_time"`
	End_time        string            `json:"end_time"`
	Brow_index      string            `json:"brow_index"`
	Record_count    int32             `json:"record_count"`
	Request_id      int32             `json:"request_id"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *SimQryTradeReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryTradeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Batch_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Start_time, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 16, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryTradeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryTradeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryTradeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Batch_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Start_time, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 13)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 16)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryTradeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQryTradeRsp struct implement
type SimQryTradeRsp struct {
	Vec_trade []SimTradeInfo `json:"vec_trade"`
}

func (st *SimQryTradeRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQryTradeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_trade = make([]SimTradeInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_trade[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQryTradeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQryTradeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQryTradeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_trade)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_trade {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQryTradeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQrySettleInfoReq struct implement
type SimQrySettleInfoReq struct {
	Account_id   string            `json:"account_id"`
	Counter_id   string            `json:"counter_id"`
	Trading_day  string            `json:"trading_day"`
	Currency_id  string            `json:"currency_id"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimQrySettleInfoReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQrySettleInfoReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trading_day, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQrySettleInfoReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQrySettleInfoReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQrySettleInfoReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trading_day, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimQrySettleInfoReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimQrySettleInfoRsp struct implement
type SimQrySettleInfoRsp struct {
	Account_id    string `json:"account_id"`
	Counter_id    string `json:"counter_id"`
	Trading_day   string `json:"trading_day"`
	Currency_id   string `json:"currency_id"`
	Settlement_id string `json:"settlement_id"`
	Sequence_id   string `json:"sequence_id"`
	Content       string `json:"content"`
}

func (st *SimQrySettleInfoRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimQrySettleInfoRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trading_day, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Settlement_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sequence_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Content, 7, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimQrySettleInfoRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimQrySettleInfoRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimQrySettleInfoRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trading_day, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Settlement_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sequence_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Content, 7)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SimQrySettleInfoRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimSettleComfireReq struct implement
type SimSettleComfireReq struct {
	Account_id   string            `json:"account_id"`
	Counter_id   string            `json:"counter_id"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimSettleComfireReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimSettleComfireReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 3, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimSettleComfireReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimSettleComfireReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimSettleComfireReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimSettleComfireReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimSettleComfireRsp struct implement
type SimSettleComfireRsp struct {
	Account_id    string `json:"account_id"`
	Counter_id    string `json:"counter_id"`
	Confirm_date  string `json:"confirm_date"`
	Confirm_time  string `json:"confirm_time"`
	Settlement_id string `json:"settlement_id"`
	Currency_id   string `json:"currency_id"`
}

func (st *SimSettleComfireRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimSettleComfireRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Confirm_date, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Confirm_time, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Settlement_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 6, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimSettleComfireRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimSettleComfireRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimSettleComfireRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Confirm_date, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Confirm_time, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Settlement_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 6)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *SimSettleComfireRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimAssetInoutReq struct implement
type SimAssetInoutReq struct {
	Type         string            `json:"type"`
	Account_id   string            `json:"account_id"`
	Fund_value   float64           `json:"fund_value"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimAssetInoutReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimAssetInoutReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Type, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Fund_value, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimAssetInoutReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimAssetInoutReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimAssetInoutReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Type, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Fund_value, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimAssetInoutReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SimAssetInoutRsp struct implement
type SimAssetInoutRsp struct {
	Extra_params map[string]string `json:"extra_params"`
}

func (st *SimAssetInoutRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SimAssetInoutRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SimAssetInoutRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SimAssetInoutRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SimAssetInoutRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SimAssetInoutRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

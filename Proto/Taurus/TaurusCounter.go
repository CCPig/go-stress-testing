// Package Taurus comment
// This file was generated by ksf2go 1.3.21
// Generated from TaurusCounter.ksf
package Taurus

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// Asset struct implement
type Asset struct {
	User_id           string            `json:"user_id"`
	Account_id        string            `json:"account_id"`
	Counter_id        string            `json:"counter_id"`
	Fund_account      string            `json:"fund_account"`
	Currency_id       string            `json:"currency_id"`
	Account_type      string            `json:"account_type"`
	Total_asset       float64           `json:"total_asset"`
	Pre_balance       float64           `json:"pre_balance"`
	Pre_margin        float64           `json:"pre_margin"`
	Cur_margin        float64           `json:"cur_margin"`
	Fetch_asset       float64           `json:"fetch_asset"`
	Available_asset   float64           `json:"available_asset"`
	Frozen_asset      float64           `json:"frozen_asset"`
	Deposit           float64           `json:"deposit"`
	Withdraw          float64           `json:"withdraw"`
	Frozen_royalty    float64           `json:"frozen_royalty"`
	Frozen_commission float64           `json:"frozen_commission"`
	Royalty           float64           `json:"royalty"`
	Commission        float64           `json:"commission"`
	Close_profit      float64           `json:"close_profit"`
	Position_profit   float64           `json:"position_profit"`
	Market_value      float64           `json:"market_value"`
	Trading_day       int32             `json:"trading_day"`
	Float_profit      float64           `json:"float_profit"`
	Extra_params      map[string]string `json:"extra_params"`
}

func (st *Asset) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Asset) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Fund_account, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_type, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_asset, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_balance, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pre_margin, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cur_margin, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Fetch_asset, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Available_asset, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_asset, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Deposit, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Withdraw, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_royalty, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_commission, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Royalty, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Position_profit, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Market_value, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trading_day, 29, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Float_profit, 30, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Asset) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Asset, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Asset) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Fund_account, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_type, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_asset, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_balance, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pre_margin, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cur_margin, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Fetch_asset, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Available_asset, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_asset, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Deposit, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Withdraw, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_royalty, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_commission, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Royalty, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Position_profit, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Market_value, 28)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trading_day, 29)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Float_profit, 30)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Asset) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// PositionDetail struct implement
type PositionDetail struct {
	User_id            string            `json:"user_id"`
	Account_id         string            `json:"account_id"`
	Counter_id         string            `json:"counter_id"`
	Direction          string            `json:"direction"`
	Exchange           string            `json:"exchange"`
	Instrument_id      string            `json:"instrument_id"`
	Open_date          int32             `json:"open_date"`
	Trade_id           string            `json:"trade_id"`
	Volume             float64           `json:"volume"`
	Open_price         float64           `json:"open_price"`
	Close_profit_date  float64           `json:"close_profit_date"`
	Close_profit_trade float64           `json:"close_profit_trade"`
	Pos_profit_date    float64           `json:"pos_profit_date"`
	Pos_profit_trade   float64           `json:"pos_profit_trade"`
	Margin             float64           `json:"margin"`
	Close_volume       float64           `json:"close_volume"`
	Close_amount       float64           `json:"close_amount"`
	Trading_day        int32             `json:"trading_day"`
	Hedge_flag         string            `json:"hedge_flag"`
	Commission         float64           `json:"commission"`
	Extra_params       map[string]string `json:"extra_params"`
}

func (st *PositionDetail) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *PositionDetail) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Direction, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Open_date, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_id, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Volume, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Open_price, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit_date, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit_trade, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pos_profit_date, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Pos_profit_trade, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Margin, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_volume, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_amount, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trading_day, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge_flag, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 19, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *PositionDetail) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PositionDetail, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *PositionDetail) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Direction, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Open_date, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_id, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Volume, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Open_price, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit_date, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit_trade, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pos_profit_date, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Pos_profit_trade, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Margin, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_volume, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_amount, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trading_day, 17)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge_flag, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 19)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *PositionDetail) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Position struct implement
type Position struct {
	User_id             string            `json:"user_id"`
	Account_id          string            `json:"account_id"`
	Counter_id          string            `json:"counter_id"`
	Exchange_id         string            `json:"exchange_id"`
	Instrument_id       string            `json:"instrument_id"`
	Instrument_name     string            `json:"instrument_name"`
	Pos_direction       string            `json:"pos_direction"`
	Long_frozen_volume  float64           `json:"long_frozen_volume"`
	Short_frozen_volume float64           `json:"short_frozen_volume"`
	Margin              float64           `json:"margin"`
	Yestoday_volume     float64           `json:"yestoday_volume"`
	Total_volume        float64           `json:"total_volume"`
	Today_volume        float64           `json:"today_volume"`
	Available_volume    float64           `json:"available_volume"`
	Subs_volume         float64           `json:"subs_volume"`
	Rede_volume         float64           `json:"rede_volume"`
	Total_buy_volume    float64           `json:"total_buy_volume"`
	Total_sell_volume   float64           `json:"total_sell_volume"`
	Today_buy_volume    float64           `json:"today_buy_volume"`
	Today_sell_volume   float64           `json:"today_sell_volume"`
	Cost_balance        float64           `json:"cost_balance"`
	Total_buy_amt       float64           `json:"total_buy_amt"`
	Total_sell_amt      float64           `json:"total_sell_amt"`
	Today_buy_amt       float64           `json:"today_buy_amt"`
	Today_sell_amt      float64           `json:"today_sell_amt"`
	Cost_price          float64           `json:"cost_price"`
	Dilute_cost_price   float64           `json:"dilute_cost_price"`
	Last_price          float64           `json:"last_price"`
	Avg_price           float64           `json:"avg_price"`
	Allotment_volume    float64           `json:"allotment_volume"`
	Allotment_amt       float64           `json:"allotment_amt"`
	Market_value        float64           `json:"market_value"`
	Float_profit        float64           `json:"float_profit"`
	Close_profit        float64           `json:"close_profit"`
	M2m_profit          float64           `json:"m2m_profit"`
	Trading_day         int32             `json:"trading_day"`
	Hedge               string            `json:"hedge"`
	Commission          float64           `json:"commission"`
	Open_cost           float64           `json:"open_cost"`
	Position_profit     float64           `json:"position_profit"`
	Yd_available        float64           `json:"yd_available"`
	Td_available        float64           `json:"td_available"`
	Virtual_margin      float64           `json:"virtual_margin"`
	Extra_params        map[string]string `json:"extra_params"`
}

func (st *Position) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *Position) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_name, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pos_direction, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Long_frozen_volume, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Short_frozen_volume, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Margin, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Yestoday_volume, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_volume, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_volume, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Available_volume, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Subs_volume, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Rede_volume, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_buy_volume, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_sell_volume, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_buy_volume, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_sell_volume, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cost_balance, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_buy_amt, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_sell_amt, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_buy_amt, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Today_sell_amt, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cost_price, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Dilute_cost_price, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Last_price, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Avg_price, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Allotment_volume, 29, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Allotment_amt, 30, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Market_value, 31, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Float_profit, 32, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Close_profit, 33, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.M2m_profit, 34, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trading_day, 35, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge, 36, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 37, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Open_cost, 38, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Position_profit, 39, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Yd_available, 40, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Td_available, 41, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Virtual_margin, 42, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 50, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *Position) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require Position, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *Position) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_name, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pos_direction, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Long_frozen_volume, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Short_frozen_volume, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Margin, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Yestoday_volume, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_volume, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_volume, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Available_volume, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Subs_volume, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Rede_volume, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_buy_volume, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_sell_volume, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_buy_volume, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_sell_volume, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cost_balance, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_buy_amt, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_sell_amt, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_buy_amt, 23)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Today_sell_amt, 24)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cost_price, 25)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Dilute_cost_price, 26)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Last_price, 27)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Avg_price, 28)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Allotment_volume, 29)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Allotment_amt, 30)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Market_value, 31)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Float_profit, 32)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Close_profit, 33)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.M2m_profit, 34)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trading_day, 35)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge, 36)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 37)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Open_cost, 38)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Position_profit, 39)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Yd_available, 40)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Td_available, 41)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Virtual_margin, 42)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 50)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *Position) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderInfo struct implement
type OrderInfo struct {
	User_id           string            `json:"user_id"`
	Account_id        string            `json:"account_id"`
	Counter_id        string            `json:"counter_id"`
	Local_order_id    string            `json:"local_order_id"`
	Sys_order_id      string            `json:"sys_order_id"`
	Instrument_id     string            `json:"instrument_id"`
	Exchange          string            `json:"exchange"`
	Order_side        string            `json:"order_side"`
	Order_volume      float64           `json:"order_volume"`
	Order_price       float64           `json:"order_price"`
	Order_status      string            `json:"order_status"`
	Status_msg        string            `json:"status_msg"`
	Trade_volume      float64           `json:"trade_volume"`
	Cancel_volume     float64           `json:"cancel_volume"`
	Trade_avg_price   float64           `json:"trade_avg_price"`
	Trade_amt         float64           `json:"trade_amt"`
	Order_date        int32             `json:"order_date"`
	Order_time        int64             `json:"order_time"`
	Price_type        string            `json:"price_type"`
	Cancel_flag       string            `json:"cancel_flag"`
	Task_id           string            `json:"task_id"`
	Frozen_commission float64           `json:"frozen_commission"`
	Frozen_margin     float64           `json:"frozen_margin"`
	Remain_vol        float64           `json:"remain_vol"`
	Order_ref         string            `json:"order_ref"`
	Cancel_time       int64             `json:"cancel_time"`
	Hedge             string            `json:"hedge"`
	Trading_day       int32             `json:"trading_day"`
	Time_cond_type    string            `json:"time_cond_type"`
	Command_id        string            `json:"command_id"`
	Extra_params      map[string]string `json:"extra_params"`
}

func (st *OrderInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_volume, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_price, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_status, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Status_msg, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_volume, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Cancel_volume, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_avg_price, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_amt, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Order_date, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Order_time, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_commission, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Frozen_margin, 28, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Remain_vol, 29, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_ref, 30, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Cancel_time, 31, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge, 32, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trading_day, 33, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Time_cond_type, 34, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Command_id, 35, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_volume, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_price, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_status, 15)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Status_msg, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_volume, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Cancel_volume, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_avg_price, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_amt, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Order_date, 21)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Order_time, 22)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 23)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 24)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_commission, 26)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Frozen_margin, 28)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Remain_vol, 29)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_ref, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Cancel_time, 31)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge, 32)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trading_day, 33)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Time_cond_type, 34)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Command_id, 35)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *OrderInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TradeInfo struct implement
type TradeInfo struct {
	User_id        string            `json:"user_id"`
	Account_id     string            `json:"account_id"`
	Counter_id     string            `json:"counter_id"`
	Local_order_id string            `json:"local_order_id"`
	Sys_order_id   string            `json:"sys_order_id"`
	Trade_id       string            `json:"trade_id"`
	Instrument_id  string            `json:"instrument_id"`
	Exchange       string            `json:"exchange"`
	Order_side     string            `json:"order_side"`
	Order_volume   float64           `json:"order_volume"`
	Order_price    float64           `json:"order_price"`
	Trade_volume   float64           `json:"trade_volume"`
	Trade_price    float64           `json:"trade_price"`
	Trade_amt      float64           `json:"trade_amt"`
	Cancel_flag    string            `json:"cancel_flag"`
	Commission     float64           `json:"commission"`
	Order_date     int32             `json:"order_date"`
	Order_time     int64             `json:"order_time"`
	Trade_date     int32             `json:"trade_date"`
	Trade_time     int64             `json:"trade_time"`
	Task_id        string            `json:"task_id"`
	Hedge          string            `json:"hedge"`
	Trading_day    int32             `json:"trading_day"`
	Command_id     string            `json:"command_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *TradeInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TradeInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_volume, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Order_price, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_volume, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_price, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Trade_amt, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Commission, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Order_date, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Order_time, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trade_date, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.Trade_time, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Hedge, 26, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Trading_day, 27, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Command_id, 28, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TradeInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TradeInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TradeInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_volume, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Order_price, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_volume, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_price, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Trade_amt, 18)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Commission, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Order_date, 21)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Order_time, 22)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trade_date, 23)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.Trade_time, 24)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Hedge, 26)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Trading_day, 27)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Command_id, 28)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TradeInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// StockHolderInfo struct implement
type StockHolderInfo struct {
	Account_id        string            `json:"account_id"`
	Exchange_id       string            `json:"exchange_id"`
	Stock_holder_id   string            `json:"stock_holder_id"`
	Stock_holder_name string            `json:"stock_holder_name"`
	Fund_account_id   string            `json:"fund_account_id"`
	Currency_id       string            `json:"currency_id"`
	Trade_access      string            `json:"trade_access"`
	Stock_holder_type string            `json:"stock_holder_type"`
	Equity_vol        int32             `json:"equity_vol"`
	Extra_params      map[string]string `json:"extra_params"`
}

func (st *StockHolderInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *StockHolderInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Exchange_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_name, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Fund_account_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_access, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Stock_holder_type, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Equity_vol, 8, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 20, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *StockHolderInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require StockHolderInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *StockHolderInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Exchange_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_name, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Fund_account_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_access, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Stock_holder_type, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Equity_vol, 8)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *StockHolderInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountRegisterReq struct implement
type AccountRegisterReq struct {
	Account_id   string            `json:"account_id"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *AccountRegisterReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountRegisterReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountRegisterReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountRegisterReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountRegisterReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountRegisterReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountRegisterRsp struct implement
type AccountRegisterRsp struct {
	Extra_params map[string]string `json:"extra_params"`
}

func (st *AccountRegisterRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountRegisterRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountRegisterRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountRegisterRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountRegisterRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountRegisterRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLogoutReq struct implement
type AccountLogoutReq struct {
	Account_id   string            `json:"account_id"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *AccountLogoutReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLogoutReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLogoutReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLogoutReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLogoutReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountLogoutReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLogoutRsp struct implement
type AccountLogoutRsp struct {
	Extra_params map[string]string `json:"extra_params"`
}

func (st *AccountLogoutRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLogoutRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLogoutRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLogoutRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLogoutRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountLogoutRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// RegistReq struct implement
type RegistReq struct {
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *RegistReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *RegistReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.Request_id, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *RegistReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require RegistReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *RegistReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.Request_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *RegistReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// UnRegistReq struct implement
type UnRegistReq struct {
	Ids          map[string]string `json:"ids"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *UnRegistReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *UnRegistReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.MAP, 0, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Ids = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Ids[k0] = v0
		}
	}

	err = readBuf.ReadInt32(&st.Request_id, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *UnRegistReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require UnRegistReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *UnRegistReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.MAP, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Ids)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Ids {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Request_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *UnRegistReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// InsertOrderReq struct implement
type InsertOrderReq struct {
	User_id         string            `json:"user_id"`
	Account_id      string            `json:"account_id"`
	Instrument_type string            `json:"instrument_type"`
	Local_order_id  string            `json:"local_order_id"`
	Instrument_id   string            `json:"instrument_id"`
	Order_side      string            `json:"order_side"`
	Volume          float64           `json:"volume"`
	Price_type      string            `json:"price_type"`
	Price           float64           `json:"price"`
	Task_id         string            `json:"task_id"`
	Order_way       string            `json:"order_way"`
	Request_id      int32             `json:"request_id"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *InsertOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InsertOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Volume, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_way, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InsertOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InsertOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InsertOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Volume, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 21)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_way, 22)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *InsertOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// InsertOrderRsp struct implement
type InsertOrderRsp struct {
	Local_order_id string            `json:"local_order_id"`
	Sys_order_id   string            `json:"sys_order_id"`
	Task_id        string            `json:"task_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *InsertOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InsertOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Local_order_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InsertOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InsertOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InsertOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Local_order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *InsertOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderReq struct implement
type CancelOrderReq struct {
	User_id        string            `json:"user_id"`
	Account_id     string            `json:"account_id"`
	Sys_order_id   string            `json:"sys_order_id"`
	Local_order_id string            `json:"local_order_id"`
	Instrument_id  string            `json:"instrument_id"`
	Task_id        string            `json:"task_id"`
	Order_way      string            `json:"order_way"`
	Request_id     int32             `json:"request_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *CancelOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_way, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_way, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderRsp struct implement
type CancelOrderRsp struct {
	Cancel_order_id string            `json:"cancel_order_id"`
	Sys_order_id    string            `json:"sys_order_id"`
	Local_order_id  string            `json:"local_order_id"`
	Task_id         string            `json:"task_id"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *CancelOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Cancel_order_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Task_id, 3, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Cancel_order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Task_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryAssetReq struct implement
type QryAssetReq struct {
	User_id      string            `json:"user_id"`
	Account_id   string            `json:"account_id"`
	Currency_id  string            `json:"currency_id"`
	Account_ids  []string          `json:"account_ids"`
	Start_time   string            `json:"start_time"`
	End_time     string            `json:"end_time"`
	Brow_index   string            `json:"brow_index"`
	Record_count int32             `json:"record_count"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QryAssetReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryAssetReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Currency_id, 3, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Start_time, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryAssetReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryAssetReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryAssetReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Currency_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Start_time, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryAssetReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryAssetRsp struct implement
type QryAssetRsp struct {
	Vec_asset    []Asset           `json:"vec_asset"`
	Brow_index   string            `json:"brow_index"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QryAssetRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryAssetRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_asset = make([]Asset, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_asset[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Brow_index, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryAssetRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryAssetRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryAssetRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_asset)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_asset {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Brow_index, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryAssetRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryOrderReq struct implement
type QryOrderReq struct {
	User_id        string            `json:"user_id"`
	Account_id     string            `json:"account_id"`
	Local_order_id string            `json:"local_order_id"`
	Sys_order_id   string            `json:"sys_order_id"`
	Instrument_id  string            `json:"instrument_id"`
	Order_side     string            `json:"order_side"`
	Cancel_flag    string            `json:"cancel_flag"`
	Start_time     string            `json:"start_time"`
	End_time       string            `json:"end_time"`
	Brow_index     string            `json:"brow_index"`
	Record_count   int32             `json:"record_count"`
	Account_ids    []string          `json:"account_ids"`
	Task_ids       []string          `json:"task_ids"`
	C_order_ids    []string          `json:"c_order_ids"`
	Instrument_ids []string          `json:"instrument_ids"`
	S_order_ids    []string          `json:"s_order_ids"`
	Request_id     int32             `json:"request_id"`
	Command_id     string            `json:"command_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *QryOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Start_time, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 13, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(15, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(16, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Task_ids = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Task_ids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(18, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.C_order_ids = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.C_order_ids[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(19, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Instrument_ids = make([]string, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = readBuf.ReadString(&st.Instrument_ids[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(20, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.S_order_ids = make([]string, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = readBuf.ReadString(&st.S_order_ids[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Command_id, 26, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i5, e5 := int32(0), length; i5 < e5; i5++ {
			var k5 string
			var v5 string

			err = readBuf.ReadString(&k5, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v5, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k5] = v5
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Start_time, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 11)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 13)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Task_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Task_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 18)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.C_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.C_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 19)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Instrument_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Instrument_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.S_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.S_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Command_id, 26)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.Extra_params {

		err = buf.WriteString(k6, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v6, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryOrderRsp struct implement
type QryOrderRsp struct {
	Vec_order    []OrderInfo       `json:"vec_order"`
	Brow_index   string            `json:"brow_index"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QryOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_order = make([]OrderInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_order[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Brow_index, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_order {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Brow_index, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryTradeReq struct implement
type QryTradeReq struct {
	User_id        string            `json:"user_id"`
	Account_id     string            `json:"account_id"`
	Local_order_id string            `json:"local_order_id"`
	Sys_order_id   string            `json:"sys_order_id"`
	Trade_id       string            `json:"trade_id"`
	Instrument_id  string            `json:"instrument_id"`
	Order_side     string            `json:"order_side"`
	Cancel_flag    string            `json:"cancel_flag"`
	Start_time     string            `json:"start_time"`
	End_time       string            `json:"end_time"`
	Brow_index     string            `json:"brow_index"`
	Record_count   int32             `json:"record_count"`
	Account_ids    []string          `json:"account_ids"`
	Task_ids       []string          `json:"task_ids"`
	C_order_ids    []string          `json:"c_order_ids"`
	Instrument_ids []string          `json:"instrument_ids"`
	Trade_ids      []string          `json:"trade_ids"`
	S_order_ids    []string          `json:"s_order_ids"`
	Request_id     int32             `json:"request_id"`
	Command_id     string            `json:"command_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *QryTradeReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryTradeReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sys_order_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_id, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_side, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_flag, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Start_time, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 15, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(16, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(17, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Task_ids = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Task_ids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(18, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.C_order_ids = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.C_order_ids[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(19, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Instrument_ids = make([]string, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = readBuf.ReadString(&st.Instrument_ids[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(20, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Trade_ids = make([]string, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = readBuf.ReadString(&st.Trade_ids[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(21, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.S_order_ids = make([]string, length)
			for i5, e5 := int32(0), length; i5 < e5; i5++ {

				err = readBuf.ReadString(&st.S_order_ids[i5], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Command_id, 26, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i6, e6 := int32(0), length; i6 < e6; i6++ {
			var k6 string
			var v6 string

			err = readBuf.ReadString(&k6, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v6, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k6] = v6
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryTradeReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryTradeReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryTradeReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sys_order_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_side, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_flag, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Start_time, 12)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 13)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 15)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 16)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 17)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Task_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Task_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 18)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.C_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.C_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 19)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Instrument_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Instrument_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 20)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Trade_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Trade_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 21)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.S_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.S_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Command_id, 26)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k7, v7 := range st.Extra_params {

		err = buf.WriteString(k7, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v7, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryTradeReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryTradeRsp struct implement
type QryTradeRsp struct {
	Vec_trade    []TradeInfo       `json:"vec_trade"`
	Brow_index   string            `json:"brow_index"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QryTradeRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryTradeRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_trade = make([]TradeInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_trade[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Brow_index, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryTradeRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryTradeRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryTradeRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_trade)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_trade {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Brow_index, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryTradeRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryPositionReq struct implement
type QryPositionReq struct {
	User_id        string            `json:"user_id"`
	Account_id     string            `json:"account_id"`
	Instrument_id  string            `json:"instrument_id"`
	Pos_side       string            `json:"pos_side"`
	Brow_index     string            `json:"brow_index"`
	Record_count   int32             `json:"record_count"`
	Account_ids    []string          `json:"account_ids"`
	Instrument_ids []string          `json:"instrument_ids"`
	Start_time     string            `json:"start_time"`
	End_time       string            `json:"end_time"`
	Request_id     int32             `json:"request_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *QryPositionReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryPositionReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pos_side, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 11, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(12, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(13, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Instrument_ids = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Instrument_ids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Start_time, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {
			var k2 string
			var v2 string

			err = readBuf.ReadString(&k2, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v2, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k2] = v2
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryPositionReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryPositionReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryPositionReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pos_side, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 11)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 12)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 13)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Instrument_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Instrument_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Start_time, 14)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 15)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k3, v3 := range st.Extra_params {

		err = buf.WriteString(k3, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v3, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryPositionReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryPositionRsp struct implement
type QryPositionRsp struct {
	Vec_position []Position        `json:"vec_position"`
	Brow_index   string            `json:"brow_index"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QryPositionRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryPositionRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_position = make([]Position, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_position[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Brow_index, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryPositionRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryPositionRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryPositionRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_position)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_position {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Brow_index, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryPositionRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryStockHolderReq struct implement
type QryStockHolderReq struct {
	Account_id   string            `json:"account_id"`
	Request_id   int32             `json:"request_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QryStockHolderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryStockHolderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Request_id, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryStockHolderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryStockHolderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryStockHolderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Request_id, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryStockHolderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryStockHolderRsp struct implement
type QryStockHolderRsp struct {
	Stock_holders []StockHolderInfo `json:"stock_holders"`
	Extra_params  map[string]string `json:"extra_params"`
}

func (st *QryStockHolderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryStockHolderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Stock_holders = make([]StockHolderInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Stock_holders[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryStockHolderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryStockHolderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryStockHolderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Stock_holders)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Stock_holders {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryStockHolderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountLoginStatus struct implement
type AccountLoginStatus struct {
	Account_id   string            `json:"account_id"`
	Status       int32             `json:"status"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *AccountLoginStatus) ResetDefault() {
	st.Status = -1
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountLoginStatus) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Status, 1, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountLoginStatus) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountLoginStatus, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountLoginStatus) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Status, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountLoginStatus) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ProxyStatusRsp struct implement
type ProxyStatusRsp struct {
	Vec_status   []AccountLoginStatus `json:"vec_status"`
	Extra_params map[string]string    `json:"extra_params"`
}

func (st *ProxyStatusRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ProxyStatusRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_status = make([]AccountLoginStatus, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_status[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {
			var k1 string
			var v1 string

			err = readBuf.ReadString(&k1, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v1, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k1] = v1
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ProxyStatusRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ProxyStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ProxyStatusRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_status)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_status {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k2, v2 := range st.Extra_params {

		err = buf.WriteString(k2, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v2, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *ProxyStatusRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryOrderFromOrderIdReq struct implement
type QryOrderFromOrderIdReq struct {
	Unique_id      string            `json:"unique_id"`
	Account_id     string            `json:"account_id"`
	Local_order_id string            `json:"local_order_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *QryOrderFromOrderIdReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryOrderFromOrderIdReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Unique_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryOrderFromOrderIdReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryOrderFromOrderIdReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryOrderFromOrderIdReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Unique_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryOrderFromOrderIdReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryOrderFromOrderIdRsp struct implement
type QryOrderFromOrderIdRsp struct {
	Unique_id  string      `json:"unique_id"`
	Account_id string      `json:"account_id"`
	Vec_order  []OrderInfo `json:"vec_order"`
}

func (st *QryOrderFromOrderIdRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryOrderFromOrderIdRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Unique_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_order = make([]OrderInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_order[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryOrderFromOrderIdRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryOrderFromOrderIdRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryOrderFromOrderIdRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Unique_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_order {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryOrderFromOrderIdRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryTradeFromTradeIdReq struct implement
type QryTradeFromTradeIdReq struct {
	Unique_id    string            `json:"unique_id"`
	Account_id   string            `json:"account_id"`
	Trade_id     string            `json:"trade_id"`
	Extra_params map[string]string `json:"extra_params"`
}

func (st *QryTradeFromTradeIdReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryTradeFromTradeIdReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Unique_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trade_id, 2, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryTradeFromTradeIdReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryTradeFromTradeIdReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryTradeFromTradeIdReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Unique_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trade_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryTradeFromTradeIdReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryTradeFromTradeIdRsp struct implement
type QryTradeFromTradeIdRsp struct {
	Unique_id  string      `json:"unique_id"`
	Account_id string      `json:"account_id"`
	Vec_trade  []TradeInfo `json:"vec_trade"`
}

func (st *QryTradeFromTradeIdRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryTradeFromTradeIdRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Unique_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_trade = make([]TradeInfo, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_trade[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryTradeFromTradeIdRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryTradeFromTradeIdRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryTradeFromTradeIdRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Unique_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_trade)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_trade {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryTradeFromTradeIdRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// SpiCommRsp struct implement
type SpiCommRsp struct {
	Request_id int64             `json:"request_id"`
	Func       string            `json:"func"`
	Param1     []int8            `json:"param1"`
	Param2     []int8            `json:"param2"`
	Param3     []int8            `json:"param3"`
	Is_last    bool              `json:"is_last"`
	Extends    map[string]string `json:"extends"`
}

func (st *SpiCommRsp) ResetDefault() {
	st.Is_last = true
}

// ReadFrom reads  from readBuf and put into struct.
func (st *SpiCommRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt64(&st.Request_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Func, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Param1 = make([]int8, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadInt8(&st.Param1[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Param1, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Param2 = make([]int8, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadInt8(&st.Param2[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Param2, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Param3 = make([]int8, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadInt8(&st.Param3[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {

			_, err = readBuf.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			err = readBuf.ReadSliceInt8(&st.Param3, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadBool(&st.Is_last, 5, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 10, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extends = make(map[string]string)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 string
			var v3 string

			err = readBuf.ReadString(&k3, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v3, 1, false)
			if err != nil {
				return err
			}

			st.Extends[k3] = v3
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *SpiCommRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require SpiCommRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *SpiCommRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt64(st.Request_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Func, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.SimpleList, 2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Param1)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Param1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.SimpleList, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Param2)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Param2)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.SimpleList, 4)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.BYTE, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Param3)), 0)
	if err != nil {
		return err
	}

	err = buf.WriteSliceInt8(st.Param3)
	if err != nil {
		return err
	}

	err = buf.WriteBool(st.Is_last, 5)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 10)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extends)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.Extends {

		err = buf.WriteString(k4, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v4, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *SpiCommRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// HTSFuncCallbackRsp struct implement
type HTSFuncCallbackRsp struct {
	RspType              int32   `json:"rspType"`
	SysType              int32   `json:"sysType"`
	TradeType            int32   `json:"tradeType"`
	DevelopLocalId       string  `json:"developLocalId"`
	CancelDevelopLocalId string  `json:"cancelDevelopLocalId"`
	AccountId            string  `json:"accountId"`
	OrderId              string  `json:"orderId"`
	OrderTime            string  `json:"orderTime"`
	FrozenAsset          float64 `json:"frozenAsset"`
	RetCode              int32   `json:"retCode"`
	OrderPrice           float64 `json:"orderPrice"`
	RetNote              string  `json:"retNote"`
	ParseCost            int64   `json:"parseCost"`
}

func (st *HTSFuncCallbackRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *HTSFuncCallbackRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadInt32(&st.RspType, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.SysType, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.TradeType, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.DevelopLocalId, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.CancelDevelopLocalId, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.AccountId, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.OrderId, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.OrderTime, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.FrozenAsset, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.RetCode, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.OrderPrice, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.RetNote, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.ParseCost, 12, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *HTSFuncCallbackRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require HTSFuncCallbackRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *HTSFuncCallbackRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteInt32(st.RspType, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.SysType, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.TradeType, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.DevelopLocalId, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.CancelDevelopLocalId, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.AccountId, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.OrderId, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.OrderTime, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.FrozenAsset, 8)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.RetCode, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.OrderPrice, 10)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.RetNote, 11)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.ParseCost, 12)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *HTSFuncCallbackRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Package Taurus comment
// This file was generated by ksf2go 1.3.21
// Generated from TaurusClient.ksf
package Taurus

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// InsertOrder struct implement
type InsertOrder struct {
	Local_id      string            `json:"local_id"`
	Account_id    string            `json:"account_id"`
	Instrument_id string            `json:"instrument_id"`
	Side          string            `json:"side"`
	Volume        float64           `json:"volume"`
	Price_type    string            `json:"price_type"`
	Price         float64           `json:"price"`
	Extra_params  map[string]string `json:"extra_params"`
}

func (st *InsertOrder) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InsertOrder) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Local_id, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_id, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Side, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Volume, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Price_type, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Price, 6, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 7, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InsertOrder) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InsertOrder, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InsertOrder) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Local_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Side, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Volume, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Price_type, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Price, 6)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 7)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *InsertOrder) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// InsertOrderRst struct implement
type InsertOrderRst struct {
	Local_id string `json:"local_id"`
	Order_id string `json:"order_id"`
}

func (st *InsertOrderRst) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InsertOrderRst) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Local_id, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InsertOrderRst) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InsertOrderRst, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InsertOrderRst) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Local_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *InsertOrderRst) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// InsertOrderBatReq struct implement
type InsertOrderBatReq struct {
	InsertOrderBat []InsertOrder `json:"InsertOrderBat"`
}

func (st *InsertOrderBatReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InsertOrderBatReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.InsertOrderBat = make([]InsertOrder, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.InsertOrderBat[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InsertOrderBatReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InsertOrderBatReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InsertOrderBatReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InsertOrderBat)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InsertOrderBat {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *InsertOrderBatReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// InsertOrderBatRsp struct implement
type InsertOrderBatRsp struct {
	InsertOrderRstBat []InsertOrderRst `json:"InsertOrderRstBat"`
}

func (st *InsertOrderBatRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *InsertOrderBatRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.InsertOrderRstBat = make([]InsertOrderRst, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.InsertOrderRstBat[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *InsertOrderBatRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InsertOrderBatRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *InsertOrderBatRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.InsertOrderRstBat)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.InsertOrderRstBat {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *InsertOrderBatRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// OrderCancel struct implement
type OrderCancel struct {
	Account_id     string            `json:"account_id"`
	Order_id       string            `json:"order_id"`
	Instrument_id  string            `json:"instrument_id"`
	Local_order_id string            `json:"local_order_id"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *OrderCancel) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *OrderCancel) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Order_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument_id, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Local_order_id, 3, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 4, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *OrderCancel) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OrderCancel, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *OrderCancel) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Order_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument_id, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Local_order_id, 3)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *OrderCancel) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderBatReq struct implement
type CancelOrderBatReq struct {
	CancelOrderBat []OrderCancel `json:"CancelOrderBat"`
}

func (st *CancelOrderBatReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderBatReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.CancelOrderBat = make([]OrderCancel, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.CancelOrderBat[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderBatReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderBatReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderBatReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.CancelOrderBat)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.CancelOrderBat {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderBatReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderRst struct implement
type CancelOrderRst struct {
	Origin_order_id string `json:"origin_order_id"`
	Cancel_order_id string `json:"cancel_order_id"`
}

func (st *CancelOrderRst) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderRst) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Origin_order_id, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Cancel_order_id, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderRst) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderRst, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderRst) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Origin_order_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Cancel_order_id, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderRst) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// CancelOrderBatRsp struct implement
type CancelOrderBatRsp struct {
	CancelOrderRstBat []CancelOrderRst `json:"CancelOrderRstBat"`
}

func (st *CancelOrderBatRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *CancelOrderBatRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.CancelOrderRstBat = make([]CancelOrderRst, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.CancelOrderRstBat[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *CancelOrderBatRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require CancelOrderBatRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *CancelOrderBatRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.CancelOrderRstBat)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.CancelOrderRstBat {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *CancelOrderBatRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryParam struct implement
type QryParam struct {
	Instrument_id string            `json:"instrument_id"`
	Extend        map[string]string `json:"extend"`
}

func (st *QryParam) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryParam) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Instrument_id, 0, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 1, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extend = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extend[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryParam) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryParam) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Instrument_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extend)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extend {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryParam) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryTransFundReq struct implement
type QryTransFundReq struct {
	Currency_id     string `json:"currency_id"`
	Bank_pwd        string `json:"bank_pwd"`
	Fund_pwd        string `json:"fund_pwd"`
	Bank_code       string `json:"bank_code"`
	Bank_account    string `json:"bank_account"`
	Index           string `json:"index"`
	Max_ret_count   string `json:"max_ret_count"`
	Business_serial string `json:"business_serial"`
}

func (st *QryTransFundReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryTransFundReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Currency_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Bank_pwd, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Fund_pwd, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Bank_code, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Bank_account, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Index, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Max_ret_count, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Business_serial, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryTransFundReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryTransFundReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryTransFundReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Currency_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Bank_pwd, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Fund_pwd, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Bank_code, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Bank_account, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Index, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Max_ret_count, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Business_serial, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QryTransFundReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TransFundInfo struct implement
type TransFundInfo struct {
	Account_id string `json:"account_id"`
	Counter_id string `json:"counter_id"`
	Bank_code  string `json:"bank_code"`
	Trans_type string `json:"trans_type"`
	Trans_amt  string `json:"trans_amt"`
	Serial_no  string `json:"serial_no"`
	Date       string `json:"date"`
	Time       string `json:"time"`
	Sponsor    string `json:"sponsor"`
}

func (st *TransFundInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TransFundInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Counter_id, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Bank_code, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trans_type, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Trans_amt, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Serial_no, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Date, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Time, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Sponsor, 8, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TransFundInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TransFundInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TransFundInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Counter_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Bank_code, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trans_type, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Trans_amt, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Serial_no, 5)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Date, 6)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Time, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Sponsor, 8)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TransFundInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ModAccInfo struct implement
type ModAccInfo struct {
	Account_id   string `json:"account_id"`
	Account_name string `json:"account_name"`
	Passwd       string `json:"passwd"`
	Effective    int32  `json:"effective"`
}

func (st *ModAccInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ModAccInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_name, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Passwd, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Effective, 3, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ModAccInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ModAccInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ModAccInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_name, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Passwd, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Effective, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ModAccInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccLoginInfo struct implement
type AccLoginInfo struct {
	Account_id string `json:"account_id"`
	Pwd        string `json:"pwd"`
}

func (st *AccLoginInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccLoginInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Pwd, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccLoginInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccLoginInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccLoginInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Pwd, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccLoginInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccLoginBatReq struct implement
type AccLoginBatReq struct {
	AccLoginBat []AccLoginInfo `json:"AccLoginBat"`
}

func (st *AccLoginBatReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccLoginBatReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.AccLoginBat = make([]AccLoginInfo, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.AccLoginBat[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccLoginBatReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccLoginBatReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccLoginBatReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.AccLoginBat)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.AccLoginBat {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccLoginBatReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccLoginResult struct implement
type AccLoginResult struct {
	Account_id string `json:"account_id"`
	Rst        Result `json:"rst"`
}

func (st *AccLoginResult) ResetDefault() {
	st.Rst.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccLoginResult) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 1, true)
	if err != nil {
		return err
	}

	err = st.Rst.ReadBlock(readBuf, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccLoginResult) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccLoginResult, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccLoginResult) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 1)
	if err != nil {
		return err
	}

	err = st.Rst.WriteBlock(buf, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AccLoginResult) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccLoginBatRsp struct implement
type AccLoginBatRsp struct {
	AccLoginBat []AccLoginResult `json:"AccLoginBat"`
}

func (st *AccLoginBatRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccLoginBatRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(0, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.AccLoginBat = make([]AccLoginResult, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = st.AccLoginBat[i0].ReadBlock(readBuf, 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccLoginBatRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccLoginBatRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccLoginBatRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.AccLoginBat)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.AccLoginBat {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccLoginBatRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccLogoutBatReq struct implement
type AccLogoutBatReq struct {
	Account_ids []string `json:"account_ids"`
}

func (st *AccLogoutBatReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccLogoutBatReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccLogoutBatReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccLogoutBatReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccLogoutBatReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccLogoutBatReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccLogoutBatRsp struct implement
type AccLogoutBatRsp struct {
	Account_ids []string `json:"account_ids"`
}

func (st *AccLogoutBatRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccLogoutBatRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Account_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Account_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccLogoutBatRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccLogoutBatRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccLogoutBatRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Account_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Account_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccLogoutBatRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// Package Taurus comment
// This file was generated by ksf2go 1.3.21
// Generated from TaurusBypass.ksf
package Taurus

import (
	"fmt"

	"go.k8sf.cloud/go/KsfGo/ksf/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

// ArchiveFinished struct implement
type ArchiveFinished struct {
	Obj           string `json:"obj"`
	Finished_time string `json:"finished_time"`
}

func (st *ArchiveFinished) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ArchiveFinished) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Obj, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Finished_time, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ArchiveFinished) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ArchiveFinished, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ArchiveFinished) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Obj, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Finished_time, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ArchiveFinished) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountProfit struct implement
type AccountProfit struct {
	Account_id              string            `json:"account_id"`
	Cur_date                int32             `json:"cur_date"`
	Total_profit            float64           `json:"total_profit"`
	Week_profit             float64           `json:"week_profit"`
	Month_profit            float64           `json:"month_profit"`
	Three_month_profit      float64           `json:"three_month_profit"`
	Half_year_profit        float64           `json:"half_year_profit"`
	Year_profit             float64           `json:"year_profit"`
	This_year_profit        float64           `json:"this_year_profit"`
	Total_profit_rate       float64           `json:"total_profit_rate"`
	Week_profit_rate        float64           `json:"week_profit_rate"`
	Month_profit_rate       float64           `json:"month_profit_rate"`
	Three_month_profit_rate float64           `json:"three_month_profit_rate"`
	Half_year_profit_rate   float64           `json:"half_year_profit_rate"`
	Year_profit_rate        float64           `json:"year_profit_rate"`
	This_year_profit_rate   float64           `json:"this_year_profit_rate"`
	Extra_params            map[string]string `json:"extra_params"`
}

func (st *AccountProfit) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountProfit) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Cur_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_profit, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Week_profit, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Month_profit, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Three_month_profit, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Half_year_profit, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Year_profit, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.This_year_profit, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_profit_rate, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Week_profit_rate, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Month_profit_rate, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Three_month_profit_rate, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Half_year_profit_rate, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Year_profit_rate, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.This_year_profit_rate, 15, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountProfit) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountProfit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountProfit) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Cur_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_profit, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Week_profit, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Month_profit, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Three_month_profit, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Half_year_profit, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Year_profit, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.This_year_profit, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_profit_rate, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Week_profit_rate, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Month_profit_rate, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Three_month_profit_rate, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Half_year_profit_rate, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Year_profit_rate, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.This_year_profit_rate, 15)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountProfit) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountMonthProfit struct implement
type AccountMonthProfit struct {
	Account_id      string            `json:"account_id"`
	Year            int32             `json:"year"`
	Jan_profit      float64           `json:"jan_profit"`
	Feb_profit      float64           `json:"feb_profit"`
	Mar_profit      float64           `json:"mar_profit"`
	Apr_profit      float64           `json:"apr_profit"`
	May_profit      float64           `json:"may_profit"`
	Jun_profit      float64           `json:"jun_profit"`
	Jul_profit      float64           `json:"jul_profit"`
	Aug_profit      float64           `json:"aug_profit"`
	Sep_profit      float64           `json:"sep_profit"`
	Oct_profit      float64           `json:"oct_profit"`
	Nov_profit      float64           `json:"nov_profit"`
	Dec_profit      float64           `json:"dec_profit"`
	Jan_profit_rate float64           `json:"jan_profit_rate"`
	Feb_profit_rate float64           `json:"feb_profit_rate"`
	Mar_profit_rate float64           `json:"mar_profit_rate"`
	Apr_profit_rate float64           `json:"apr_profit_rate"`
	May_profit_rate float64           `json:"may_profit_rate"`
	Jun_profit_rate float64           `json:"jun_profit_rate"`
	Jul_profit_rate float64           `json:"jul_profit_rate"`
	Aug_profit_rate float64           `json:"aug_profit_rate"`
	Sep_profit_rate float64           `json:"sep_profit_rate"`
	Oct_profit_rate float64           `json:"oct_profit_rate"`
	Nov_profit_rate float64           `json:"nov_profit_rate"`
	Dec_profit_rate float64           `json:"dec_profit_rate"`
	Extra_params    map[string]string `json:"extra_params"`
}

func (st *AccountMonthProfit) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountMonthProfit) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Year, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Jan_profit, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Feb_profit, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Mar_profit, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Apr_profit, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.May_profit, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Jun_profit, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Jul_profit, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Aug_profit, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Sep_profit, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Oct_profit, 11, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Nov_profit, 12, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Dec_profit, 13, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Jan_profit_rate, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Feb_profit_rate, 15, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Mar_profit_rate, 16, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Apr_profit_rate, 17, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.May_profit_rate, 18, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Jun_profit_rate, 19, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Jul_profit_rate, 20, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Aug_profit_rate, 21, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Sep_profit_rate, 22, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Oct_profit_rate, 23, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Nov_profit_rate, 24, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Dec_profit_rate, 25, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 40, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountMonthProfit) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountMonthProfit, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountMonthProfit) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Year, 1)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Jan_profit, 2)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Feb_profit, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Mar_profit, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Apr_profit, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.May_profit, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Jun_profit, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Jul_profit, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Aug_profit, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Sep_profit, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Oct_profit, 11)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Nov_profit, 12)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Dec_profit, 13)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Jan_profit_rate, 14)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Feb_profit_rate, 15)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Mar_profit_rate, 16)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Apr_profit_rate, 17)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.May_profit_rate, 18)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Jun_profit_rate, 19)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Jul_profit_rate, 20)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Aug_profit_rate, 21)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Sep_profit_rate, 22)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Oct_profit_rate, 23)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Nov_profit_rate, 24)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Dec_profit_rate, 25)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 40)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountMonthProfit) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountTradeVolume struct implement
type AccountTradeVolume struct {
	Account_id         string            `json:"account_id"`
	Cur_date           int32             `json:"cur_date"`
	Product            string            `json:"product"`
	Instrument         string            `json:"instrument"`
	Total_volume       float64           `json:"total_volume"`
	Week_volume        float64           `json:"week_volume"`
	Month_volume       float64           `json:"month_volume"`
	Three_month_volume float64           `json:"three_month_volume"`
	Half_year_volume   float64           `json:"half_year_volume"`
	Year_volume        float64           `json:"year_volume"`
	This_year_volume   float64           `json:"this_year_volume"`
	Extra_params       map[string]string `json:"extra_params"`
}

func (st *AccountTradeVolume) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountTradeVolume) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Cur_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Product, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_volume, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Week_volume, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Month_volume, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Three_month_volume, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Half_year_volume, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Year_volume, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.This_year_volume, 10, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountTradeVolume) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountTradeVolume, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountTradeVolume) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Cur_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Product, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument, 3)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_volume, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Week_volume, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Month_volume, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Three_month_volume, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Half_year_volume, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Year_volume, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.This_year_volume, 10)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountTradeVolume) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AccountAdvanceInstrument struct implement
type AccountAdvanceInstrument struct {
	Account_id         string            `json:"account_id"`
	Cur_date           int32             `json:"cur_date"`
	Product            string            `json:"product"`
	Instrument         string            `json:"instrument"`
	Pos_duration       int32             `json:"pos_duration"`
	Total_profit       float64           `json:"total_profit"`
	Week_profit        float64           `json:"week_profit"`
	Month_profit       float64           `json:"month_profit"`
	Three_month_profit float64           `json:"three_month_profit"`
	Half_year_profit   float64           `json:"half_year_profit"`
	Year_profit        float64           `json:"year_profit"`
	This_year_profit   float64           `json:"this_year_profit"`
	Extra_params       map[string]string `json:"extra_params"`
}

func (st *AccountAdvanceInstrument) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AccountAdvanceInstrument) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Account_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Cur_date, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Product, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Instrument, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Pos_duration, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Total_profit, 5, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Week_profit, 6, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Month_profit, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Three_month_profit, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Half_year_profit, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.Year_profit, 10, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadFloat64(&st.This_year_profit, 11, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			var k0 string
			var v0 string

			err = readBuf.ReadString(&k0, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v0, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k0] = v0
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AccountAdvanceInstrument) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AccountAdvanceInstrument, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AccountAdvanceInstrument) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Account_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Cur_date, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Product, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Instrument, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Pos_duration, 4)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Total_profit, 5)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Week_profit, 6)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Month_profit, 7)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Three_month_profit, 8)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Half_year_profit, 9)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.Year_profit, 10)
	if err != nil {
		return err
	}

	err = buf.WriteFloat64(st.This_year_profit, 11)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.Extra_params {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *AccountAdvanceInstrument) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryTaskStatusReq struct implement
type QryTaskStatusReq struct {
	User_id       string            `json:"user_id"`
	Account_group string            `json:"account_group"`
	Task_ids      []string          `json:"task_ids"`
	Main_ids      []string          `json:"main_ids"`
	Parent_ids    []string          `json:"parent_ids"`
	Status        string            `json:"status"`
	Start_time    string            `json:"start_time"`
	End_time      string            `json:"end_time"`
	Brow_index    string            `json:"brow_index"`
	Record_count  int32             `json:"record_count"`
	Extra_params  map[string]string `json:"extra_params"`
}

func (st *QryTaskStatusReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryTaskStatusReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_group, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Task_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Task_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Main_ids = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.Main_ids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Parent_ids = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Parent_ids[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Status, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Start_time, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 15, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 string
			var v3 string

			err = readBuf.ReadString(&k3, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v3, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k3] = v3
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryTaskStatusReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryTaskStatusReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryTaskStatusReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_group, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Task_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Task_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Main_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Main_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Parent_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Parent_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Status, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Start_time, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 15)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.Extra_params {

		err = buf.WriteString(k4, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v4, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryTaskStatusReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryTaskStatusRsp struct implement
type QryTaskStatusRsp struct {
	Vec_task []TaskStatus `json:"vec_task"`
}

func (st *QryTaskStatusRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryTaskStatusRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_task = make([]TaskStatus, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_task[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryTaskStatusRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryTaskStatusRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryTaskStatusRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_task)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_task {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryTaskStatusRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryParentOrderReq struct implement
type QryParentOrderReq struct {
	User_id        string            `json:"user_id"`
	Account_group  string            `json:"account_group"`
	Task_ids       []string          `json:"task_ids"`
	P_order_ids    []string          `json:"p_order_ids"`
	Instrument_ids []string          `json:"instrument_ids"`
	Status         string            `json:"status"`
	Start_time     string            `json:"start_time"`
	End_time       string            `json:"end_time"`
	Brow_index     string            `json:"brow_index"`
	Record_count   int32             `json:"record_count"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *QryParentOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryParentOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_group, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Task_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Task_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.P_order_ids = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.P_order_ids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Instrument_ids = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.Instrument_ids[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Status, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Start_time, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 15, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {
			var k3 string
			var v3 string

			err = readBuf.ReadString(&k3, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v3, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k3] = v3
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryParentOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryParentOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryParentOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_group, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Task_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Task_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.P_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.P_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Instrument_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Instrument_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Status, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Start_time, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 15)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k4, v4 := range st.Extra_params {

		err = buf.WriteString(k4, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v4, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryParentOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryParentOrderRsp struct implement
type QryParentOrderRsp struct {
	Vec_parent_order []ParentOrder `json:"vec_parent_order"`
}

func (st *QryParentOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryParentOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_parent_order = make([]ParentOrder, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_parent_order[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryParentOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryParentOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryParentOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_parent_order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_parent_order {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryParentOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryChildOrderReq struct implement
type QryChildOrderReq struct {
	User_id        string            `json:"user_id"`
	Account_group  string            `json:"account_group"`
	Task_ids       []string          `json:"task_ids"`
	P_order_ids    []string          `json:"p_order_ids"`
	C_order_ids    []string          `json:"c_order_ids"`
	S_order_ids    []string          `json:"s_order_ids"`
	Instrument_ids []string          `json:"instrument_ids"`
	Status         string            `json:"status"`
	Start_time     string            `json:"start_time"`
	End_time       string            `json:"end_time"`
	Brow_index     string            `json:"brow_index"`
	Record_count   int32             `json:"record_count"`
	Extra_params   map[string]string `json:"extra_params"`
}

func (st *QryChildOrderReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryChildOrderReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.User_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Account_group, 1, false)
	if err != nil {
		return err
	}

	have, ty, err = readBuf.SkipToNoCheck(2, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Task_ids = make([]string, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = readBuf.ReadString(&st.Task_ids[i0], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(3, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.P_order_ids = make([]string, length)
			for i1, e1 := int32(0), length; i1 < e1; i1++ {

				err = readBuf.ReadString(&st.P_order_ids[i1], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(4, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.C_order_ids = make([]string, length)
			for i2, e2 := int32(0), length; i2 < e2; i2++ {

				err = readBuf.ReadString(&st.C_order_ids[i2], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(5, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.S_order_ids = make([]string, length)
			for i3, e3 := int32(0), length; i3 < e3; i3++ {

				err = readBuf.ReadString(&st.S_order_ids[i3], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	have, ty, err = readBuf.SkipToNoCheck(6, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Instrument_ids = make([]string, length)
			for i4, e4 := int32(0), length; i4 < e4; i4++ {

				err = readBuf.ReadString(&st.Instrument_ids[i4], 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	err = readBuf.ReadString(&st.Status, 7, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Start_time, 8, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.End_time, 9, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Brow_index, 14, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&st.Record_count, 15, false)
	if err != nil {
		return err
	}

	have, err = readBuf.SkipTo(codec.MAP, 30, false)
	if err != nil {
		return err
	}

	if have {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.Extra_params = make(map[string]string)
		for i5, e5 := int32(0), length; i5 < e5; i5++ {
			var k5 string
			var v5 string

			err = readBuf.ReadString(&k5, 0, false)
			if err != nil {
				return err
			}

			err = readBuf.ReadString(&v5, 1, false)
			if err != nil {
				return err
			}

			st.Extra_params[k5] = v5
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryChildOrderReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryChildOrderReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryChildOrderReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.User_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Account_group, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.LIST, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Task_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Task_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 3)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.P_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.P_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 4)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.C_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.C_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 5)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.S_order_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.S_order_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteHead(codec.LIST, 6)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Instrument_ids)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Instrument_ids {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	err = buf.WriteString(st.Status, 7)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Start_time, 8)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.End_time, 9)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Brow_index, 14)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(st.Record_count, 15)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 30)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Extra_params)), 0)
	if err != nil {
		return err
	}

	for k6, v6 := range st.Extra_params {

		err = buf.WriteString(k6, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v6, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryChildOrderReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QryChildOrderRsp struct implement
type QryChildOrderRsp struct {
	Vec_child_order []ChildOrder `json:"vec_child_order"`
}

func (st *QryChildOrderRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QryChildOrderRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	have, ty, err = readBuf.SkipToNoCheck(0, false)
	if err != nil {
		return err
	}

	if have {
		if ty == codec.LIST {
			err = readBuf.ReadInt32(&length, 0, true)
			if err != nil {
				return err
			}

			st.Vec_child_order = make([]ChildOrder, length)
			for i0, e0 := int32(0), length; i0 < e0; i0++ {

				err = st.Vec_child_order[i0].ReadBlock(readBuf, 0, false)
				if err != nil {
					return err
				}

			}
		} else if ty == codec.SimpleList {
			err = fmt.Errorf("not support SimpleList type")
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not")
			if err != nil {
				return err
			}

		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QryChildOrderRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QryChildOrderRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QryChildOrderRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 0)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.Vec_child_order)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.Vec_child_order {

		err = v.WriteBlock(buf, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *QryChildOrderRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// PutTaskDataReq struct implement
type PutTaskDataReq struct {
	Task_id string `json:"task_id"`
	Data    string `json:"data"`
}

func (st *PutTaskDataReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *PutTaskDataReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Task_id, 0, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.Data, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *PutTaskDataReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require PutTaskDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *PutTaskDataReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Task_id, 0)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.Data, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *PutTaskDataReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryTaskDataReq struct implement
type QueryTaskDataReq struct {
	Task_id string `json:"task_id"`
}

func (st *QueryTaskDataReq) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryTaskDataReq) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Task_id, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryTaskDataReq) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryTaskDataReq, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryTaskDataReq) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Task_id, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryTaskDataReq) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// QueryTaskDataRsp struct implement
type QueryTaskDataRsp struct {
	Data string `json:"data"`
}

func (st *QueryTaskDataRsp) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *QueryTaskDataRsp) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.Data, 0, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *QueryTaskDataRsp) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require QueryTaskDataRsp, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *QueryTaskDataRsp) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.Data, 0)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *QueryTaskDataRsp) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}
